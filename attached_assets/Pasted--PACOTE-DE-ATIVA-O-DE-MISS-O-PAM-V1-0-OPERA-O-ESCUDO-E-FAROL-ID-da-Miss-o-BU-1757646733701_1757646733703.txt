### **PACOTE DE ATIVAÇÃO DE MISSÃO (PAM) V1.0 - OPERAÇÃO "ESCUDO E FAROL"**

**ID da Missão:** `BUGFIX-FORMALIZATION-TIMELINE-001-STEP4`

**Ferramenta Alocada:** `Sniper` - Missão de Nível 1 (Simples)

---

#### **Sumário da Missão (O Quê):**

Realizar a blindagem final do fluxo de formalização, implementando tratamento de erros explícito na UI e enriquecendo a observabilidade no backend com logs estruturados para auditoria.

#### **Intenção Estratégica (O Porquê):**

Uma funcionalidade que falha silenciosamente é um risco inaceitável. O usuário precisa de feedback claro quando uma operação falha, e a equipe de operações precisa de logs detalhados para diagnosticar problemas rapidamente em produção. Esta missão transforma um fluxo funcional em um fluxo **resiliente e auditável**, cumprindo nossos Requisitos Não-Funcionais (NFRs) de manutenibilidade e confiabilidade.

#### **Histórico Relevante (Consulta Obrigatória):**

* A auditoria forense (`...-AUDIT`) revelou que o logging no fluxo original era inadequado, utilizando apenas `console.log`.
* A "Operação Restauração do Núcleo" (`...-STEP1`) introduziu `UseCases` no backend, que agora são o local ideal para centralizar a lógica de logging.
* O hook `useMutation` no frontend já possui um callback `onError` que pode ser utilizado para exibir feedback de erro.

#### **Modelo Mental (Como se Encaixa):**

Você está operando de forma transversal em duas camadas:
1.  **Backend (Observabilidade):** Adicionando "faróis" (logs) nos `UseCases` para iluminar a execução da lógica de negócio.
2.  **Frontend (Resiliência):** Adicionando "escudos" (feedback de erro) na UI para proteger a experiência do usuário contra falhas inesperadas.

#### **Riscos Antecipados e Contramedidas:**

1.  **Risco de Informação Insuficiente (Baixo):** Logs genéricos que não contêm contexto (como IDs) são inúteis para depuração.
    * **Contramedida Mandatória:** Os logs de erro **DEVEM** incluir o `propostaId`, `userId`, e a mensagem de erro específica capturada no bloco `catch`.

* * *

#### **IMPLEMENTAR:**

Blindagem Transversal e Melhoria de Observabilidade.

#### **CURRENT STATE:**

O fluxo de formalização funciona no "caminho feliz". No entanto, se o backend retornar um erro (ex: `DomainException` por transição de estado inválida), a UI não informa o usuário sobre a falha. Os logs de backend para este fluxo são insuficientes para uma auditoria eficaz.

#### **EXPECTED (Estado Final de Sucesso):**

1.  No componente `EtapaFormalizacaoControl.tsx`, o callback `onError` do hook `updateEtapa` foi implementado para exibir um toast de erro (`toast.error`) com uma mensagem clara para o usuário.
2.  Nos `UseCases` `MarcarAssinaturaConcluidaUseCase.ts` e `MarcarAguardandoAssinaturaUseCase.ts`, a lógica de `catch` agora inclui `logger.error` para registrar falhas, incluindo o `propostaId` e a mensagem de erro.

#### **CONSTRAINTS (Roadmap de Implementação):**

Siga estes passos em ordem rigorosa.

**Passo 4.1: [FRONTEND] Implementar Feedback de Erro**
* Navegue até o arquivo `client/src/components/propostas/EtapaFormalizacaoControl.tsx`.
* Localize o hook `useMutation` chamado `updateEtapa`.
* Adicione um callback `onError` à sua definição.
* Dentro do `onError`, chame a função `toast.error("Ocorreu um erro ao atualizar a etapa. Por favor, tente novamente.")`.

**Passo 4.2: [BACKEND] Enriquecer Logs de Falha**
* Navegue até o arquivo `server/routes.ts`.
* Localize o endpoint `PATCH /api/propostas/:id/etapa-formalizacao`.
* No bloco `catch`, onde a `DomainException` é capturada, adicione uma instrução de log antes de enviar a resposta: `logError('Falha na transição de status manual', { propostaId: id, userId: req.user?.id, error: err.message });`

* * *

#### **DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**

* **CONFIANÇA NA IMPLEMENTAÇÃO:** 98%
* **RISCOS IDENTIFICADOS:** **BAIXO**. A complexidade da tarefa é mínima. O principal risco é um erro de digitação nos parâmetros de log.
* **DECISÕES TÉCNICAS ASSUMIDAS:** Estamos adicionando o log de erro no controller (`routes.ts`) em vez de no `UseCase` para capturar a falha de validação e logar o contexto da requisição (como o `userId`).
* **VALIDAÇÃO PENDENTE:** O QA (GEM 03) deverá testar o "caminho infeliz": tentar marcar uma etapa como concluída quando a FSM não permitir (ex: clicar duas vezes rapidamente) e verificar se um toast de erro aparece na UI e se um log de erro correspondente é gerado no backend.

* * *

#### **PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**

1.  Mapeie os **3 arquivos modificados**: `EtapaFormalizacaoControl.tsx`, e `routes.ts`.
2.  Garanta que o `toast` e o `logError` estão sendo importados e utilizados corretamente.
3.  Execute `get_latest_lsp_diagnostics` e corrija **TODOS** os erros.
4.  Declare seu **Nível de Confiança (0-100%)** final.
5.  Categorize quaisquer **Riscos Descobertos**.
6.  Realize o teste funcional completo do "caminho infeliz" conforme descrito na seção "Validação Pendente".
7.  Documente a decisão de logar o erro no controller para capturar o contexto da requisição.