### Pacote de Ativação de Missão (PAM) V1.0 - Sprint 2 / US S2-003: Padrão Unit of Work

* **Sumário da Missão (O Quê):** Implementar o Padrão Unit of Work (UoW) para gerir transações atômicas na base de dados, garantindo que operações de negócio complexas que envolvem múltiplos repositórios sejam executadas como uma única unidade indivisível.
* **Intenção Estratégica (O Porquê):** Garantir a integridade e consistência dos dados em cenários de negócio críticos (ex: aprovação de proposta, geração de CCB). O UoW previne estados de dados parciais ou corruptos em caso de falha a meio de uma operação, um requisito não negociável para um sistema de nível bancário.
* **Modelo Mental (Como se Encaixa):** Você é um engenheiro de backend sênior focado em resiliência e integridade de dados. Sua tarefa é criar um gestor de transações que orquestre o trabalho de múltiplos repositórios, garantindo que todas as alterações sejam confirmadas (`commit`) ou revertidas (`rollback`) em conjunto.

---

**IMPLEMENTAR (Plano de Implementação):**
Execute a seguinte sequência de ações para implementar o Padrão Unit of Work.

**CURRENT STATE:**
A camada de repositórios foi implementada. Os serviços de aplicação (`use cases`) podem estar a chamar múltiplos repositórios sequencialmente, mas sem uma garantia transacional entre eles.

**EXPECTED (Estado Final de Sucesso):**
1.  Uma classe ou interface `UnitOfWork` existe, fornecendo acesso aos repositórios e métodos para `commit` e `rollback`.
2.  Os serviços de aplicação (Use Cases) que modificam múltiplos agregados são refatorados para usar a instância do `UnitOfWork`, garantindo que todas as operações de persistência dentro do caso de uso ocorram dentro de uma única transação.

**CONSTRAINTS (Roadmap de Implementação):**

**Passo 1: Criar a Abstração e Implementação do Unit of Work**
1.1. Crie um novo ficheiro `server/modules/shared/domain/IUnitOfWork.ts`.
1.2. Defina a interface `IUnitOfWork`, que deve expor instâncias dos repositórios (`proposals`, `ccbs`, `boletos`, etc.) e os métodos `executeInTransaction(work: () => Promise<T>): Promise<T>`.
1.3. Crie a implementação concreta em `server/modules/shared/infrastructure/UnitOfWork.ts`. O método `executeInTransaction` deve utilizar a funcionalidade `db.transaction()` do Drizzle para envolver as operações. Dentro do *callback* da transação, os repositórios devem ser instanciados com o cliente de transação do Drizzle.

**Passo 2: Integrar o Unit of Work nos Use Cases Críticos**
2.1. Identifique um serviço de aplicação (Use Case) crítico que modifica múltiplos agregados, como o fluxo de aprovação de uma proposta que também precisa criar um registo de CCB.
2.2. Refatore este *use case* para receber uma instância do `UnitOfWork` (via injeção de dependência).
2.3. Envolva toda a lógica de negócio que interage com os repositórios dentro do método `uow.executeInTransaction(...)`. As chamadas aos repositórios (`save`, `update`, etc.) devem agora usar as instâncias de repositório fornecidas pelo UoW (ex: `uow.proposals.save(...)`).

**Passo 3: Validação Final**
3.1. Apresente o conteúdo dos ficheiros `IUnitOfWork.ts` e `UnitOfWork.ts`.
3.2. Apresente o *snippet* de código do *use case* refatorado, mostrando como o `UnitOfWork` é utilizado para garantir a atomicidade da operação.
3.3. Execute `get_latest_lsp_diagnostics` para garantir que a refatoração não introduziu erros.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** 95%
* **RISCOS IDENTIFICADOS:** BAIXO. A principal complexidade está em passar corretamente o contexto da transação do Drizzle para cada instância de repositório criada dentro do UoW.
* **DECISÕES TÉCNICAS ASSUMIDAS:** O Unit of Work será implementado como uma classe que pode ser injetada nos serviços de aplicação, promovendo um design limpo e testável.
* **VALIDAÇÃO PENDENTE:** A eficácia do UoW em reverter transações em caso de falha será validada por testes de integração no Sprint 3.