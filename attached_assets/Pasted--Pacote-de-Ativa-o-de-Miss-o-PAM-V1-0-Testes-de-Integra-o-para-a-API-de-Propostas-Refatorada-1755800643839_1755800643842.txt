### Pacote de Ativação de Missão (PAM) V1.0 (Testes de Integração para a API de Propostas Refatorada)

* **Sumário da Missão (O Quê):** Criar uma suíte de testes de integração completa para a nova API de Propostas, validando os seus principais endpoints (`POST /`, `GET /:id`, etc.) que agora operam sob a nova arquitetura DDD.
* **Intenção Estratégica (O Porquê):** Garantir, com prova automatizada, que a refatoração massiva para a arquitetura DDD não introduziu nenhuma regressão funcional. Estes testes servirão como a "certificação de qualidade" final para o nosso novo Bounded Context de Propostas.
* **Histórico Relevante (Consulta Obrigatória):** A missão anterior ativou a nova API de Propostas, que agora é orquestrada pelo `proposalController` e utiliza os `UseCases`. A nossa infraestrutura de testes de integração (`db-helper.ts`, `supertest`, ambiente isolado) está 100% operacional.
* **Modelo Mental (Como se Encaixa):** Aja como um Engenheiro de QA em Automação. Sua tarefa é escrever testes de "caixa-preta" que validem o comportamento da API do ponto de vista de um cliente externo, sem conhecer os detalhes da sua implementação interna.

---

**IMPLEMENTAR:**
Suíte de Testes de Integração para a API de Propostas DDD

**CURRENT STATE:**
A nova API de Propostas está ativa, mas a sua funcionalidade de ponta a ponta (desde a rota HTTP até a persistência no banco de dados através da nova arquitetura) não está coberta por testes de integração automatizados.

**EXPECTED (Estado Final de Sucesso):**
1.  Um novo arquivo de teste, `tests/integration/proposal-api.test.ts`, é criado.
2.  A suíte de testes utiliza `vitest` e `supertest` para fazer chamadas HTTP reais à aplicação em um ambiente de teste isolado.
3.  Os hooks `beforeEach` e `afterEach` utilizam os helpers `cleanTestDatabase` e `setupTestEnvironment` para garantir o isolamento dos testes.
4.  São criados testes para cobrir, no mínimo, os seguintes cenários críticos:
    * **Cenário 1 (Criação de Proposta - Sucesso):** Um teste que envia um `payload` válido para `POST /api/propostas`. As asserções devem verificar se:
        * A resposta da API é `201 Created`.
        * A proposta foi de fato criada no banco de dados.
    * **Cenário 2 (Criação de Proposta - Falha de Validação):** Um teste que envia um `payload` inválido (ex: `valor_solicitado` fora dos limites definidos no Agregado) para `POST /api/propostas`. A asserção deve verificar se a resposta da API é `400 Bad Request`.
    * **Cenário 3 (Busca de Proposta):** Um teste que primeiro cria uma proposta e depois faz uma chamada para `GET /api/propostas/:id` com o ID da proposta criada. A asserção deve verificar se a resposta é `200 OK` e se os dados retornados correspondem aos da proposta criada.

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Reutilize a Infraestrutura de Teste:** O teste DEVE usar os helpers `cleanTestDatabase` e `setupTestEnvironment` e a lógica de autenticação que já estabelecemos nas missões anteriores.
2.  **Foco nos Contratos da API:** Teste o comportamento externo da API (status de resposta, payload de retorno), não os detalhes da sua implementação interna.
3.  **Validação no Banco de Dados:** Para o cenário de criação bem-sucedida, a sua asserção final DEVE incluir uma consulta direta ao banco de dados para confirmar que os dados foram persistidos corretamente.
4.  **Validação Final Mandatória:** A prova de sucesso é a execução bem-sucedida da nova suíte de testes.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Ex: "Assumi que a lógica de autenticação nos testes pode ser reutilizada sem modificações."]
* **VALIDAÇÃO PENDENTE:** [Nenhuma. O sucesso é definido pela passagem de 100% dos novos testes de integração.]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear ficheiros e funções exatas afetadas (criação do novo arquivo de teste).
2.  Garantir que os cenários de teste estão corretamente implementados com `supertest` e `vitest`.
3.  Executar `get_latest_lsp_diagnostics` para garantir 0 erros novos.
4.  **Declarar Nível de Confiança (0 a 100%)**.
5.  **Categorizar Riscos Descobertos**.
6.  **Realizar teste funcional completo** (executar a nova suíte de testes e garantir que todos passem).
7.  **Documentar Decisões Técnicas**.