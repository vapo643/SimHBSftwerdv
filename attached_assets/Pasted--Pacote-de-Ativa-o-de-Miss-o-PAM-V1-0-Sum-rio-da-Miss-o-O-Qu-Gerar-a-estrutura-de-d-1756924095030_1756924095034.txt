### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Gerar a estrutura de diretórios e o conteúdo detalhado do "Blueprint Estratégico e Arquitetural" em formato Markdown, com um mínimo de 1000 linhas, para servir como a fundação documental do projeto Simpix.
* **Intenção Estratégica (O Porquê):** Materializar o conhecimento tácito do projeto Simpix em um documento formal, servindo como a "verdade imutável" da arquitetura para garantir alinhamento, consistência e facilitar o onboarding de futuras instâncias de IA ou membros da equipe.
* **Histórico Relevante (Consulta Obrigatória):** A arquitetura foi concebida com base nas melhores práticas para aplicações web full-stack, priorizando a segurança, escalabilidade e uma experiência de desenvolvedor de elite.
* **Modelo Mental (Como se Encaixa):** Este é o segundo e mais importante documento do Dossiê de Continuidade de Projeto (DCP). Ele define o "porquê" e o "o quê" do projeto, servindo de alicerce para os documentos subsequentes que detalharão o "como".
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** O Agente pode gerar conteúdo genérico e superficial, não atingindo a profundidade necessária.
    * **Contramedida:** O prompt abaixo foi massivamente enriquecido com contexto detalhado e exemplos específicos para cada seção, forçando a IA a expandir sobre uma base sólida em vez de criar do zero.

---

**IMPLEMENTAR:**
Criar a estrutura de pastas e o primeiro documento mestre do projeto Simpix, o "Blueprint Estratégico e Arquitetural".

**CURRENT STATE:**
O projeto existe, mas a sua documentação arquitetural fundamental ainda não foi formalizada em artefatos versionáveis. O conhecimento reside de forma tácita na equipe.

**EXPECTED (Estado Final de Sucesso):**
1.  Um novo diretório chamado `docs` deve ser criado na raiz do projeto.
2.  Dentro de `/docs`, um novo arquivo chamado `02-blueprint-arquitetural.md` deve ser criado.
3.  Este arquivo deve conter uma documentação extremamente detalhada, com no mínimo 1000 linhas, seguindo a estrutura e o conteúdo definidos nas constraints abaixo.

**CONSTRAINTS (Roadmap de Implementação do Documento):**

Você deve escrever o conteúdo do arquivo `02-blueprint-arquitetural.md` em formato Markdown. O documento deve ser abrangente, técnico e profissional. Expanda cada um dos pontos a seguir com o máximo de detalhes possível.

**# Blueprint Estratégico e Arquitetural do Projeto Simpix**

## 1. Visão da Missão e Intenção Estratégica

### 1.1. Problema de Negócio
Expanda detalhadamente sobre o problema fundamental que o "Simpix" se propõe a resolver.
**Contexto para expandir:** "Simpix é uma plataforma SaaS (Software as a Service) projetada para capacitar pequenos prestadores de serviços (ex: eletricistas, encanadores, designers freelancers, consultores) a gerenciar e escalar seus negócios. O problema principal é que esses profissionais são especialistas em sua área, mas carecem de ferramentas acessíveis e integradas para gerenciar agendamentos, propostas, pagamentos e comunicação com clientes. Atualmente, eles recorrem a uma colcha de retalhos de ferramentas desconexas como planilhas, aplicativos de mensagem e e-mails. Este método fragmentado gera ineficiência operacional, perda de oportunidades de negócio por falta de acompanhamento, e projeta uma imagem de amadorismo que limita seu potencial de crescimento."

### 1.2. Solução Proposta
Elabore sobre como a plataforma Simpix aborda diretamente cada faceta do problema.
**Contexto para expandir:** "Simpix oferece um painel de controle centralizado e intuitivo que atua como o centro de comando para o negócio do prestador de serviço. A plataforma integra verticalmente as funções essenciais: (1) **Gestão de Perfil Profissional:** Permite a criação de uma página pública com portfólio, serviços e avaliações. (2) **Agendamento Inteligente:** Um calendário que sincroniza com agendas externas (Google Calendar) e permite que clientes agendem horários disponíveis online. (3) **Gestão de Propostas e Orçamentos:** Ferramenta para criar, enviar e rastrear propostas padronizadas, com status (enviado, visualizado, aceito, rejeitado). (4) **Processamento de Pagamentos:** Integração segura com Stripe para aceitar pagamentos com cartão de crédito diretamente pelas propostas ou agendamentos. (5) **CRM Simplificado:** Um histórico de comunicação e serviços centralizado por cliente, melhorando o relacionamento e a recorrência."

### 1.3. Métricas de Sucesso (KPIs)
Defina e detalhe as métricas que serão usadas para medir o sucesso do projeto.
**Contexto para expandir:**
* **North Star Metric:** Número de Agendamentos Concluídos por Semana. Esta métrica representa o valor central entregue tanto para o prestador (trabalho realizado) quanto para o cliente (serviço recebido).
* **KPIs Primários:**
    * **Taxa de Conversão (Proposta para Serviço):** Percentual de propostas enviadas que são aceitas e se tornam serviços. Mede a eficácia da ferramenta de propostas.
    * **Receita Mensal Recorrente (MRR):** A receita previsível gerada pelas assinaturas da plataforma.
    * **Custo de Aquisição de Cliente (CAC):** O custo total de marketing e vendas para adquirir um novo prestador de serviço pagante.
    * **Lifetime Value (LTV):** A receita total esperada de um cliente ao longo de sua vida na plataforma. A relação LTV/CAC deve ser de no mínimo 3:1.
* **KPIs Secundários:**
    * **Taxa de Ativação de Novos Usuários:** Percentual de novos usuários que completam os 3 passos críticos do onboarding (criar perfil, cadastrar primeiro serviço, conectar calendário) na primeira semana.
    * **Engajamento Semanal (WAU - Weekly Active Users):** Número de prestadores que realizam pelo menos uma ação de valor (enviar proposta, confirmar agendamento) por semana.

## 2. Princípios Arquiteturais Core

### 2.1. Segurança por Padrão (Security by Default)
Elabore sobre a filosofia de segurança do projeto.
**Contexto para expandir:** "A arquitetura adota uma postura de 'confiança zero'. Nenhum acesso a dados é permitido implicitamente. O acesso é negado por padrão e liberado de forma granular e explícita através de políticas de Row Level Security (RLS) no Supabase, que são ativadas em todas as tabelas. Todos os inputs de usuário, sem exceção, são tratados como não confiáveis e devem passar por validação e sanitização no servidor antes de serem processados. A autenticação é delegada integralmente à solução robusta do Supabase Auth (GoTrue), aproveitando seus mecanismos de segurança testados. Credenciais, chaves de API e outros segredos são gerenciados exclusivamente através do sistema de Secrets do ambiente, sendo terminantemente proibido o 'hard-coding'."

### 2.2. Estado Atômico e Previsível
Justifique a abordagem de gerenciamento de estado no frontend.
**Contexto para expandir:** "Para a gestão de estado no frontend, adotamos o Jotai. Este princípio dita que o estado da aplicação deve ser decomposto em suas menores unidades lógicas e independentes possíveis, chamadas 'átomos'. Esta abordagem garante re-renderizações mínimas, pois os componentes se inscrevem apenas nos átomos específicos de que necessitam. Isso resulta em uma performance superior e um fluxo de dados explícito e fácil de depurar, evitando os problemas de re-renders em cascata e complexidade de seletores comuns em soluções de estado globais monolíticas."

### 2.3. API-First e Contratos Claros
Descreva a arquitetura de comunicação entre o cliente e o servidor.
**Contexto para expandir:** "A comunicação entre o frontend (Remix) e o backend (Supabase) é governada por um contrato estrito e bem definido. As funções `loaders` (para busca de dados) e `actions` (para mutações de dados) do Remix atuam como a camada de API para o cliente. Toda a lógica de negócio crítica, validações e interações com o banco de dados residem exclusivamente no servidor, dentro dessas funções. Isso garante que o cliente (browser) seja o mais 'leve' possível e que a lógica de negócio sensível nunca seja exposta."

### 2.4. Developer Experience (DX) as a Priority
Explique por que a experiência do desenvolvedor é um pilar do projeto.
**Contexto para expandir:** "A pilha tecnológica e as ferramentas foram escolhidas não apenas pela performance do produto final, mas pela produtividade, segurança e satisfação que oferecem à equipe de engenharia. O uso mandatório de TypeScript garante segurança de tipos em tempo de compilação. A combinação de ESLint e Prettier impõe um padrão de código limpo e consistente de forma automática. O ambiente de desenvolvimento do Remix com Vite e Hot Module Replacement (HMR) fornece um ciclo de feedback quase instantâneo, acelerando a iteração e a depuração."

## 3. A "Golden Stack" Detalhada

### 3.1. Framework Full-Stack: Remix.js
Justifique detalhadamente a escolha do Remix.
**Contexto para expandir:** "Remix foi escolhido por sua arquitetura que abraça os fundamentos da web, resultando em aplicações mais resilientes e performáticas. Seu modelo de `loaders` e `actions` co-localizados com as rotas simplifica radicalmente o fluxo de dados, elimina a complexidade do gerenciamento de estado de busca de dados no cliente e previne 'waterfalls' de requisições. O sistema de roteamento aninhado permite a criação de layouts componentizados e otimiza o carregamento de dados e código, carregando apenas o necessário para cada view. A filosofia de 'Progressive Enhancement' garante que a aplicação seja funcional mesmo em condições de rede adversas ou sem JavaScript, melhorando a acessibilidade e o SEO."

### 3.2. Backend as a Service: Supabase
Justifique detalhadamente a escolha do Supabase.
**Contexto para expandir:** "Supabase foi selecionado como nossa fundação de backend por ser uma alternativa open-source robusta, construída sobre PostgreSQL, um padrão da indústria. Esta escolha mitiga o risco de 'vendor lock-in' associado a soluções proprietárias. Supabase nos fornece um conjunto integrado e escalável de ferramentas essenciais: um banco de dados PostgreSQL completo, um sistema de Autenticação robusto, Armazenamento de arquivos e Edge Functions para lógica serverless. A sua principal vantagem de segurança é a implementação nativa de Row Level Security (RLS), que nos permite definir políticas de acesso a dados diretamente no banco de dados, garantindo um controle de acesso à prova de falhas."

### 3.3. Linguagem: TypeScript
Justifique detalhadamente a escolha do TypeScript.
**Contexto para expandir:** "O uso de TypeScript em todo o projeto (frontend e backend) é inegociável. A tipagem estática nos permite capturar uma vasta gama de erros em tempo de compilação, antes que cheguem à produção. O código se torna auto-documentado, pois os tipos e interfaces definem contratos claros entre as diferentes partes do sistema. Isso melhora drasticamente a manutenibilidade, facilita a refatoração segura e potencializa o suporte da IDE com autocompletar inteligente e navegação de código precisa. A segurança e a clareza que o TypeScript proporciona em projetos de longo prazo superam em muito o pequeno custo inicial de adicionar as anotações de tipo."

### 3.4. Estilização: TailwindCSS
Justifique detalhadamente a escolha do TailwindCSS.
**Contexto para expandir:** "TailwindCSS foi adotado por sua abordagem 'utility-first'. Em vez de escrever CSS personalizado em arquivos separados, construímos interfaces complexas aplicando classes de utilidade diretamente no HTML/JSX. Isso mantém a lógica de estilização co-localizada com o componente, melhora a consistência do design system e previne o crescimento de CSS não utilizado. O uso do plugin `prettier-plugin-tailwindcss` garante que as classes sejam sempre ordenadas de forma lógica e consistente, mantendo a legibilidade do código."

### 3.5. Estratégia de Testes: Vitest & Playwright
Justifique detalhadamente a escolha das ferramentas de teste.
**Contexto para expandir:** "Nossa estratégia de testes é multifacetada para garantir a qualidade em todos os níveis.
* **Testes Unitários e de Integração:** Utilizamos o **Vitest** por sua integração nativa e otimizada com o ambiente Vite do Remix. Sua alta velocidade, suporte a HMR e API compatível com Jest proporcionam um ciclo de desenvolvimento de testes rápido e eficiente.
* **Testes End-to-End (E2E):** Utilizamos o **Playwright** para simular as interações do usuário em um navegador real. Foi escolhido por sua robustez, capacidade de 'auto-waiting' que reduz drasticamente a instabilidade ('flakiness') dos testes, e suas excelentes ferramentas de depuração como o Trace Viewer, que nos permite analisar execuções de teste passo a passo."

## 4. Diagrama de Entidade-Relacionamento (ERD) do Banco de Dados

### 4.1. Representação Textual (Código SQL `CREATE TABLE`)
Gere o código SQL completo e comentado para as tabelas principais do banco de dados Simpix, incluindo tipos de dados, chaves primárias, chaves estrangeiras, constraints e comentários explicativos para cada tabela e coluna relevante.
**Contexto para expandir (gere o código SQL completo a partir daqui):**
```sql
-- Habilita a extensão pgcrypto para usar gen_random_uuid() se não estiver habilitada
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Tabela para armazenar informações de todos os usuários da plataforma.
-- Serve como a tabela central de autenticação.
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT UNIQUE NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    full_name TEXT,
    avatar_url TEXT CHECK (avatar_url ~* '^https?://.+$'),
    role TEXT NOT NULL DEFAULT 'client' CHECK (role IN ('provider', 'client')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    
    -- Coluna para referenciar o ID de usuário do Supabase Auth
    auth_user_id UUID UNIQUE
);
COMMENT ON TABLE users IS 'Armazena todos os usuários da plataforma, tanto prestadores de serviço quanto clientes. O ID é o nosso identificador interno.';
COMMENT ON COLUMN users.role IS 'Define a permissão do usuário: "provider" (prestador de serviço) ou "client" (cliente).';

-- Tabela para armazenar perfis detalhados e públicos dos prestadores de serviço.
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    professional_title TEXT,
    bio TEXT,
    phone_number TEXT,
    website_url TEXT CHECK (website_url ~* '^https?://.+$'),
    -- Outros campos específicos do perfil, como localização, etc.
    updated_at TIMESTAMPTZ
);
COMMENT ON TABLE profiles IS 'Dados adicionais e específicos para usuários com o papel de "provider", formando seu perfil público.';

-- Tabela para armazenar os serviços específicos oferecidos pelos prestadores.
CREATE TABLE services (
    id BIGSERIAL PRIMARY KEY,
    provider_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title TEXT NOT NULL CHECK (char_length(title) > 0),
    description TEXT,
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    duration_minutes INT CHECK (duration_minutes > 0),
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ
);
COMMENT ON TABLE services IS 'Catálogo de serviços oferecidos por cada prestador, com preço e duração.';
CREATE INDEX idx_services_provider_id ON services(provider_id);

-- Tabela para gerenciar agendamentos de serviços.
CREATE TABLE bookings (
    id BIGSERIAL PRIMARY KEY,
    client_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    service_id BIGINT NOT NULL REFERENCES services(id) ON DELETE CASCADE,
    scheduled_at TIMESTAMPTZ NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'completed', 'cancelled')),
    notes_from_client TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ,
    CONSTRAINT chk_client_is_not_provider CHECK (client_id <> provider_id)
);
COMMENT ON TABLE bookings IS 'Registra todos os agendamentos de serviços entre clientes e prestadores.';
CREATE INDEX idx_bookings_client_id ON bookings(client_id);
CREATE INDEX idx_bookings_provider_id ON bookings(provider_id);

-- Tabela para gerenciar propostas e orçamentos customizados.
CREATE TABLE proposals (
    id BIGSERIAL PRIMARY KEY,
    provider_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    client_email TEXT NOT NULL CHECK (client_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    title TEXT NOT NULL,
    details TEXT NOT NULL,
    total_value DECIMAL(10, 2) NOT NULL CHECK (total_value >= 0),
    status TEXT NOT NULL DEFAULT 'sent' CHECK (status IN ('sent', 'accepted', 'rejected', 'expired')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL,
    accepted_at TIMESTAMPTZ
);
COMMENT ON TABLE proposals IS 'Armazena as propostas e orçamentos customizados enviados pelos prestadores para potenciais clientes.';
CREATE INDEX idx_proposals_provider_id ON proposals(provider_id);
DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):

CONFIANÇA NA IMPLEMENTAÇÃO: 95%

RISCOS IDENTIFICADOS: BAIXO - O principal risco é que o conteúdo gerado, apesar de seguir a estrutura, seja superficial. A riqueza de contexto fornecida visa mitigar este risco, mas a profundidade final dependerá da capacidade de expansão do modelo.

DECISÕES TÉCNICAS ASSUMIDAS: Assumiu-se uma estrutura de dados inicial para o Simpix com base no problema de negócio descrito. Esta estrutura é uma hipótese que precisará ser validada e iterada.

VALIDAÇÃO PENDENTE: O conteúdo gerado deve ser revisado por um arquiteto humano para garantir a precisão técnica, a profundidade e o alinhamento completo com a visão do projeto.

PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:

Mapear ficheiros e funções exatas afetadas (/docs/02-blueprint-arquitetural.md).

Garantir importações e tipos corretos (Não aplicável para Markdown).

Executar get_latest_lsp_diagnostics e corrigir TODOS os erros (Não aplicável para Markdown).

Declarar Nível de Confiança (0-100%): 95%.

Categorizar Riscos Descobertos: BAIXO.

Realizar teste funcional completo (Revisão humana do documento gerado).

Documentar Decisões Técnicas (As premissas de contexto para o Simpix estão documentadas neste prompt).

