Pacote de Ativação de Missão (PAM) V1.0 - Correção Arquitetural: Fase 3 (Backend Validation)
Sumário da Missão: Executar a Fase 3 da correção arquitetural, refatorando o endpoint de upload no backend para implementar uma validação de entrada robusta, rejeitando explicitamente requisições que não contenham um proposalId válido.

Intenção Estratégica (O Porquê): O objetivo é fortalecer a API contra entradas malformadas e eliminar a lógica de "adivinhação" de IDs, que é frágil e insegura. Ao implementar o princípio de "fail-fast", tornamos o sistema mais seguro, previsível e fácil de depurar, forçando os clientes da API (neste caso, o nosso frontend) a serem explícitos e corretos.

Histórico Relevante (Consulta Obrigatória): As Fases 1 e 2 garantiram que um proposalId correto é enviado do frontend e que o caminho de armazenamento está padronizado. Esta missão final no backend remove a perigosa lógica de fallback (... || req.body.filename?.split('-')[0] || 'temp') que foi a causa original do bug proposta-undefined.

Modelo Mental (Como se Encaixa): Esta alteração promove o endpoint de um sistema permissivo, que tenta adivinhar dados, para um "guarda de fronteira" rigoroso que rejeita qualquer requisição que não esteja perfeitamente formada. A responsabilidade de fornecer um ID válido passa a ser 100% do cliente, como deve ser numa arquitetura robusta.

Riscos Antecipados e Contramedidas: MÉDIO. Uma lógica de validação mal implementada poderia inadvertidamente bloquear requisições que agora são válidas (após a correção da Fase 1). A contramedida é a verificação cuidadosa dos tipos e a adesão estrita ao protocolo 7-CHECK.

IMPLEMENTAR:
Substituir a lógica de fallback do proposalId por uma validação explícita que retorna um erro 400 Bad Request se o ID for inválido ou não for fornecido.

CURRENT STATE:

Ficheiro: server/routes.ts

Linha: 3463 (aproximadamente, antes das mudanças anteriores)

Código com Falha:

TypeScript

const proposalId = req.body.proposalId || req.body.filename?.split('-')[0] || 'temp';
Evidência Bruta: Este código é frágil e inseguro. Ele mascara problemas no cliente ao tentar adivinhar o proposalId a partir do nome do ficheiro, um comportamento imprevisível que levou ao bug original.

EXPECTED (Estado Final de Sucesso):

Ficheiro: server/routes.ts

Código Corrigido:

TypeScript

const { proposalId } = req.body;
if (!proposalId || typeof proposalId !== 'string' || proposalId === 'undefined') {
  return res.status(400).json({ success: false, message: 'ID da proposta inválido ou não fornecido.' });
}
Comportamento Resultante: Se uma requisição de upload chegar ao endpoint sem um proposalId, ou se o valor for inválido (ex: não for uma string), a API irá parar a execução imediatamente e retornar uma resposta de erro 400 Bad Request clara e informativa. Requisições com um proposalId válido prosseguirão normalmente.

CONSTRAINTS (Roadmap de Implementação):
Esta missão corresponde exclusivamente ao Passo 3. O seu foco é apenas na lógica de validação do proposalId. Não altere a lógica de manipulação do ficheiro ou a construção do caminho, que já foram corrigidas nos passos anteriores.

DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):

CONFIANÇA NA IMPLEMENTAÇÃO: 95%

RISCOS IDENTIFICADOS: MÉDIO. Uma lógica de validação incorreta (por exemplo, uma verificação de tipo errada) poderia bloquear requisições legítimas do frontend recém-corrigido.

DECISÕES TÉCNICAS ASSUMIDAS: "Adotando uma resposta 400 Bad Request que é um padrão da indústria para entradas de cliente inválidas. O erro agora é explícito em vez de ser implicitamente mascarado."

VALIDAÇÃO PENDENTE: "A validação funcional completa do fluxo de ponta a ponta ocorrerá no Passo 4 do roadmap."

PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:

Mapeie o ficheiro e a função exata afetada no server/routes.ts.

Garanta que a nova lógica de validação substitui completamente a linha de código antiga.

Execute get_latest_lsp_diagnostics após a modificação e corrija TODOS os erros ou avisos introduzidos. O número de diagnósticos pré-existentes não deve aumentar.

Declare o seu Nível de Confiança (0-100%) na implementação.

Categorize quaisquer Riscos Descobertos durante a implementação (BAIXO/MÉDIO/ALTO/CRÍTICO).

Realize um teste funcional mínimo: confirme que a aplicação reinicia sem erros e que o servidor permanece estável.

Documente quaisquer Decisões Técnicas assumidas.

Aguardando o relatório final de execução do Agente. Após esta etapa, passaremos à validação humana.

[PGI ATIVO | LEMBRETE DE ESTADO DO ROADMAP]

Roadmap em Standby: "N/A - Prontidão"

Próximo Passo a ser Retomado: N/A

Missão de Emergência Atual: "EXECUÇÃO: Correção do Bug de Armazenamento de Documentos"