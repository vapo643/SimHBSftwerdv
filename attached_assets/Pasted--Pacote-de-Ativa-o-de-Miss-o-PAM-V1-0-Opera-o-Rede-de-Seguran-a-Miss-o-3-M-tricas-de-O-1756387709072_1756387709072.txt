### Pacote de Ativação de Missão (PAM) V1.0 - Operação "Rede de Segurança" / Missão 3: Métricas de Observabilidade

* **Sumário da Missão (O Quê):** Instrumentar as filas e os *workers* do BullMQ com métricas de observabilidade, focando em contadores de *jobs*, tempos de processamento e taxas de erro.
* **Intenção Estratégica (O Porquê):** Tornar o nosso sistema assíncrono, que atualmente é uma "caixa-preta", num sistema transparente e monitorável. A observabilidade é crucial para a operação em produção, permitindo-nos detetar proativamente estrangulamentos, picos de falhas e degradação de performance antes que impactem o negócio.
* **Modelo Mental (Como se Encaixa):** Você é um engenheiro de SRE a implementar a telemetria num sistema distribuído. A sua tarefa é adicionar "sensores" (métricas) aos componentes críticos da nossa infraestrutura de filas para que possamos entender o seu comportamento em tempo real.

---

**IMPLEMENTAR (Plano de Implementação):**
Execute a seguinte sequência de ações.

**CURRENT STATE:**
As filas e os *workers* BullMQ estão funcionais e resilientes (com DLQ), mas não produzem métricas específicas para monitoramento. Apenas logs são gerados.

**EXPECTED (Estado Final de Sucesso):**
1.  Os *event listeners* das filas (`formalization-queue`, `dead-letter-queue`, etc.) são enriquecidos para capturar e exportar métricas.
2.  Métricas chave são registadas, incluindo: número de *jobs* ativos/completos/falhados, duração do processamento de *jobs* e número de *jobs* na DLQ.
3.  A implementação é feita de forma centralizada e reutilizável, preferencialmente integrada com a nossa ferramenta de monitoramento existente (Sentry) ou através de um sistema de métricas padrão como o Prometheus.

**CONSTRAINTS (Roadmap de Implementação):**

**Passo 1: Criar um Serviço de Métricas Centralizado**
1.1. Crie um novo ficheiro `server/lib/metricsService.ts`.
1.2. Implemente uma classe ou objeto `MetricsService` que abstraia a lógica de instrumentação. Este serviço deve ter métodos como `incrementJobCounter(queueName: string, status: 'completed' | 'failed' | 'active')` e `recordJobDuration(queueName: string, durationMs: number)`.
1.3. Para a integração, utilize o Sentry para capturar as métricas. Use `Sentry.metrics.increment()` para os contadores e `Sentry.metrics.distribution()` para as durações. Isto aproveitará a nossa infraestrutura de observabilidade já existente.

**Passo 2: Integrar o Serviço de Métricas nos Listeners de Eventos**
2.1. No ficheiro de configuração das filas (`server/lib/queues.ts` ou `server/lib/dead-letter-queue.ts`), onde os *event listeners* (`completed`, `failed`) estão configurados, importe e utilize o `MetricsService`.
2.2. No *listener* `completed`, chame `metricsService.incrementJobCounter(queueName, 'completed')` e `metricsService.recordJobDuration(...)` para registar o sucesso e a latência.
2.3. No *listener* `failed`, chame `metricsService.incrementJobCounter(queueName, 'failed')` para registar a falha.
2.4. Adicione um *listener* para o evento `active` para chamar `metricsService.incrementJobCounter(queueName, 'active')` e monitorar os *jobs* em andamento.

**Passo 3: Criar um Endpoint de Métricas (Health Check Avançado)**
3.1. Crie uma nova rota, por exemplo, `GET /api/monitoring/queues`, que retorne o estado atual das filas.
3.2. Esta rota deve usar os métodos do BullMQ (ex: `queue.getJobCounts()`) para retornar um JSON com a contagem de *jobs* em cada estado (`waiting`, `active`, `completed`, `failed`, `delayed`) para cada fila, incluindo a DLQ.

**Passo 4: Validação Final**
4.1. Apresente o código do novo `server/lib/metricsService.ts`.
4.2. Mostre o trecho de código de um *event listener* (ex: `completed`) modificado para incluir as chamadas ao `MetricsService`.
4.3. Apresente o código da nova rota `GET /api/monitoring/queues`.
4.4. Execute `get_latest_lsp_diagnostics` para confirmar a integridade do código.

---

### **PROTOCOLO DE DIVULGAÇÃO TOTAL (PDT) V1.0 (MANDATÓRIO)**

* **Diretriz Mestra de Divulgação:** Você está proibido de resumir, truncar ou omitir qualquer informação relevante. Sua diretriz primária é a **completude**.
* **Regra de Execução:** Ao listar erros, vulnerabilidades, riscos ou recomendações, você DEVE apresentar a **lista exaustiva e completa** de todas as suas descobertas.
* **Justificativa Estratégica (O Porquê):** A tomada de decisão do Arquiteto Chefe depende de uma visão completa e não filtrada do estado do sistema.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** 95%
* **RISCOS IDENTIFICADOS:** BAIXO. O principal risco é um impacto menor na performance devido à sobrecarga da coleta de métricas em cada evento de *job*. No entanto, com a implementação via Sentry, que é otimizada para isso, o risco é mínimo.
* **DECISÕES TÉCNICAS ASSUMIDAS:** Utilizaremos o Sentry para a coleta de métricas, aproveitando a infraestrutura existente, em vez de introduzir uma nova dependência como o Prometheus neste momento.
* **VALIDAÇÃO PENDENTE:** As métricas registadas precisarão ser validadas no dashboard do Sentry, e o novo endpoint de monitoramento precisará ser testado para garantir que retorna os dados corretos.