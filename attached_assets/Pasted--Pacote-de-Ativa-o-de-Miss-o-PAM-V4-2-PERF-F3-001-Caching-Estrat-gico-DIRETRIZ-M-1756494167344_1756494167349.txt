### **Pacote de Ativação de Missão (PAM) V4.2 - PERF-F3-001 (Caching Estratégico)**

**[DIRETRIZ MESTRA DE DIVULGAÇÃO - PDT V2.0 ATIVADA]**
*Sua resposta deve ser exaustiva. Reporte a realidade técnica sem omissões. A transparência radical é mandatória.*

* **Sumário da Missão (O Quê):** Implementar uma estratégia de caching "cache-aside" utilizando o `CacheManager` (`server/lib/cache-manager.ts`) para os endpoints que servem dados de `tabelasComerciais` e `produtos`, que são dados de alta leitura e baixa volatilidade.
* **Intenção Estratégica (O Porquê):** Reduzir drasticamente a carga sobre o PostgreSQL e diminuir a latência para operações frequentes, como simulações de crédito e carregamento de formulários de propostas. Ao servir esses dados a partir de um cache em memória (Redis), a resposta será quase instantânea, contribuindo significativamente para atingir nosso SLA de `P95 < 500ms`.
* **Histórico Relevante (Consulta Obrigatória):** O alinhamento estratégico (QAE) identificou `tabelasComerciais` e `produtos` como os candidatos ideais para caching. O `cache-manager.ts`, que se conecta ao Redis Cloud, já foi implementado e validado.
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** **ALTO** - Dados obsoletos (`stale cache`). Se uma tabela comercial for atualizada no banco de dados, os usuários podem receber cálculos baseados em taxas antigas se o cache não for invalidado corretamente.
    * **Contramedida:** A implementação deve incluir uma estratégia de invalidação de cache explícita. Qualquer operação de **escrita** (Criação, Atualização, Exclusão) em `tabelasComerciais` ou `produtos` deve **obrigatoriamente** limpar a chave de cache correspondente, garantindo que a próxima leitura busque os dados atualizados do banco.

---

**IMPLEMENTAR:**
User Story PERF-003: Implementar Cache Redis para Dados de Baixa Volatilidade

**CONTEXT:**
Otimizamos nossas queries, mas ainda estamos acessando o banco de dados para buscar dados que quase nunca mudam, como a lista de produtos e as tabelas de taxas. Para atingir a performance de nível bancário, vamos implementar um cache em Redis para servir esses dados de forma quase instantânea e proteger nosso banco de dados de cargas desnecessárias.

**CURRENT STATE:**
O `cache-manager.ts` está funcional e conectado ao Redis Cloud. Os endpoints que servem `produtos` e `tabelasComerciais` atualmente buscam os dados diretamente do banco de dados a cada requisição.

**EXPECTED (Estado Final de Sucesso):**
1.  **Lógica de Leitura com Cache:**
    * Os controllers ou serviços responsáveis por listar `produtos` e `tabelasComerciais` devem ser refatorados para seguir o padrão `cache-aside`.
    * **Fluxo:** Antes de consultar o banco, tente buscar os dados do cache (`cacheManager.get`). Se houver `CACHE HIT`, retorne os dados do cache. Se for `CACHE MISS`, busque os dados do banco, salve-os no cache com um TTL apropriado (ex: 1 hora), e então retorne os dados.
2.  **Lógica de Escrita com Invalidação de Cache:**
    * Os controllers ou serviços responsáveis por **modificar** `produtos` ou `tabelasComerciais` (`create`, `update`, `delete`) devem ser refatorados.
    * **Fluxo:** Após a operação de escrita no banco de dados ser concluída com sucesso, a chave de cache correspondente **deve ser invalidada** (`cacheManager.del`).
3.  **Prova de Funcionamento:**
    * Logs devem ser adicionados para mostrar claramente os eventos `CACHE HIT`, `CACHE MISS`, e `CACHE INVALIDATED`.
    * Você deve fornecer uma sequência de logs de execução que demonstre o ciclo completo: um `CACHE MISS` na primeira chamada, um `CACHE HIT` na segunda chamada, uma chamada a um endpoint de modificação que loga `CACHE INVALIDATED`, e um `CACHE MISS` na chamada subsequente à listagem.

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Localizar Endpoints Alvo:** Identifique os arquivos de controller/serviço que contêm a lógica para `GET /api/produtos`, `GET /api/tabelas-comerciais`, e os endpoints `POST`, `PUT`, `DELETE` correspondentes.
2.  **Implementar `cache-aside` na Leitura:** Refatore os métodos de listagem (`GET`). Envolva a lógica de busca do banco de dados com a verificação de cache, conforme descrito acima. Use chaves de cache claras, como `cache:products:all` e `cache:commercial-tables:all`.
3.  **Implementar Invalidação na Escrita:** Refatore os métodos de modificação (`POST`, `PUT`, `DELETE`). Após a conclusão bem-sucedida da operação de banco de dados, adicione a chamada para `cacheManager.del()` com a chave de cache apropriada.
4.  **Adicionar Logging:** Insira `console.log` informativos em todos os pontos de interação com o cache para que possamos validar o fluxo.
5.  **Executar Cenário de Validação:**
    * Reinicie o servidor.
    * Faça uma requisição `GET` para `/api/produtos`. Capture o log mostrando `CACHE MISS`.
    * Faça a mesma requisição `GET` novamente. Capture o log mostrando `CACHE HIT`.
    * Faça uma requisição `POST` para criar um novo produto. Capture o log mostrando `CACHE INVALIDATED`.
    * Faça a requisição `GET` final. Capture o log mostrando um novo `CACHE MISS`.
6.  **Verificação Final:** Execute o protocolo `7-CHECK FULL` e preencha a declaração de incerteza.

---