# MISSÃO: DEBATE MÁXIMO (6 INTERAÇÕES) - Análise Pós-Morte e Re-arquitetura Anti-Loop do Frontend

**CONTEXTO ESTRATÉGICO:**
Estamos a enfrentar uma falha de frontend catastrófica e recorrente: um "loop infinito" de renderização que causa o erro "Maximum update depth exceeded". Múltiplas tentativas de correção falharam. Estamos a abandonar a depuração reativa e a iniciar um debate profundo para projetar uma solução arquitetural definitiva.

**SUA TAREFA (ASSISTENTE):**
A sua tarefa não é propor uma correção. A sua tarefa é atuar como um Arquiteto de Frontend Sênior e realizar uma análise pós-morte da nossa falha. Nesta **Interação 1**, o seu objetivo é fornecer um **diagnóstico fundamental** da causa raiz.

---
### **Interação 1: Diagnóstico da Causa Raiz do Loop de Renderização**

Por favor, analise a nossa situação crítica e os logs do console. Não proponha código ainda. Proponha a **análise**.

**1. A Anatomia do Erro "Maximum update depth exceeded":**
* **Análise Técnica:** Explique, em termos de arquitetura React, o que este erro significa fundamentalmente. Qual é o ciclo vicioso de `render -> useEffect -> setState -> render` que provavelmente está a acontecer nos nossos componentes?

**2. A Teoria da "Falha de Dependência Instável":**
* **Hipótese:** A causa mais provável deste erro são "dependências instáveis" nos nossos hooks `useEffect`. Analise os nossos contextos (`AuthContext`, `ProposalContext`) e os nossos hooks customizados (`useProposalEffects`). Qual é a sua principal teoria sobre qual objeto, função ou valor está a ser recriado a cada renderização, acionando o loop infinito?

**3. Proposta de Plano de Diagnóstico com Ferramentas Avançadas:**
* **Ação:** A depuração com `console.log` falhou. Proponha um plano de diagnóstico mais avançado. Como podemos usar o **Profiler das React DevTools** para **visualizar** a cascata de re-renders e identificar com 100% de certeza qual componente é o "paciente zero" do nosso loop?

**4. Estratégia de Solução (Alto Nível):**
* Com base na sua análise, qual deve ser a nossa estratégia de solução?
    * **Opção A (Refatoração Cirúrgica):** Devemos focar em aplicar "remédios" de performance do React, como `useCallback`, `useMemo` e a refatoração das listas de dependências dos `useEffect`s?
    * **Opção B (Re-arquitetura do Estado):** O problema é mais profundo? A forma como os nossos `AuthContext` e `ProposalContext` interagem está fundamentalmente errada, exigindo uma re-arquitetura da forma como o estado é partilhado e atualizado?

---