### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Criar um teste de integração automatizado para a regra de negócio de "Negação Automática por Comprometimento de Renda".
* **Intenção Estratégica (O Porquê):** Criar uma rede de segurança permanente para uma das regras de negócio mais críticas e sensíveis do sistema. Este teste garantirá que futuras alterações no código não quebrem a lógica de pré-aprovação, prevenindo a aprovação acidental de propostas financeiramente inviáveis.
* **Histórico Relevante (Consulta Obrigatória):** A FASE 2 implementou o `preApprovalService` com esta lógica. A missão anterior (4.1.3) desbloqueou a nossa infraestrutura de testes de integração, que agora possui helpers robustos (`cleanTestDatabase`, `setupTestEnvironment`) que devem ser utilizados.
* **Modelo Mental (Como se Encaixa):** Esta é uma missão de Quality Assurance. O Agente irá escrever um novo cenário de teste que simula um caso de uso específico do mundo real: um cliente com alta dívida a solicitar um empréstimo. O teste validará que o sistema responde corretamente conforme a regra de negócio.
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** O teste pode ser instável ("flaky") se os dados de setup não forem precisos.
    * **Contramedida:** O prompt exige o uso dos helpers de teste já validados e a criação de dados de teste específicos e determinísticos para o cenário.

---

**IMPLEMENTAR:**
Teste de Integração para a Regra de Negação Automática

**CURRENT STATE:**
A lógica de negócio para a negação automática de propostas com base no comprometimento de renda existe no `preApprovalService` e está integrada ao endpoint de criação de propostas, mas não possui cobertura de testes automatizados, representando um risco de regressão.

**EXPECTED (Estado Final de Sucesso):**
1.  Um novo arquivo de teste, `tests/integration/pre-approval.test.ts`, é criado.
2.  A suíte de testes utiliza `vitest` para a estrutura e `supertest` para fazer chamadas à API.
3.  O hook `beforeEach` utiliza os helpers `cleanTestDatabase` e `setupTestEnvironment` para criar um ambiente de teste limpo e com os dados pré-requisito (usuário, loja, etc.).
4.  Um novo teste (`it(...)`) é criado para o cenário de "Negação Automática". Este teste deve:
    a. Simular uma chamada de API para `POST /api/propostas`.
    b. O corpo da requisição (`payload`) deve conter dados de um cliente onde a soma de `clienteDividasExistentes` e a `valor_parcela` da nova proposta exceda 25% da `clienteRenda` informada.
    c. As asserções (`expect`) devem verificar se, após a chamada, o registro da proposta criado no banco de dados tem o seu campo `status` igual a `'rejeitado'`.

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Reutilize a Infraestrutura de Teste:** O teste DEVE usar os helpers `cleanTestDatabase` e `setupTestEnvironment` de `tests/lib/db-helper.ts`.
2.  **Ferramentas:** O teste deve ser escrito usando `vitest` e a biblioteca `supertest` para fazer a chamada HTTP à API de criação de propostas.
3.  **Cenário de Teste Específico:** Crie dados de teste que forcem a falha na regra de negócio. Exemplo: `clienteRenda: 10000`, `clienteDividasExistentes: 2000`, e um `valor_solicitado` que resulte em uma parcela de `600`. (Comprometimento = (2000+600)/10000 = 26%).
4.  **Validação no Banco de Dados:** A asserção final DEVE fazer uma consulta direta ao banco de dados de teste (usando o Drizzle) para buscar a proposta recém-criada e verificar se o seu campo `status` está correto.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATório):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Ex: "Assumi que o `supertest` está corretamente configurado para interagir com o app Express no ambiente de teste."]
* **VALIDAÇÃO PENDENTE:** [Nenhuma. O sucesso é definido pela passagem de 100% dos novos testes.]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear ficheiros e funções exatas afetadas (criação do novo arquivo de teste).
2.  Garantir importações e tipos corretos para os helpers de teste e `supertest`.
3.  Executar `get_latest_lsp_diagnostics` para garantir 0 erros novos.
4.  **Declarar Nível de Confiança (0 a 100%)**.
5.  **Categorizar Riscos Descobertos**.
6.  **Realizar teste funcional completo** (executar a nova suíte de testes e garantir que todos passem).
7.  **Documentar Decisões Técnicas** como a estrutura dos dados de teste criados.