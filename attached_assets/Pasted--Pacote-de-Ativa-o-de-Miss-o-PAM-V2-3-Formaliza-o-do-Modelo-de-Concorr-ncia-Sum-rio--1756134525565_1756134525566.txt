### Pacote de Ativação de Missão (PAM) V2.3 (Formalização do Modelo de Concorrência)

* **Sumário da Missão (O Quê):** Gerar um Architecture Decision Record (ADR) que defina o nosso **Modelo de Concorrência** para o backend, detalhando como iremos gerir *threads*, *pools* de conexão e operações assíncronas para garantir alta performance e estabilidade sob carga.
* **Intenção Estratégica (O Porquê):** Prevenir gargalos de performance e garantir que a nossa aplicação utilize os recursos de CPU e memória de forma eficiente. Um modelo de concorrência bem definido é crucial para a escalabilidade do nosso sistema e para cumprir os SLOs de latência que estabelecemos.
* **Histórico Relevante (Consulta Obrigatória):** A auditoria de conformidade identificou a ausência de um modelo de concorrência formal como uma lacuna. A nossa stack Node.js é single-threaded por natureza, o que torna uma estratégia explícita para lidar com operações de I/O e tarefas de CPU intensivas ainda mais crítica.
* **Modelo Mental (Como se Encaixa):** Aja como um Engenheiro de Performance Sênior. A sua tarefa é projetar o "motor" da nossa aplicação, definindo como ele irá lidar com múltiplas tarefas simultaneamente sem sobreaquecer ou perder performance.

---

**IMPLEMENTAR:**
ADR: Estratégia de Modelo de Concorrência

**CURRENT STATE:**
A aplicação lida com concorrência de forma implícita, através do *event loop* do Node.js e das capacidades do BullMQ, mas não temos uma estratégia documentada ou padrões para a otimização de *pools* ou para o gerenciamento de tarefas de CPU intensivas.

**EXPECTED (Estado Final de Sucesso):**
Um novo arquivo Markdown, `architecture/02-technical/concurrency-model-strategy.md`, é criado. O arquivo deve conter um ADR completo, incluindo as seguintes seções:

1.  **Decisão:** Uma declaração clara, por exemplo: "Adotaremos um modelo de concorrência híbrido, utilizando o **Event Loop do Node.js** para operações de I/O, **Worker Pools (BullMQ)** para tarefas de background e o **módulo `cluster` do Node.js** para paralelismo de CPU."
2.  **Justificativa:** A justificação para a escolha (aproveitar os pontos fortes do Node.js, isolar tarefas pesadas, escalar verticalmente na mesma máquina).
3.  **Definição do Modelo de Concorrência:**
    * **Event Loop:** Diretrizes para código "non-blocking".
    * **Worker Pools (BullMQ):** Como iremos configurar as nossas filas e *workers* para tarefas assíncronas (geração de PDF, webhooks).
    * **Paralelismo de CPU (`cluster`):** A nossa estratégia para usar o módulo `cluster` para criar um *fork* do processo da aplicação para cada núcleo de CPU disponível, maximizando a utilização de recursos.
4.  **Estratégia de Gerenciamento de Recursos:**
    * **Connection Pools (PostgreSQL):** Como iremos configurar e otimizar o nosso *pool* de conexões com o banco de dados para evitar exaustão.
    * **Backpressure:** Como iremos lidar com a contrapressão em cenários de alta carga.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO. Ex: Risco de complexidade na gestão de estado entre os processos do `cluster`.]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Ex: "Assumi que o módulo `cluster` do Node.js é a forma mais simples e eficaz de alcançar o paralelismo de CPU para a nossa aplicação, em vez de introduzir uma nova linguagem/tecnologia."]
* **VALIDAÇÃO PENDENTE:** [O ADR gerado deve ser revisado e ratificado pelo Arquiteto Chefe.]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear o ficheiro exato a ser criado.
2.  Garantir que todas as seções obrigatórias do ADR estão completas.
3.  Executar `get_latest_lsp_diagnostics` para garantir que o ambiente está estável.
4.  **Declarar Nível de Confiança (0 a 100%)**.
5.  **Categorizar Riscos Descobertos**.
6.  **Realizar teste funcional completo** (revisão do documento Markdown gerado).
7.  **Documentar Decisões Técnicas**.