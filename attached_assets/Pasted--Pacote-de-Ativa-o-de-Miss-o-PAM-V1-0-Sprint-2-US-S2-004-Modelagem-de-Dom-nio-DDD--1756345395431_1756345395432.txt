### Pacote de Ativação de Missão (PAM) V1.0 - Sprint 2 / US S2-004: Modelagem de Domínio (DDD)

* **Sumário da Missão (O Quê):** Implementar o Agregado `Proposal` como a entidade central do domínio de crédito, encapsulando suas invariantes de negócio, a máquina de estados (FSM) e a emissão de Domain Events.
* **Intenção Estratégica (O Porquê):** Traduzir as regras de negócio complexas e não negociáveis, definidas no blueprint, em código coeso e explícito. Isso protege a integridade do sistema, garante a conformidade com os fluxos operacionais e cria uma base de código que fala a linguagem do negócio (Ubiquitous Language).
* **Modelo Mental (Como se Encaixa):** Você é um engenheiro de software especialista em Domain-Driven Design (DDD). Sua tarefa não é apenas escrever código, mas modelar um conceito de negócio. O Agregado `Proposal` será o guardião de todas as regras relacionadas a uma proposta de crédito.

---

**IMPLEMENTAR (Plano de Implementação):**
Execute a seguinte sequência de ações para modelar o Agregado `Proposal`.

**CURRENT STATE:**
A camada de persistência (Schema, Repositories, UoW) está implementada. Pode existir uma classe `Proposal` básica, mas sem a lógica de domínio encapsulada.

**EXPECTED (Estado Final de Sucesso):**
1. A classe `Proposal` em `server/modules/proposal/domain/Proposal.ts` é um Agregado DDD completo.
2. As invariantes de negócio (regras de validação de estado) estão implementadas como métodos dentro da classe `Proposal`.
3. A lógica de transição de status segue rigorosamente a FSM definida, incluindo o novo estado `PENDENCIADO`.
4. Os Domain Events são emitidos pelo Agregado após operações de negócio bem-sucedidas.

**CONSTRAINTS (Roadmap de Implementação):**

**Passo 1: Enriquecer o Agregado `Proposal`**
1.1. Abra o ficheiro `server/modules/proposal/domain/Proposal.ts`.
1.2. Garanta que a classe `Proposal` tenha um construtor privado e um método estático de fábrica (ex: `create()`) para controlar a criação de instâncias válidas.
1.3. Implemente métodos públicos para modificar o estado do agregado, que encapsularão a lógica de negócio. Por exemplo:
    * `submitForAnalysis()`
    * `approve(analystId: string)`
    * `reject(analystId: string, reason: string)`
    * `pend(analystId: string, reason: string)`
    * `updateAfterPending(newData: Partial<ProposalData>)`

**Passo 2: Implementar Invariantes e Máquina de Estados (FSM)**
2.1. Dentro de cada método de modificação (ex: `approve`), implemente a lógica de validação das **invariantes de negócio**. O método deve lançar um erro (`DomainException`) se uma regra for violada.
    * **Exemplo em `approve()`:** `if (this.status !== 'EM_ANALISE') { throw new DomainException('Só é possível aprovar propostas em análise.'); }`
2.2. Garanta que as transições de status sigam o fluxo definido: `RASCUNHO` → `EM_ANALISE` → `APROVADO`/`REJEITADO`/`PENDENCIADO`.
2.3. Assegure que os métodos `reject()` e `pend()` exijam um motivo (`reason`) como argumento obrigatório.

**Passo 3: Implementar a Emissão de Domain Events**
3.1. Crie uma classe base para eventos ou um tipo simples em `server/modules/shared/domain/DomainEvent.ts`.
3.2. Após uma operação de negócio bem-sucedida dentro de um método do Agregado, adicione a lógica para registrar um novo evento de domínio (ex: `this.addDomainEvent(new ProposalApprovedEvent(this.id))`).
3.3. Os eventos a serem implementados são: `ProposalCreatedEvent`, `ProposalSubmittedEvent`, `ProposalApprovedEvent`, `ProposalRejectedEvent`, `ProposalPendingEvent`, `ProposalUpdatedAfterPendingEvent`, e os eventos do ciclo de formalização.

**Passo 4: Validação Final**
4.1. Apresente o conteúdo completo do ficheiro `server/modules/proposal/domain/Proposal.ts` após a refatoração.
4.2. Mostre um exemplo de método (ex: `approve` ou `reject`) que demonstre claramente: a) a verificação de invariante, b) a transição de estado, e c) a emissão de um Domain Event.
4.3. Execute `get_latest_lsp_diagnostics` para garantir a integridade do código.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** 95%
* **RISCOS IDENTIFICADOS:** BAIXO. A principal complexidade é garantir que todas as transições de estado e invariantes definidas no blueprint sejam corretamente mapeadas para a lógica dentro da classe do Agregado.
* **DECISÕES TÉCNICAS ASSUMIDAS:** Será criada uma lista privada de eventos de domínio dentro da classe `Proposal` e um método público para limpá-los após o despacho, uma prática comum em implementações de DDD.
* **VALIDAÇÃO PENDENTE:** Os Domain Events emitidos serão consumidos por *handlers* em sprints futuros. A validação neste passo foca-se na emissão correta dos eventos pelo Agregado.