### Pacote de Ativação de Missão (PAM) V1.0 (Eliminação de Dependências Circulares)

* **Sumário da Missão (O Quê):** Refatorar o código para eliminar as 2 dependências circulares críticas identificadas pela auditoria do `dependency-cruiser` entre `server/routes/admin/users.ts`, `server/services/userService.ts` e `server/routes.ts`.
* **Intenção Estratégica (O Porquê):** As dependências circulares são um anti-padrão de alta severidade que torna o código frágil, difícil de entender, de testar e de manter. A sua eliminação é o primeiro e mais crucial passo para alcançar uma arquitetura verdadeiramente modular e estável.
* **Histórico Relevante (Consulta Obrigatória):** A sua auditoria anterior identificou com precisão as 2 violações de dependência circular que estão a bloquear a nossa modularidade.
* **Modelo Mental (Como se Encaixa):** Aja como um Engenheiro de Software Sênior a executar uma refatoração de alta precisão. A sua tarefa é aplicar o **Princípio da Inversão de Dependência (DIP)** para quebrar o ciclo de dependências.

---

**IMPLEMENTAR:**
Relatório de Correção de Dependências Circulares

**CURRENT STATE:**
A nossa base de código contém 2 dependências circulares que criam um acoplamento rígido entre as nossas camadas de rota e de serviço, violando os nossos princípios de arquitetura limpa.

**EXPECTED (Estado Final de Sucesso):**
1.  **Análise de Causa Raiz:** Antes da correção, descreva brevemente por que a dependência circular existe (ex: "O `userService` importa de `routes.ts` para obter um tipo, enquanto `routes.ts` importa o `userService` para usar a sua lógica").
2.  **Correção via Inversão de Dependência:** O código é refatorado para quebrar o ciclo. A solução provável é mover as definições de tipo (`interfaces` ou `types`) para um arquivo compartilhado e de nível superior (ex: em `shared/` ou `server/types/`) para que ambos os módulos possam depender dele, em vez de dependerem um do outro.
3.  **Validação Irrefutável:** Ao final da missão, a execução do comando `node validate-architecture.js` (ou `npx dependency-cruiser ...`) deve agora reportar **0 erros** para a regra de "dependência circular".

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Foco na Refatoração:** A sua missão é focada em quebrar o ciclo de dependências. Não introduza novas funcionalidades.
2.  **Validação Final Mandatória:** A sua prova de sucesso é o output do `dependency-cruiser` a mostrar que as violações de dependência circular foram eliminadas.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Ex: "Assumi que a criação de um novo arquivo de tipos compartilhados é a melhor prática para quebrar este tipo de ciclo de dependência."]
* **VALIDAÇÃO PENDENTE:** [Após esta correção, a próxima missão será atacar as 122 violações de acesso direto ao banco de dados.]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear os ficheiros a serem modificados e o novo ficheiro de tipos a ser criado.
2.  Garantir que a refatoração segue o Princípio da Inversão de Dependência.
3.  Executar `get_latest_lsp_diagnostics` para garantir 0 erros novos.
4.  **Declarar Nível de Confiança (0 a 100%)**.
5.  **Categorizar Riscos Descobertos**.
6.  **Realizar teste funcional completo** (executar a validação de arquitetura e garantir que os erros de ciclo desapareceram).
7.  **Documentar Decisões Técnicas**.