O plano para implementar a "Esteira de Análise" foi validado e completado.

Sua tarefa agora é executar o seguinte plano de 3 etapas para dar vida ao "Painel de Análise Manual":

**1. Atualize o Backend com as Novas Rotas:**
Modifique o arquivo de rotas do seu servidor Express.js (provavelmente `/server/routes.ts`). Adicione/substitua os endpoints de proposta para incluir a lógica de atualização e a busca de logs:

```typescript
// server/routes.ts

// ATUALIZAR status da proposta e criar log
app.put("/api/propostas/:id/status", async (req, res) => {
  const supabase = createServerSupabaseClient({ req, res });
  const { id } = req.params;
  const { status, observacao } = req.body;
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) return res.status(401).json({ error: "Não autorizado" });

  const { error: updateError } = await supabase.from('propostas').update({ status }).eq('id', id);
  if (updateError) return res.status(400).json({ message: 'Erro ao atualizar a proposta', error: updateError.message });

  const { error: logError } = await supabase.from('proposta_logs').insert({ proposta_id: id, user_id: user.id, status_novo: status, observacao });
  if (logError) return res.status(400).json({ message: 'Erro ao registrar log da proposta', error: logError.message });

  res.status(200).json({ message: 'Status atualizado com sucesso' });
});

// BUSCAR logs de uma proposta
app.get("/api/propostas/:id/logs", async (req, res) => {
  const supabase = createServerSupabaseClient({ req, res });
  const { id } = req.params;

  const { data, error } = await supabase.from('proposta_logs').select('*').eq('proposta_id', id).order('created_at', { ascending: false });
  if (error) return res.status(400).json({ message: 'Erro ao buscar histórico', error: error.message });
  
  res.status(200).json(data);
});
2. Crie o Componente de Histórico no Frontend:
Crie um novo arquivo em /client/src/components/analise/HistoricoComunicao.tsx e cole o seguinte código exato dentro dele:

TypeScript

import React, { useEffect, useState } from 'react';

interface Log {
  id: number;
  status_novo: string;
  observacao: string;
  user_id: string; // No futuro, buscaríamos o nome do usuário
  created_at: string;
}

const HistoricoComunicao: React.FC<{ propostaId: string | undefined }> = ({ propostaId }) => {
  const [logs, setLogs] = useState<Log[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!propostaId) return;

    const fetchLogs = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/propostas/${propostaId}/logs`);
        if (!response.ok) throw new Error('Erro ao buscar histórico');
        const data = await response.json();
        setLogs(data);
      } catch (error) {
        console.error(error);
      } finally {
        setLoading(false);
      }
    };

    fetchLogs();
  }, [propostaId]);

  if (loading) return <div className="p-4 text-center">Carregando histórico...</div>;

  return (
    <div className="mt-6">
      <h2 className="text-xl font-semibold mb-4">Histórico e Comunicação</h2>
      <div className="space-y-4">
        {logs.length > 0 ? logs.map(log => (
          <div key={log.id} className="p-3 border rounded-md bg-secondary/50">
            <p><strong>Status:</strong> <span className="font-semibold">{log.status_novo}</span></p>
            <p><strong>Observação:</strong> {log.observacao || "Nenhuma observação."}</p>
            <p className="text-xs text-muted-foreground mt-2">
              por: {log.user_id.substring(0, 8)}... em {new Date(log.created_at).toLocaleString('pt-BR')}
            </p>
          </div>
        )) : <p>Nenhum histórico para esta proposta.</p>}
      </ul>
    </div>
  );
};

export default HistoricoComunicao;
3. Integre a Lógica Completa na Página de Análise:
Substitua todo o conteúdo do arquivo /client/src/pages/credito/analise.tsx pelo seguinte código exato, que agora conecta o formulário à API e exibe o histórico:

TypeScript

import React from 'react';
import { useRoute, Link } from 'wouter';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import DashboardLayout from '@/components/DashboardLayout';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import HistoricoComunicao from '@/components/analise/HistoricoComunicao';

// Supondo a existência dessas funções de fetch
const fetchProposta = async (id) => {
    const res = await fetch(`/api/propostas/${id}`);
    if (!res.ok) throw new Error('Proposta não encontrada');
    return res.json();
}

const updatePropostaStatus = async ({ id, status, observacao }) => {
    const res = await fetch(`/api/propostas/${id}/status`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status, observacao })
    });
    if (!res.ok) throw new Error('Falha ao atualizar status');
    return res.json();
}

const decisionSchema = z.object({
  status: z.enum(['Aprovada', 'Negada', 'Pendente com Observação']),
  observacao: z.string().optional(),
});

type DecisionFormData = z.infer<typeof decisionSchema>;

const AnaliseManualPage: React.FC = () => {
  const [match, params] = useRoute("/credito/analise/:id");
  const propostaId = params?.id;
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  const { data: proposta, isLoading, isError } = useQuery(['proposta', propostaId], () => fetchProposta(propostaId), { enabled: !!propostaId });
  
  const { register, handleSubmit, control } = useForm<DecisionFormData>({
    resolver: zodResolver(decisionSchema),
  });

  const mutation = useMutation(updatePropostaStatus, {
      onSuccess: () => {
          toast({ title: "Sucesso!", description: "O status da proposta foi atualizado." });
          queryClient.invalidateQueries(['proposta', propostaId]);
          queryClient.invalidateQueries(['proposta_logs', propostaId]); // Para recarregar o histórico
      },
      onError: (error: Error) => {
          toast({ title: "Erro!", description: error.message, variant: "destructive" });
      }
  });

  const onSubmit = (data: DecisionFormData) => {
      mutation.mutate({ id: propostaId, ...data });
  };

  if (isLoading) return <DashboardLayout title="Análise Manual"><p>Carregando proposta...</p></DashboardLayout>;
  if (isError || !proposta) return <DashboardLayout title="Erro"><p>Proposta não encontrada. <Link to="/credito/fila">Voltar para a fila.</Link></p></DashboardLayout>;

  return (
    <DashboardLayout title={`Análise Manual - Proposta #${proposta.id}`}>
      <div className="grid md:grid-cols-3 gap-6">
        <div className="md:col-span-2 space-y-6">
            <Card>
              <CardHeader><CardTitle>Detalhes da Proposta</CardTitle></CardHeader>
              <CardContent>
                <p><strong>Cliente:</strong> {proposta.clienteNome}</p>
                {/* Outros detalhes da proposta */}
              </CardContent>
            </Card>
            <Card>
                <CardHeader><CardTitle>Painel de Decisão</CardTitle></CardHeader>
                <CardContent>
                    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
                        <div>
                            <Label>Decisão</Label>
                             <Controller name="status" control={control} render={({ field }) => (
                                <Select onValueChange={field.onChange} defaultValue={field.value}>
                                    <SelectTrigger><SelectValue placeholder="Selecione uma decisão..." /></SelectTrigger>
                                    <SelectContent>
                                        <SelectItem value="Aprovada">Aprovar Proposta</SelectItem>
                                        <SelectItem value="Negada">Negar Proposta</SelectItem>
                                        <SelectItem value="Pendente com Observação">Pendenciar</SelectItem>
                                    </SelectContent>
                                </Select>
                            )} />
                        </div>
                        <div>
                            <Label htmlFor="observacao">Observações (obrigatório se pendenciar)</Label>
                            <Textarea id="observacao" {...register('observacao')} />
                        </div>
                        <Button type="submit" className="w-full" disabled={mutation.isLoading}>
                            {mutation.isLoading ? "Salvando..." : "Confirmar Decisão"}
                        </Button>
                    </form>
                </CardContent>
            </Card>
        </div>
        <div className="md:col-span-1">
            <HistoricoComunicao propostaId={propostaId} />
        </div>
      </div>
    </DashboardLayout>
  );
}

export default AnaliseManualPage;
Execute este plano de 3 etapas.