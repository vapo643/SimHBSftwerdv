Pacote de Ativação de Missão (PAM) V1.0 - P1.3: Inversão de Dependência
Sumário da Missão (O Quê): Refatorar os Controllers e Use Cases para eliminar o acoplamento forte com implementações concretas de repositórios. A missão é fazer com que estas classes dependam de abstrações (a interface IProposalRepository) e não de detalhes de implementação, aderindo ao Princípio da Inversão de Dependência (DIP) do SOLID.

Intenção Estratégica (O Porquê): Esta é a Ação P1.3 da "Operação Aço Líquido". As auditorias revelaram violações graves do DIP, onde classes de alto nível (Use Cases) instanciam diretamente classes de baixo nível (new ProposalRepository()). Isto cria um sistema rígido, frágil e impossível de testar de forma isolada. Ao inverter a dependência, tornamos o sistema flexível, testável e verdadeiramente modular, curando uma das principais causas da fratura arquitetural.

Histórico Relevante (Consulta Obrigatória): A Ação P1.2 nos forneceu a abstração necessária: a interface IProposalRepository. Agora, vamos utilizá-la para desacoplar o código. O DIAGNOSTICO_SISTEMICO_FINAL.md destacou esta violação como um ponto crítico a ser corrigido.

Modelo Mental (Como se Encaixa): Estamos a "religar" a eletricidade da nossa aplicação. Em vez de cada aparelho (Use Case) ir diretamente à "central elétrica" (a classe ProposalRepository), vamos forçá-los a ligarem-se a uma "tomada" padronizada (a interface IProposalRepository). Isto permite-nos, no futuro, trocar a central elétrica por uma nova (ou por uma de teste) sem ter de modificar nenhum dos aparelhos.

Riscos Antecipados e Contramedidas:

Risco (MÉDIO): A alteração dos construtores dos Use Cases irá quebrar os pontos onde eles são instanciados (provavelmente nos Controllers).

Contramedida: O plano inclui a criação de um mecanismo simples de Injeção de Dependência (IoC), como um arquivo de Factory, para gerir a criação e injeção centralizada das dependências, resolvendo as quebras de compilação de forma organizada.

IMPLEMENTAR: Refatoração para Inversão de Dependência (DIP)

CONTEXT: Classes de alto nível, como Use Cases, estão diretamente acopladas a implementações concretas de repositórios (new ProposalRepository()), violando o Princípio da Inversão de Dependência. Precisamos refatorar este código para que ele dependa da abstração (IProposalRepository) que criámos na missão anterior.

CURRENT STATE: Código fortemente acoplado, difícil de testar e manter. Exemplo hipotético:

TypeScript

// Exemplo do padrão atual a ser corrigido
import { ProposalRepository } from '../infrastructure/ProposalRepository';

class CreateProposalUseCase {
  private proposalRepository: ProposalRepository;

  constructor() {
    this.proposalRepository = new ProposalRepository(); // ❌ Acoplamento forte!
  }

  async execute(data: any) {
    // ...
  }
}
EXPECTED (Estado Final de Sucesso):

Todos os Use Cases e Services relevantes devem depender da interface IProposalRepository, recebendo a dependência através dos seus construtores (Injeção de Dependência).

Um mecanismo centralizado (ex: um Factory ou um arquivo de inicialização) será responsável por criar a instância do ProposalRepository e injetá-la onde for necessário.

O sistema deve compilar sem erros e a lógica de negócio deve permanecer funcional.

CONSTRAINTS (Roadmap de Implementação):

Fase 1: Auditoria de Acoplamento

Execute uma busca global no código por instâncias diretas do repositório concreto: new ProposalRepository(). Foque nos arquivos dentro de server/modules/.

Fase 2: Refatoração dos Construtores

Para cada Use Case ou Service identificado que instancia diretamente o ProposalRepository:

Altere o construtor para receber a dependência.

Mude o tipo da propriedade interna para a interface IProposalRepository.

Exemplo de Refatoração:

TypeScript

// server/modules/proposal/application/CreateProposalUseCase.ts
import { IProposalRepository } from '../domain/IProposalRepository'; // ✅ Depende da abstração

class CreateProposalUseCase {
  private proposalRepository: IProposalRepository; // ✅ Usa a interface

  constructor(proposalRepository: IProposalRepository) { // ✅ Recebe via injeção
    this.proposalRepository = proposalRepository;
  }

  async execute(data: any) {
    // ...
  }
}
Fase 3: Centralização da Injeção de Dependência

As alterações da Fase 2 irão quebrar a instanciação dos Use Cases (provavelmente nos Controllers).

Crie um novo arquivo, por exemplo, server/modules/dependencies.ts.

Neste arquivo, crie e exporte uma única instância do repositório e dos Use Cases que dependem dele.

Exemplo de Factory Simples:

TypeScript

// server/modules/dependencies.ts
import { ProposalRepository } from './proposal/infrastructure/ProposalRepository';
import { CreateProposalUseCase } from './proposal/application/CreateProposalUseCase';
// ... importe outros Use Cases

export const proposalRepository = new ProposalRepository();

export const createProposalUseCase = new CreateProposalUseCase(proposalRepository);
// ... instancie outros Use Cases aqui, injetando o mesmo repositório
Refatore os Controllers (ex: proposalController.ts) para importar as instâncias dos Use Cases a partir de dependencies.ts, em vez de criá-las com new.

Validação:

Execute get_latest_lsp_diagnostics de forma iterativa até que zero erros sejam reportados, garantindo que todo o sistema está corretamente "religado".

DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):

CONFIANÇA NA IMPLEMENTAÇÃO: [Preencher com a porcentagem de 0 a 100%]

RISCOS IDENTIFICADOS: [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO]

DECISÕES TÉCNICAS ASSUMIDAS: [Ex: "Assumi que um simples Factory em dependencies.ts é suficiente como mecanismo de IoC para o estado atual do projeto."]

VALIDAÇÃO PENDENTE: [Ex: "Testes de integração para validar que os Use Cases continuam a funcionar corretamente com as dependências injetadas."]