**### Pacote de Ativação de Missão (PAM) V1.0**

* **Sumário da Missão (O Quê):** Implementar a lógica de escuta (subscription) do Supabase Realtime na "Tela de Cobranças" para que a tabela de propostas seja atualizada automaticamente quando o status de um boleto mudar.
* **Intenção Estratégica (O Porquê):** Para que o dashboard de cobranças seja uma ferramenta verdadeiramente operacional, a equipe precisa ver o status dos pagamentos em tempo real. Esta funcionalidade elimina a necessidade de atualizações manuais, aumenta a eficiência e garante que a equipe esteja sempre a trabalhar com a informação mais recente.
* **Histórico Relevante (Consulta Obrigatória):** Já implementamos com sucesso um listener do Supabase Realtime na "Tela de Formalização". Sua missão é replicar e adaptar essa mesma arquitetura para a "Tela de Cobranças".
* **Modelo Mental (Como se Encaixa):** O backend (webhook do Inter) já está a atualizar a tabela `inter_collections` ou `propostas`. O Supabase Realtime já está a transmitir estes eventos de `UPDATE`. A peça final que falta é o nosso componente de frontend (`CobrancasPage.tsx`) se inscrever para "ouvir" estas transmissões e, ao receber uma, re-validar os dados na tela.
* **Riscos Antecipados:** **Risco:** Uma implementação ingênua pode fazer a tela piscar ou recarregar de forma ineficiente. **Contramedida:** A atualização deve ser feita através do `queryClient.invalidateQueries` do TanStack Query, que já utilizamos, para garantir um recarregamento de dados suave e eficiente.

---

**IMPLEMENTAR:**
A lógica de subscrição em tempo real na "Tela de Cobranças" para atualizar a lista de propostas automaticamente.

**CURRENT STATE:**
O backend atualiza o status dos boletos no banco de dados, mas o frontend não é notificado destas mudanças. O operador precisa recarregar a página manualmente para ver as atualizações.

**EXPECTED (Estado Final de Sucesso):**
Um fluxo 100% reativo. Quando o Banco Inter envia um webhook de "boleto pago":
1.  O backend atualiza o banco de dados.
2.  O Supabase transmite o evento de `UPDATE`.
3.  O componente da "Tela de Cobranças" recebe o evento.
4.  A tabela na UI é atualizada **automaticamente em poucos segundos**, mostrando o novo status "PAGO" para a proposta correspondente, sem a necessidade de qualquer interação do usuário.

**CONSTRAINTS (Roadmap de Implementação):**

**1. Implementação da Escuta no Frontend (`CobrancasPage.tsx`):**
    - **Ação:** No ficheiro `client/src/pages/financeiro/CobrancasPage.tsx`, adicione um `useEffect` para configurar a subscrição do Supabase Realtime.
    - **Lógica (Código de Exemplo):**
      ```typescript
      useEffect(() => {
        const channel = supabase
          .channel('table-db-changes')
          .on(
            'postgres_changes',
            {
              event: 'UPDATE',
              schema: 'public',
              table: 'propostas', // Ou 'inter_collections', se for mais direto
            },
            (payload) => {
              console.log('✅ [REALTIME] Evento de UPDATE recebido:', payload);
              // Invalida a query principal para forçar um refetch
              queryClient.invalidateQueries({ queryKey: ['/api/cobrancas'] });
            }
          )
          .subscribe();

        console.log('✅ [REALTIME] Conectado ao canal de atualizações de cobranças.');

        // Limpeza ao desmontar o componente
        return () => {
          supabase.removeChannel(channel);
        };
      }, [queryClient]);
      ```

**PROTOCOLO OBRIGATÓRIO 5-CHECK:**
1.  Mapear o ficheiro `CobrancasPage.tsx`.
2.  Garantir que a subscrição seja limpa (`removeChannel`) no retorno do `useEffect` para evitar memory leaks.
3.  Executar `get_latest_lsp_diagnostics`.
4.  Realizar um teste funcional simulando uma atualização no banco de dados (usando o SQL Editor do Supabase para mudar o status de uma proposta) e validar que a UI atualiza sozinha.
5.  O critério final de sucesso é a atualização automática da tabela na "Tela de Cobranças" após a simulação da mudança no banco de dados.