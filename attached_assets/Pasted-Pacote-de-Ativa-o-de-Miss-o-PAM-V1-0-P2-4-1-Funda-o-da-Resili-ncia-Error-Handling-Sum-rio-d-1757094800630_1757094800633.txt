Pacote de Ativação de Missão (PAM) V1.0 - P2.4.1: Fundação da Resiliência (Error Handling)
Sumário da Missão (O Quê): Implementar um middleware de tratamento de erros (Error Handling) global e centralizado para a nossa aplicação Express.js, substituindo o padrão inconsistente de blocos try/catch que respondem com JSON diretamente nos controllers.

Intenção Estratégica (O Porquê): Esta é a Ação P2.4 do ROADMAP_MESTRE_ACO_LIQUIDO.md. Um sistema resiliente trata falhas de forma previsível e observável. Centralizar o tratamento de erros numa única "rede de segurança" garante que: 1) Nenhuma exceção passe despercebida; 2) Todos os erros sejam logados de forma padronizada; 3) O frontend receba sempre uma resposta de erro consistente, melhorando a experiência do usuário em casos de falha.

Histórico Relevante (Consulta Obrigatória): As auditorias anteriores mostraram múltiplos blocos try/catch nos controllers que usam console.error e res.status(500).json(...). Estes serão os alvos da nossa refatoração.

Modelo Mental (Como se Encaixa): Estamos a instalar uma "caixa preta" no final da nossa cadeia de execução da API. Qualquer error não capturado que ocorra em qualquer rota será canalizado para este middleware final. Ele irá registar os detalhes do desastre para a nossa análise forense (logger) e enviar uma mensagem de desculpas padronizada e segura para o cliente, sem nunca vazar detalhes sensíveis da implementação.

Riscos Antecipados e Contramedidas:

Risco (BAIXO): A ordem de registo do middleware é crítica. Se não for o último app.use(), ele não funcionará corretamente.

Contramedida: O PAM especifica explicitamente que o middleware deve ser o último a ser adicionado à pilha de execução do Express, garantindo a sua correta operação.

IMPLEMENTAR: Middleware de Tratamento de Erros Global

CONTEXT: A aplicação atualmente trata erros de forma descentralizada em múltiplos try/catch nos controllers. Este padrão é inconsistente, difícil de manter e propenso a falhas (ex: esquecer de logar um erro). Precisamos de um padrão centralizado e robusto.

CURRENT STATE: Lógica de tratamento de erro duplicada e inconsistente.

TypeScript

// Exemplo em proposalController.ts
try {
  // ... lógica de negócio ...
} catch (error) {
  console.error('Error:', error); // ❌ Logging inconsistente
  res.status(500).json({
    success: false,
    error: 'Erro interno do servidor' // ❌ Resposta de erro não padronizada
  });
}
EXPECTED (Estado Final de Sucesso):

Um novo arquivo de middleware (server/middleware/errorHandler.ts) existirá, contendo a lógica centralizada de tratamento de erros.

Este middleware será registado como o último na cadeia de execução em server/app.ts (ou server/index.ts).

Os blocos try/catch nos controllers serão simplificados para apenas chamar next(error), delegando a responsabilidade para o middleware global.

Todas as respostas de erro 500 - Internal Server Error serão consistentes e seguras.

CONSTRAINTS (Roadmap de Implementação Faseado):

Fase 1: Criação do Middleware de Resiliência

Crie um novo arquivo: server/middleware/errorHandler.ts.

Implemente e exporte a função de middleware, que deve ter a assinatura de 4 argumentos do Express: (error: Error, req: Request, res: Response, next: NextFunction).

Dentro do middleware:

Use o nosso logger central para registar o erro completo (ex: logger.error(error.message, { stack: error.stack })).

Envie uma resposta JSON padronizada e segura para o cliente. Não vaze o error.stack em produção.

TypeScript

// Exemplo da lógica em server/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import { logger } from '../lib/logger';

export const errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
  logger.error(`Erro não tratado na rota ${req.method} ${req.path}:`, { 
    errorMessage: error.message,
    errorStack: error.stack 
  });

  const isDevelopment = process.env.NODE_ENV === 'development';

  res.status(500).json({
    success: false,
    error: {
      message: isDevelopment ? error.message : 'Ocorreu um erro interno no servidor.',
      stack: isDevelopment ? error.stack : undefined,
    }
  });
};
Fase 2: Ativação do Middleware

Abra o arquivo principal da aplicação (server/app.ts ou server/index.ts).

Importe o errorHandler que acabou de criar.

Como a última instrução app.use() antes do app.listen(), adicione o middleware: app.use(errorHandler);. A ordem aqui é CRÍTICA.

Fase 3: Refatoração Piloto

Abra server/modules/proposal/presentation/proposalController.ts.

Escolha um método que tenha um bloco try/catch (ex: getById).

Refatore o bloco catch para ser mais simples, apenas passando o erro para a "rede de segurança":

TypeScript

// ANTES
// catch (error: any) { ... res.status(500).json(...) ... }

// DEPOIS
catch (error: any) {
  next(error); // Delega para o middleware global
}
Validação Final:

Execute get_latest_lsp_diagnostics. O resultado deve ser ZERO erros.

O seu relatório final deve confirmar a criação e registo do middleware e a refatoração do controller piloto.

DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):

CONFIANÇA NA IMPLEMENTAÇÃO: [Preencher com a porcentagem de 0 a 100%]

RISCOS IDENTIFICADOS: [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO]

DECISÕES TÉCNICAS ASSUMIDAS: [Ex: "Assumi que o logger está disponível para ser importado no novo middleware."]

VALIDAÇÃO PENDENTE: [Ex: "Um teste de integração deve ser criado para simular uma exceção e validar que o middleware a captura e responde no formato esperado."]