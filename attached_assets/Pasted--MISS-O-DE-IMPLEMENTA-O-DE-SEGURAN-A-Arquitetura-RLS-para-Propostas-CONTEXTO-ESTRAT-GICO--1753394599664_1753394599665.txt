# MISSÃO DE IMPLEMENTAÇÃO DE SEGURANÇA: Arquitetura RLS para Propostas

**CONTEXTO ESTRATÉGICO:**
Este prompt é o resultado final de um debate arquitetural e representa a arquitetura de segurança final e aprovada para a tabela `propostas`. A missão é crítica para a integridade de dados e a segurança do nosso sistema multi-tenant.

**AÇÃO:**
Sua missão é executar os seguintes scripts SQL no nosso banco de dados Supabase, na ordem exata apresentada, para implementar a nossa camada de Row Level Security (RLS).

**ROADMAP DE EXECUÇÃO (SQL - Sequencial):**

---
**PASSO 1: Criar a Função Auxiliar de Contexto de Usuário**
* **Execute o seguinte script:**
    ```sql
    CREATE OR REPLACE FUNCTION get_current_user_context()
    RETURNS TABLE(user_id INTEGER, user_role TEXT, user_loja_id INTEGER) AS $$
    BEGIN
      RETURN QUERY
      SELECT u.id, u.role, u.loja_id
      FROM users u
      WHERE u.email = (auth.jwt() ->> 'email')::TEXT
      LIMIT 1;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;
    ```

---
**PASSO 2: Ativar o RLS e Criar as Políticas de Acesso**
* **Execute o seguinte script:**
    ```sql
    -- Habilitar RLS na tabela propostas
    ALTER TABLE propostas ENABLE ROW LEVEL SECURITY;

    -- Política de SELECT (Leitura)
    CREATE POLICY "Users can view propostas based on role and store" ON propostas
      FOR SELECT USING (
        EXISTS (
          SELECT 1 FROM get_current_user_context() AS ctx
          WHERE 
            propostas.user_id = ctx.user_id OR
            ctx.user_role = 'admin' OR
            (ctx.user_role = 'manager' AND propostas.loja_id = ctx.user_loja_id) OR
            ctx.user_role = 'analyst'
        )
      );

    -- Política de INSERT (Criação)
    CREATE POLICY "Users can create propostas for their store" ON propostas
      FOR INSERT WITH CHECK (
        EXISTS (
          SELECT 1 FROM get_current_user_context() AS ctx
          WHERE 
            ctx.user_id IS NOT NULL AND
            propostas.loja_id = ctx.user_loja_id AND
            propostas.user_id = ctx.user_id
        )
      );

    -- Política de UPDATE (Atualização)
    CREATE POLICY "Users can update propostas based on role and ownership" ON propostas
      FOR UPDATE USING (
        EXISTS (
          SELECT 1 FROM get_current_user_context() AS ctx
          WHERE 
            propostas.user_id = ctx.user_id OR
            ctx.user_role = 'admin' OR
            (ctx.user_role = 'manager' AND propostas.loja_id = ctx.user_loja_id) OR
            ctx.user_role = 'analyst'
        )
      );

    -- Política de DELETE (Deleção)
    CREATE POLICY "Only admins can delete propostas" ON propostas
      FOR DELETE USING (
        EXISTS (
          SELECT 1 FROM get_current_user_context() AS ctx
          WHERE ctx.user_role = 'admin'
        )
      );
    ```

---
**PASSO 3: Implementar o Gatilho de Integridade de Dados**
* **Execute o seguinte script:**
    ```sql
    -- Função do Trigger
    CREATE OR REPLACE FUNCTION validate_proposta_integrity()
    RETURNS TRIGGER AS $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1 FROM users u 
        WHERE u.id = NEW.user_id AND u.loja_id = NEW.loja_id
      ) THEN
        RAISE EXCEPTION 'User does not belong to the specified store';
      END IF;
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Criação do Trigger
    CREATE TRIGGER enforce_proposta_integrity
      BEFORE INSERT OR UPDATE ON propostas
      FOR EACH ROW
      EXECUTE FUNCTION validate_proposta_integrity();
    ```
---