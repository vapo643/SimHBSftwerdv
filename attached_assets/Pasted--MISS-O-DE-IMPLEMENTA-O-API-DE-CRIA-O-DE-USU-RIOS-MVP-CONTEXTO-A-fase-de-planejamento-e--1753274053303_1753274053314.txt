# MISSÃO DE IMPLEMENTAÇÃO: API DE CRIAÇÃO DE USUÁRIOS (MVP)

**CONTEXTO:** A fase de planejamento e validação foi concluída. O código abaixo foi auditado e aprovado.

**AÇÃO:** Sua missão é aplicar a seguinte implementação em nosso projeto. Você deve modificar dois ficheiros: `/server/services/userService.ts` e `/server/routes.ts`. Substitua o conteúdo dos ficheiros existentes pelo código exato fornecido abaixo.

---
### **CÓDIGO PARA O FICHEIRO: `/server/services/userService.ts`**

```typescript
import { createServerSupabaseClient } from "../lib/supabase";
import { z } from "zod";
import crypto from "crypto";

// Schema para validação
export const createUserSchema = z.object({
  fullName: z.string().min(1, "Nome completo é obrigatório"),
  email: z.string().email("Email inválido"),
  role: z.enum(['ADMINISTRADOR', 'GERENTE', 'ATENDENTE']),
  lojaId: z.number().int().optional()
}).refine(data => {
  return !((data.role === 'GERENTE' || data.role === 'ATENDENTE') && !data.lojaId);
}, {
  message: "Loja é obrigatória para perfis GERENTE e ATENDENTE",
  path: ["lojaId"]
});

export type UserData = z.infer<typeof createUserSchema>;

interface CreatedUser {
  id: string;
  email: string;
  fullName: string;
  role: string;
  lojaId?: number;
}

// Função mock para enviar email de boas-vindas
function sendWelcomeEmail(email: string, temporaryPassword: string): void {
  console.log(`[MOCK EMAIL] Enviando email de boas-vindas para: ${email}`);
  console.log(`[MOCK EMAIL] Senha temporária: ${temporaryPassword}`);
}

// Gerar senha temporária segura
function generateTemporaryPassword(): string {
  return crypto.randomBytes(12).toString('base64').slice(0, 12);
}

export async function createUser(userData: UserData): Promise<CreatedUser> {
  const supabase = createServerSupabaseClient();
  let createdAuthUser: any = null;

  try {
    const { data: existingUser, error: checkError } = await supabase.auth.admin.getUserByEmail(userData.email);
    if (checkError && checkError.message !== 'User not found') {
        throw new Error(`Erro ao verificar email: ${checkError.message}`);
    }
    if (existingUser.user) {
      throw new Error(`Usuário com email ${userData.email} já existe`);
    }

    const temporaryPassword = generateTemporaryPassword();
    const { data: authData, error: authError } = await supabase.auth.admin.createUser({
      email: userData.email,
      password: temporaryPassword,
      email_confirm: true,
      user_metadata: {
        full_name: userData.fullName,
        role: userData.role
      }
    });

    if (authError) throw new Error(`Erro ao criar usuário no Auth: ${authError.message}`);
    if (!authData.user) throw new Error("Usuário não foi criado no Auth");

    createdAuthUser = authData.user;

    const profileData = {
      id: authData.user.id,
      role: userData.role,
      full_name: userData.fullName,
      loja_id: userData.lojaId || null
    };

    const { error: profileError } = await supabase.from('profiles').insert(profileData);

    if (profileError) {
      console.error("Erro ao inserir profile, fazendo rollback...", profileError);
      await supabase.auth.admin.deleteUser(authData.user.id);
      console.log("Rollback concluído: usuário removido do Auth");
      throw new Error(`Erro ao criar perfil do usuário: ${profileError.message}`);
    }

    sendWelcomeEmail(userData.email, temporaryPassword);

    return {
      id: authData.user.id,
      email: userData.email,
      fullName: userData.fullName,
      role: userData.role,
      lojaId: userData.lojaId
    };

  } catch (error) {
    if (error instanceof Error && error.message.includes('já existe')) {
        throw error;
    }
    if (createdAuthUser) {
        await supabase.auth.admin.deleteUser(createdAuthUser.id);
        console.log("Rollback de emergência concluído");
    }
    throw error;
  }
}
CÓDIGO PARA ADICIONAR AO FICHEIRO: /server/routes.ts
TypeScript

// Adicione esta importação no topo do ficheiro
import { createUser, createUserSchema } from "./services/userService";

// Adicione este middleware antes das suas rotas
const adminMiddleware = async (req: EnhancedAuthRequest, res: any, next: any) => {
  try {
    if (req.user?.role !== 'ADMINISTRADOR') {
      return res.status(403).json({ 
        message: "Acesso negado. Apenas administradores podem acessar este recurso." 
      });
    }
    next();
  } catch (error) {
    console.error("Admin middleware error:", error);
    res.status(500).json({ message: "Erro interno do servidor" });
  }
};

// Adicione este endpoint
app.post("/api/admin/users", authMiddleware, adminMiddleware, async (req: EnhancedAuthRequest, res) => {
  try {
    const validatedData = createUserSchema.parse(req.body);
    const newUser = await createUser(validatedData);
    res.status(201).json({
      message: "Usuário criado com sucesso",
      user: newUser
    });
    
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        message: "Dados inválidos",
        errors: error.errors
      });
    }

    if (error.message.includes('já existe')) {
      return res.status(409).json({
        message: error.message
      });
    }

    console.error("Create user error:", error);
    res.status(500).json({
      message: error.message || "Erro interno do servidor"
    });
  }
});
Aguardando o resultado da execução do Agente.