### Pacote de Ativação de Missão (PAM) V1.0 - Operação "Velocidade de Escape" / Missão 1: Cache Distribuído

* **Sumário da Missão (O Quê):** Refatorar o *hotfix* de cache de token local implementado no *middleware* JWT (`jwt-auth-middleware.ts`) para utilizar a instância de Redis Cloud centralizada e distribuída.
* **Intenção Estratégica (O Porquê):** Eliminar o risco P0 de instabilidade causado pelo cache em memória local. Um cache distribuído (Redis) garante a consistência do estado dos tokens através de múltiplos processos ou reinicializações do servidor, resolvendo a causa raiz da *race condition* de forma robusta e escalável.
* **Modelo Mental (Como se Encaixa):** Você é um engenheiro de backend a substituir uma solução tática de curto prazo por uma solução arquitetural estratégica e de longo prazo.

---
### **DOUTRINA DE EXECUÇÃO OBRIGATÓRIA: PEO V2.0**

* **MODO DE OPERAÇÃO:** Esta missão é de implementação de código. Você operará em **MODO_EXECUÇÃO**.
* **PERSONA:** Adote a persona de **"Executor de Elite"**.
* **CICLO DE AÇÃO MANDATÓRIO (CAM) V3.0:** Siga estritamente os passos: Análise Rápida -> Execução Controlada -> Validação Final -> Relatório Sintético.
* **VALIDAÇÃO (7-CHECK ADAPTATIVO):** O risco desta missão é **BAIXO**. Execute o **"7-CHECK LIGHT"** na sua validação final.

---

**IMPLEMENTAR (Plano de Implementação):**
Execute a seguinte sequência de ações.

**CURRENT STATE:**
O ficheiro `server/lib/jwt-auth-middleware.ts` contém uma implementação de cache de token em memória (`tokenCache`) para mitigar *race conditions*.

**EXPECTED (Estado Final de Sucesso):**
1.  A implementação do cache em memória local é completamente removida.
2.  O *middleware* é refatorado para interagir com o nosso serviço de Redis centralizado.
3.  A lógica de `get`, `set` e `delete` para o cache de tokens é agora executada contra a instância do Redis Cloud.

**CONSTRAINTS (Roadmap de Implementação):**

**Passo 1: Integrar o Cliente Redis no Middleware**
1.1. Abra o ficheiro `server/lib/jwt-auth-middleware.ts`.
1.2. Importe o cliente Redis configurado a partir do nosso módulo centralizado `redis-config.ts`.
1.3. Remova a declaração da variável `tokenCache` em memória.

**Passo 2: Refatorar a Lógica de Cache para Usar Redis**
2.1. Substitua as operações de `tokenCache.get(token)` por chamadas assíncronas ao Redis, como `await redisClient.get(token)`.
2.2. Substitua as operações de `tokenCache.set(token, user, ...)` por chamadas assíncronas ao Redis, como `await redisClient.setex(token, JSON.stringify(user), 300)` (definindo um tempo de expiração de 5 minutos, em segundos).
2.3. Assegure-se de que os dados do utilizador sejam serializados (com `JSON.stringify`) antes de serem guardados e desserializados (com `JSON.parse`) após serem recuperados do Redis.

**Passo 3: Validação Final (Execução do 7-CHECK LIGHT)**
3.1. **(Check 1 e 2):** Apresente o código refatorado do `jwt-auth-middleware.ts` mostrando a nova lógica de cache baseada em Redis.
3.2. **(Check 3):** Execute `get_latest_lsp_diagnostics` para confirmar que não há erros de compilação.
3.3. **Relatório:** Gere o "Relatório de Execução V2 com Prova", confirmando a conclusão bem-sucedida dos passos.

---

### **PROTOCOLO DE DIVULGAÇÃO TOTAL (PDT) V1.0 (MANDATÓRIO)**
Apresente a lista exaustiva de TODAS as suas descobertas, riscos e recomendações.
---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** 95%
* **RISCOS IDENTIFICADOS (LISTA COMPLETA):**
    * **Risco 1 (Baixo):** A gestão de serialização/desserialização de objetos JSON no Redis deve ser tratada corretamente para evitar erros de *parsing*.
* **DECISÕES TÉCNICAS ASSUMIDAS (LISTA COMPLETA):**
    * A conexão com o Redis utilizará o módulo de configuração central já existente e validado.
* **VALIDAÇÃO PENDENTE (LISTA COMPLETA):**
    * A **Missão 4** deste roadmap (Teste de Carga) validará empiricamente a eficácia desta implementação.