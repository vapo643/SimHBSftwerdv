### **Pacote de Ativação de Missão (PAM) V3.4 - BULLMQ-F1-001 (Fundação e Resiliência)**

**[DIRETRIZ MESTRA DE DIVULGAÇÃO - PDT V2.0 ATIVADA]**
*Sua resposta deve ser exaustiva. Reporte a realidade técnica sem omissões. A transparência radical é mandatória.*

* **Sumário da Missão (O Quê):** Refatorar a infraestrutura de filas existente para criar três filas distintas e especializadas (`payments`, `webhooks`, `reports`), cada uma com seu próprio worker, política de retentativas e configuração de Dead-Letter Queue (DLQ), além de implementar um mecanismo de graceful shutdown.
* **Intenção Estratégica (O Porquê):** Construir um sistema de processamento assíncrono que seja resiliente por design. A separação de filas impede que jobs de baixa prioridade (relatórios) bloqueiem processos críticos (pagamentos). As políticas de retry e a DLQ garantem que nenhum webhook ou transação financeira seja perdido devido a falhas transitórias, o que é um requisito de negócio inegociável.
* **Histórico Relevante (Consulta Obrigatória):** A implementação atual em `server/lib/queues.ts` é monolítica, com uma única fila e worker genérico. Esta missão irá decompor essa estrutura em um padrão mais robusto e especializado.
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** **ALTO** - A configuração incorreta das múltiplas instâncias de `Queue` e `Worker` pode levar a consumo excessivo de memória ou conexões com o Redis. A lógica de `graceful shutdown` pode falhar em capturar os sinais de término, resultando em perda de jobs.
    * **Contramedida:** A criação das instâncias de fila deve ser centralizada em um único local para garantir consistência. O `graceful shutdown` deve ser testado rigorosamente, simulando um `SIGTERM` no processo para garantir que os workers aguardem a conclusão dos jobs ativos.

---

**IMPLEMENTAR:**
User Story S4-001: Implementar Infraestrutura de Processamento Assíncrono com BullMQ (8 Pontos, P0)

**CONTEXT:**
Para garantir a resiliência e a escalabilidade do Simpix, precisamos de um sistema de filas de nível industrial. A implementação atual é muito simplista. Esta missão irá construir a fundação de um sistema de alta performance, separando as responsabilidades em filas distintas e garantindo que o sistema possa se desligar de forma limpa e segura, sem perder dados, e que possa lidar com falhas de forma inteligente.

**CURRENT STATE:**
O arquivo `server/lib/queues.ts` define uma única fila genérica. O arquivo `server/worker.ts` define um único processador de worker genérico. Não há políticas de retry explícitas por tipo de job nem uma configuração de Dead-Letter Queue. O tratamento de `SIGTERM` para graceful shutdown é inexistente.

**EXPECTED (Estado Final de Sucesso):**
1.  **Múltiplas Filas Definidas:** O sistema deve ter três instâncias de `BullMQ.Queue` claramente definidas e exportadas:
    * `paymentsQueue`: Para jobs de processamento financeiro.
    * `webhooksQueue`: Para processar webhooks de serviços externos.
    * `reportsQueue`: Para tarefas de baixa prioridade como geração de relatórios.
2.  **Workers Especializados:** Devem existir workers correspondentes para cada fila, cada um processando apenas os jobs de sua respectiva fila.
3.  **Políticas de Retry Diferenciadas:**
    * `paymentsQueue` deve ser configurada com `attempts: 5` e backoff `exponential`.
    * `webhooksQueue` deve ser configurada com `attempts: 3` e backoff `fixed`.
    * `reportsQueue` deve ser configurada com `attempts: 2` e backoff `fixed`.
4.  **Dead-Letter Queue (DLQ) Ativa:** Todos os jobs que falharem em todas as suas tentativas devem ser movidos automaticamente para uma DLQ. Um evento deve ser registrado (`console.error` é suficiente por agora) quando um job for movido para a DLQ.
5.  **Graceful Shutdown Funcional:** O servidor (`server/index.ts`) deve escutar o evento `SIGTERM` e, ao recebê-lo, chamar o método `.close()` em todos os workers, garantindo que eles finalizem seus jobs atuais antes de o processo ser encerrado.

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Refatorar `queues.ts`:** Modifique `server/lib/queues.ts`. Crie e exporte as três instâncias de `Queue` (`paymentsQueue`, `webhooksQueue`, `reportsQueue`), aplicando as `defaultJobOptions` com as políticas de `attempts` e `backoff` especificadas para cada uma.
2.  **Refatorar `worker.ts`:** Crie três instâncias de `Worker` em `server/worker.ts`, cada uma conectada a uma das filas criadas no passo anterior e com seu próprio arquivo de processador lógico (ex: `payment-processor.ts`, `webhook-processor.ts`).
3.  **Implementar Lógica da DLQ:** Na declaração dos workers, adicione os listeners para o evento `failed`. Dentro do listener, verifique se `job.attemptsMade >= job.opts.attempts`. Se verdadeiro, logue um erro indicando que o job foi para a DLQ. A movimentação para a DLQ é gerenciada pelo BullMQ, mas o evento de log é nossa responsabilidade.
4.  **Implementar Graceful Shutdown:** No arquivo `server/index.ts`, adicione o seguinte bloco de código:
    ```typescript
    const workers = [/* adicione suas 3 instâncias de worker aqui */];
    process.on('SIGTERM', async () => {
      console.log('SIGTERM recebido. Desligando workers...');
      await Promise.all(workers.map(worker => worker.close()));
      console.log('Todos os workers foram desligados.');
      process.exit(0);
    });
    ```
5.  **Validação:** Descreva como você testaria o graceful shutdown e a DLQ para garantir que estão funcionando como esperado.
6.  **Verificação Final:** Execute o protocolo `7-CHECK FULL` e preencha a declaração de incerteza.

---

**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO e uma breve descrição]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Listar decisões tomadas que podem ter implicações futuras]
* **VALIDAÇÃO PENDENTE:** [Listar ações que o Orquestrador (GEM 02) ou o QA (GEM 03) devem validar]
---