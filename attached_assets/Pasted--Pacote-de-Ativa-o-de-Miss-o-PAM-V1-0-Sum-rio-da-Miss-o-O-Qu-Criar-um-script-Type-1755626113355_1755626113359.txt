### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Criar um script TypeScript para auditar o uso de cada status na tabela `propostas`.
* **Intenção Estratégica (O Porquê):** Precisamos de dados concretos para identificar quais dos 25+ status são legados e podem ser eliminados com segurança. Esta é a base para a refatoração da máquina de estados.
* **Histórico Relevante (Consulta Obrigatória):** N/A.
* **Modelo Mental (Como se Encaixa):** Este é um script de análise único (one-off). Ele irá se conectar ao banco de dados, executar uma query de agregação e imprimir um relatório no console. Ele não fará parte da aplicação principal.
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** A query pode ser lenta em uma tabela de produção muito grande.
    * **Contramedida:** O script deve usar a conexão de banco de dados de desenvolvimento (`STAGING_DATABASE_URL`) por padrão e se conectar à produção apenas com uma flag explícita.

---

**IMPLEMENTAR:**
Script de Auditoria de Status de Propostas

**CURRENT STATE:**
Não existe nenhum mecanismo para verificar quais valores do `statusEnum` são realmente utilizados no banco de dados. As decisões de refatoração seriam baseadas em suposições.

**EXPECTED (Estado Final de Sucesso):**
Um script TypeScript (`scripts/audit-status.ts`) que, quando executado via `tsx`, realiza o seguinte:
1.  Conecta-se ao banco de dados usando Drizzle.
2.  Executa uma query na tabela `propostas` que agrupa por `status` e conta o número de ocorrências de cada um.
3.  Imprime no console um relatório formatado em tabela, listando todos os 25+ status do `statusEnum`.
4.  Para cada status, mostra a contagem de propostas que o utilizam no banco. Se a contagem for 0, deve ser claramente destacado como **"[LEGACY]"**.

**CONSTRAINTS (Roadmap de Implementação):**
1.  Crie um novo arquivo em `scripts/audit-status.ts`.
2.  Importe a instância `db` do Drizzle e o `statusEnum` de `shared/schema.ts`.
3.  Implemente a lógica principal dentro de uma função `async function main()`.
4.  Use `db.select({ status: propostas.status, count: sql`count(*)` }).from(propostas).groupBy(propostas.status)` para buscar os dados de uso.
5.  Crie um mapa (Map) a partir dos resultados da query para fácil acesso (`status -> count`).
6.  Itere sobre **todos** os valores do `statusEnum` para garantir que mesmo os status não utilizados (com contagem zero) apareçam no relatório.
7.  Para cada status do enum, busque sua contagem no mapa (o valor padrão deve ser 0).
8.  Use `console.log` para imprimir o relatório final formatado como uma tabela alinhada, para garantir a legibilidade. Destaque as contagens zero com a tag `[LEGACY]`.
9.  Chame a função `main()` no final do script e adicione um bloco `.catch()` para logar quaisquer erros que possam ocorrer durante a execução.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO e uma breve descrição]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Listar decisões tomadas que podem ter implicações futuras, ex: "Tipos não validados", "queries sem tipagem otimizada"]
* **VALIDAÇÃO PENDENTE:** [Listar ações que o Orquestrador (GEM 02) ou o QA (GEM 03) devem validar, ex: "Correção completa de tipos antes de qualquer nova funcionalidade"]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear ficheiros e funções exatas afetadas.
2.  Garantir importações e tipos corretos.
3.  Executar `get_latest_lsp_diagnostics` e corrigir TODOS os erros.
4.  **Declarar Nível de Confiança (0-100%)** na implementação.
5.  **Categorizar Riscos Descobertos** (BAIXO/MÉDIO/ALTO/CRÍTICO).
6.  Realizar teste funcional completo.
7.  **Documentar Decisões Técnicas** assumidas para auditoria futura.