### Pacote de Ativação de Missão (PAM) V1.0 - Operação "Escudo de Produção" / Missão 1: Resiliência Assíncrona

* **Sumário da Missão (O Quê):** Auditar a configuração de conexão do Redis e, se aprovada, implementar o padrão Dead-Letter Queue (DLQ) para todas as filas críticas do BullMQ, garantindo a resiliência do sistema de processamento assíncrono.
* **Intenção Estratégica (O Porquê):** Blindar o sistema contra falhas operacionais em produção. Uma configuração de Redis robusta é essencial para a conectividade, e uma DLQ é uma rede de segurança não negociável para capturar e preservar transações financeiras que falhem no processamento, garantindo zero perda de dados.
* **Modelo Mental (Como se Encaixa):** Você é um engenheiro de SRE (Site Reliability Engineering) a executar um checklist de prontidão para produção. A sua execução deve ser metódica, validando cada passo antes de prosseguir.

---

**IMPLEMENTAR (Plano de Implementação e Auditoria):**
Execute a seguinte sequência de ações.

**FASE 1: AUDITORIA DA CONFIGURAÇÃO DO REDIS**

**Passo 1.1: Verificação da Configuração Centralizada**
* Localize o ficheiro `server/lib/redis-config.ts`. Confirme se a função `createRedisConfig` lê as variáveis de ambiente (`REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD`, `REDIS_TLS_ENABLED`) para configurar a conexão em produção e se possui um *fallback* para `localhost` em ambiente de desenvolvimento. Apresente o código como prova.

**Passo 1.2: Verificação da Utilização Consistente**
* Verifique os ficheiros `server/lib/queues.ts`, `server/infrastructure/events/EventDispatcher.ts`, e `server/workers/formalizationWorker.ts`. Confirme que **TODOS** eles importam e utilizam a função `createRedisConfig` do módulo centralizado, em vez de criarem as suas próprias configurações. Reporte qualquer desvio.

**Passo 1.3: Verificação da Documentação de Ambiente**
* Inspecione o ficheiro `.env.example` e confirme que as variáveis `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD`, e `REDIS_TLS_ENABLED` estão documentadas.

**FASE 2: IMPLEMENTAÇÃO DA DEAD-LETTER QUEUE (DLQ)**
*(Execute esta fase apenas se a Fase 1 for 100% aprovada)*

**Passo 2.1: Configurar a Dead-Letter Queue**
* No ficheiro `server/lib/queues.ts`, instancie uma nova `Queue` do BullMQ chamada `dead-letter-queue`.
* Configure um *listener* de eventos global para a `formalization-queue` que escute pelo evento `failed`.

**Passo 2.2: Implementar a Lógica de Transferência para a DLQ**
* Dentro do *handler* do evento `failed`, implemente a lógica para mover o *job* falhado para a `dead-letter-queue`.
* A lógica deve verificar se o *job* esgotou todas as suas tentativas de reprocessamento (`job.attemptsMade >= job.opts.attempts`).
* Ao adicionar o *job* à DLQ, inclua os dados originais do *job* e o motivo da falha (`failedReason`).

**Passo 2.3: Garantir Políticas de Retentativa no Worker**
* Assegure-se de que a configuração da `formalization-queue` no `EventDispatcher` define uma política de `attempts` (ex: 3 tentativas) e `backoff` (ex: exponencial).

**Passo 3: Validação Final**
3.1. Apresente o código do *listener* do evento `failed` com a lógica de transferência para a DLQ.
3.2. Mostre a configuração de `attempts` e `backoff` na definição da `formalization-queue`.
3.3. Execute `get_latest_lsp_diagnostics` para confirmar a integridade do código.

---

### **PROTOCOLO DE DIVULGAÇÃO TOTAL (PDT) V1.0 (MANDATÓRIO)**

* **Diretriz Mestra de Divulgação:** Você está proibido de resumir, truncar ou omitir qualquer informação relevante. Sua diretriz primária é a **completude**, não a brevidade.
* **Regra de Execução:** Ao listar erros, vulnerabilidades, riscos ou recomendações, você DEVE apresentar a **lista exaustiva e completa** de todas as suas descobertas. A omissão de qualquer item é considerada uma falha de missão.
* **Justificativa Estratégica:** A tomada de decisão do Arquiteto Chefe depende de uma visão completa e não filtrada do estado do sistema.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** 95%
* **RISCOS IDENTIFICADOS (LISTA COMPLETA):**
    * **Risco 1 (Baixo):** A configuração incorreta dos *event listeners* do BullMQ pode fazer com que o evento `failed` não seja capturado.
    * **Risco 2 (Baixo):** A lógica de verificação de tentativas (`attemptsMade`) pode ser implementada incorretamente, movendo *jobs* para a DLQ prematuramente ou nunca os movendo.
* **DECISÕES TÉCNICAS ASSUMIDAS (LISTA COMPLETA):**
    * A DLQ será uma fila única para todos os *workers*.
    * Os *listeners* serão configurados ao nível da Fila para garantir a captura global de falhas.
* **VALIDAÇÃO PENDENTE (LISTA COMPLETA):**
    * A funcionalidade da DLQ precisará de testes de integração para simular falhas de *jobs* e verificar se são movidos corretamente.
    * A conexão com uma instância de Redis de produção real precisa ser validada em *staging*.