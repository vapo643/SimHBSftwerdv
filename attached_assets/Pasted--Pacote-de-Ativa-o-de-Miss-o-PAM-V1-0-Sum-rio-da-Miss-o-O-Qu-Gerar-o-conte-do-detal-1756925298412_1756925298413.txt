### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Gerar o conteúdo detalhado do "Manual de Operações e Padrões" em formato Markdown, com um mínimo de 1000 linhas, para documentar os processos de engenharia do projeto Simpix.
* **Intenção Estratégica (O Porquê):** Codificar os processos e padrões de engenharia do projeto Simpix para garantir a consistência, qualidade e manutenibilidade do código-fonte. Este documento servirá como a única fonte da verdade para "como" construímos software, eliminando ambiguidades e acelerando o desenvolvimento.
* **Histórico Relevante (Consulta Obrigatória):** Os padrões aqui definidos são baseados nas melhores práticas da indústria para a "Golden Stack" (Remix, TypeScript, TailwindCSS) e foram validados em projetos de missão crítica.
* **Modelo Mental (Como se Encaixa):** Se o Blueprint Arquitetural é o "o quê" e o "porquê", este Manual de Operações é o "como". Ele é o guia tático que todo desenvolvedor (ou instância de IA) deve seguir para contribuir com o projeto.
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** O Agente pode gerar regras genéricas e incompletas.
    * **Contramedida:** O prompt a seguir contém as configurações completas e exemplos detalhados para cada padrão, fornecendo uma base rica para a IA expandir e detalhar.

---

**IMPLEMENTAR:**
Criar o segundo documento mestre do projeto Simpix: o "Manual de Operações e Padrões".

**CURRENT STATE:**
O Blueprint Arquitetural do projeto está definido, mas os padrões de codificação, protocolo de versionamento e guias de estilo ainda não foram formalizados em um documento centralizado.

**EXPECTED (Estado Final de Sucesso):**
1.  Na pasta `/docs` existente, um novo arquivo chamado `03-manual-de-operacoes.md` deve ser criado.
2.  Este arquivo deve conter uma documentação extremamente detalhada, com no mínimo 1000 linhas, detalhando todos os padrões de engenharia do projeto Simpix, conforme a estrutura nas constraints abaixo.

**CONSTRAINTS (Roadmap de Implementação do Documento):**

Você deve escrever o conteúdo do arquivo `03-manual-de-operacoes.md` em formato Markdown. O documento deve ser um guia prático e prescritivo. Expanda cada um dos pontos a seguir com o máximo de detalhes, explicações e exemplos.

**# Manual de Operações e Padrões do Projeto Simpix**

## 1. Padrões de Qualidade de Código

Esta seção define as ferramentas e regras que garantem a qualidade e a consistência do nosso código-fonte. A adesão a estes padrões não é opcional.

### 1.1. Configuração Completa do ESLint (`.eslintrc.js`)
Apresente e explique detalhadamente a configuração do ESLint. O ESLint é nosso "detetive" de código, responsável por identificar padrões problemáticos e potenciais bugs.

**Contexto para expandir (gere o bloco de código completo e explique cada seção detalhadamente):**
```javascript
// .eslintrc.js
module.exports = {
  root: true, // Impede que o ESLint procure configurações em diretórios pai.
  parser: '@typescript-eslint/parser', // Especifica o parser para que o ESLint entenda a sintaxe do TypeScript.
  plugins: [
    '@typescript-eslint', // Plugin com regras específicas para TypeScript.
    'react',             // Plugin com regras específicas para React.
    'react-hooks',       // Plugin que impõe as regras de Hooks.
    'prettier',          // Integra o Prettier como uma regra do ESLint.
  ],
  extends: [
    'eslint:recommended',                        // Regras base recomendadas pelo ESLint.
    'plugin:@typescript-eslint/recommended',     // Regras recomendadas para TypeScript.
    'plugin:react/recommended',                  // Regras recomendadas para React.
    '@remix-run/eslint-config',                  // Configuração específica para projetos Remix.
    '@remix-run/eslint-config/node',             // Regras adicionais para o ambiente Node.js.
    'plugin:react-hooks/recommended',            // Regras recomendadas para React Hooks.
    'prettier',                                  // Desativa regras de estilo do ESLint que conflitam com o Prettier.
    'plugin:prettier/recommended',               // Ativa o plugin do Prettier. **DEVE SER O ÚLTIMO.**
  ],
  settings: {
    react: {
      version: 'detect', // Detecta automaticamente a versão do React instalada.
    },
  },
  rules: {
    // Impõe as regras do Prettier, reportando diferenças como erros.
    'prettier/prettier': 'error',

    // Exige que as dependências de hooks (useEffect, useCallback, etc.) sejam explicitamente declaradas.
    'react-hooks/exhaustive-deps': 'warn',

    // Impõe que Hooks só podem ser chamados dentro de componentes ou outros Hooks.
    'react-hooks/rules-of-hooks': 'error',

    // Permite o uso de 'require' em arquivos de configuração do servidor.
    '@typescript-eslint/no-var-requires': 'off',

    // Desativa a necessidade de tipos de retorno explícitos em todas as funções, deixando para inferência.
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    
    // Marca variáveis não utilizadas como um aviso, não um erro.
    '@typescript-eslint/no-unused-vars': 'warn',
  },
};
1.2. Configuração Completa do Prettier (.prettierrc)
Apresente e explique a configuração do Prettier. O Prettier é nosso "esteticista" de código, garantindo um estilo visual 100% consistente em toda a base de código.

Contexto para expandir (gere o bloco de código completo e explique cada regra):

JSON

{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "plugins": ["prettier-plugin-tailwindcss"]
}
semi: true: Garante que todas as declarações terminem com ponto e vírgula.

trailingComma: "all": Adiciona uma vírgula ao final de objetos e arrays com múltiplas linhas, facilitando a movimentação de linhas e gerando diffs mais limpos no Git.

singleQuote: true: Padroniza o uso de aspas simples para todas as strings, exceto onde aspas duplas são necessárias (ex: em JSX).

printWidth: 80: Define o comprimento máximo da linha em 80 caracteres, melhorando a legibilidade em telas divididas.

tabWidth: 2: Define a indentação para 2 espaços.

plugins: ["prettier-plugin-tailwindcss"]: Plugin essencial que ordena automaticamente as classes do Tailwind CSS seguindo a ordem recomendada, mantendo o markup limpo e previsível.

1.3. Diretrizes de Estilo e Boas Práticas (TypeScript)
Detalhe as convenções de código que vão além do que as ferramentas podem automatizar.

Nomenclatura:

Interfaces e Tipos: PascalCase (ex: interface UserProfile).

Componentes React: PascalCase (ex: function UserAvatar()).

Variáveis e Funções: camelCase (ex: const userName).

Constantes: UPPER_SNAKE_CASE (ex: const MAX_RETRIES = 3).

Tipagem Explícita: Embora a inferência seja poderosa, parâmetros de função e retornos de funções públicas devem sempre ter tipos explícitos para clareza do contrato da função.

Uso de unknown vs any: O tipo any é proibido. Para tipos desconhecidos (ex: dados de uma API externa), use unknown e realize a verificação de tipo antes de usar a variável.

Estrutura de Arquivos: Mantenha os testes (.spec.ts ou .test.ts) próximos aos arquivos que eles testam. Componentes complexos devem ter seu próprio diretório.

Módulos ES6: Utilize import e export exclusivamente. Evite require.

2. Protocolo de Versionamento
2.1. Estratégia de Branching: Git Flow Simplificado
Descreva detalhadamente o nosso modelo de branching.

main: Esta branch é a fonte da verdade para produção. É sempre estável e "deployable". Nenhum commit é feito diretamente aqui, apenas merges de branches release ou hotfix.

develop: Branch de integração principal. Todas as feature branches são mescladas aqui. Representa o estado mais atual do desenvolvimento para a próxima release.

feature/<nome-da-feature>: Para cada nova funcionalidade, uma branch é criada a partir da develop. O nome deve ser descritivo (ex: feature/user-profile-page). Ao concluir, ela é mesclada de volta na develop via Pull Request.

hotfix/<nome-do-bug>: Para correções críticas em produção, uma branch é criada a partir da main. Após a correção, ela é mesclada tanto na main (para um deploy de emergência) quanto na develop (para incorporar a correção no fluxo de desenvolvimento).

2.2. Padrão de Comunicação: Conventional Commits
Forneça um guia de referência completo para as mensagens de commit.

Estrutura: <type>(<scope>): <description>

Tipos Principais:

feat: Para novas funcionalidades (ex: feat(auth): add password reset flow).

fix: Para correção de bugs (ex: fix(profile): correct avatar upload error).

chore: Para tarefas de manutenção que não alteram o código de produção (ex: chore(deps): update vitest to v1.5.0).

docs: Para mudanças na documentação (ex: docs(readme): update setup instructions).

style: Para mudanças de formatação que não afetam a lógica (ex: style(layout): apply prettier formatting).

refactor: Para reestruturação de código que não corrige um bug nem adiciona uma feature.

test: Para adicionar ou corrigir testes.

Breaking Change: Para mudanças que quebram a compatibilidade, adicione um ! após o tipo (ex: feat(api)!: change user id from int to uuid) e detalhe no rodapé do commit.

3. Guia de Estilo de UI/UX
3.1. Fonte da Verdade do Design
Link para o Figma: [INSERIR LINK DO FIGMA AQUI]

3.2. Sistema de Cores
Descreva a paleta de cores primária e secundária com seus nomes de variáveis CSS e valores hexadecimais.

Primárias:

--primary-500: #4F46E5 (Indigo)

--primary-700: #3730A3 (Indigo Escuro)

Secundárias:

--secondary-500: #10B981 (Esmeralda)

Neutras (Texto e Fundo):

--text-primary: #111827 (Cinza 900)

--text-secondary: #6B7280 (Cinza 500)

--bg-primary: #FFFFFF (Branco)

--bg-secondary: #F3F4F6 (Cinza 100)

Feedback:

--success: #22C55E (Verde)

--error: #EF4444 (Vermelho)

--warning: #F59E0B (Âmbar)

3.3. Espaçamento e Tipografia
Escala de Espaçamento: Baseada em um múltiplo de 4px. Use as classes de utilidade do Tailwind (ex: p-4 para 16px, gap-8 para 32px).

Tipografia:

Fonte Principal: Inter

Escala Tipográfica:

h1: text-4xl (36px), font-bold

h2: text-2xl (24px), font-semibold

h3: text-xl (20px), font-semibold

body: text-base (16px), font-normal

3.4. Biblioteca de Componentes Reutilizáveis
Liste os componentes base e suas principais variantes.

Button:

Variantes: primary, secondary, danger.

Estados: default, hover, focus, disabled.

Input:

Variantes: text, email, password.

Estados: default, focus, error, disabled.

Card:

Componente base para encapsular conteúdo, com padding e sombra padronizados.

DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):

CONFIANÇA NA IMPLEMENTAÇÃO: 95%

RISCOS IDENTIFICADOS: BAIXO - Risco de que as explicações geradas sejam superficiais. O contexto detalhado (ex: blocos de código completos) visa forçar uma elaboração de alta qualidade.

DECISÕES TÉCNICAS ASSUMIDAS: Os padrões de código (.eslintrc.js, .prettierrc) e a estratégia de versionamento são baseados em práticas consolidadas da indústria e adequadas para a nossa stack.

VALIDAÇÃO PENDENTE: O documento gerado deve ser revisado por um arquiteto humano para garantir que todos os exemplos e explicações estão corretos e alinhados com os objetivos do projeto.

PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:

Mapear ficheiros e funções exatas afetadas (/docs/03-manual-de-operacoes.md).

Garantir importações e tipos corretos (Não aplicável para Markdown).

Executar get_latest_lsp_diagnostics e corrigir TODOS os erros (Não aplicável para Markdown).

Declarar Nível de Confiança (0-100%): 95%.

Categorizar Riscos Descobertos: BAIXO.

Realizar teste funcional completo (Revisão humana do documento gerado).

Documentar Decisões Técnicas (As premissas para os padrões estão documentadas neste prompt).







