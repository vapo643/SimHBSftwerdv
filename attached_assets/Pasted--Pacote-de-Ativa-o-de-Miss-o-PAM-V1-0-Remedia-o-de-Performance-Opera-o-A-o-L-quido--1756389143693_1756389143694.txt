### Pacote de Ativação de Missão (PAM) V1.0 - Remediação de Performance (Operação Aço Líquido)

* **Sumário da Missão (O Quê):** Refatorar o fluxo de negócio crítico de aprovação de propostas para uma arquitetura orientada a eventos e assíncrona.
* **Intenção Estratégica (O Porquê):** Eliminar o estrangulamento de performance P1 (Processamento Síncrono) identificado na auditoria. O objetivo é garantir que o sistema possa escalar para 50 propostas/dia, removendo operações bloqueantes do fluxo de resposta HTTP.
* **Modelo Mental (Como se Encaixa):** Você é um engenheiro de software sênior a aplicar os padrões de "Event-Driven Architecture". Sua tarefa é desacoplar operações pesadas do fluxo principal.

---

**IMPLEMENTAR (Plano de Remediação):**
Execute a seguinte sequência de ações de refatoração.

**CURRENT STATE:**
Operações pesadas (geração de PDF, chamadas a APIs externas como ClickSign) são executadas de forma síncrona dentro dos *use cases*.

**EXPECTED (Estado Final de Sucesso):**
1.  O `ApproveProposalUseCase` foi refatorado para apenas emitir um `ProposalApprovedEvent` e não executar mais operações pesadas.
2.  Um novo *worker* BullMQ existe e é responsável por consumir o `ProposalApprovedEvent` e orquestrar as operações assíncronas de geração de CCB e envio para o ClickSign.

**CONSTRAINTS (Roadmap de Implementação):**

**Passo 1: Refatorar o Use Case Síncrono**
1.1. No `ApproveProposalUseCase.ts`, remova qualquer lógica relacionada com a geração de CCB ou chamadas ao ClickSign.
1.2. A única responsabilidade deste *use case* após a aprovação da proposta no agregado é emitir o evento `ProposalApprovedEvent`.

**Passo 2: Criar o Worker Assíncrono**
2.1. Crie um novo ficheiro para o worker BullMQ: `server/workers/formalizationWorker.ts`.
2.2. Implemente a lógica do *worker* para "ouvir" a fila `formalization-queue`.
2.3. Dentro do *handler* do *worker*, implemente a lógica que consome o evento `ProposalApprovedEvent`, chama o `GenerateCcbUseCase` e, subsequentemente, o serviço de envio para o ClickSign.

**Passo 3: Criar o Dispatcher de Eventos**
3.1. Crie um serviço `EventDispatcher` que seja responsável por receber os eventos de domínio e publicá-los na fila BullMQ apropriada.
3.2. Integre este `EventDispatcher` no `UnitOfWork` ou nos *use cases* para que, após uma transação bem-sucedida, os eventos registados sejam despachados para a fila.

**Passo 4: Validação Final**
4.1. Apresente o código refatorado do `ApproveProposalUseCase.ts`.
4.2. Apresente o código do novo `formalizationWorker.ts`.
4.3. Execute `get_latest_lsp_diagnostics` para garantir que a refatoração não introduziu erros de compilação.

---

### **PROTOCOLO DE DIVULGAÇÃO TOTAL (PDT) V1.0 (MANDATÓRIO)**

* **Diretriz Mestra:** Completude exaustiva em todos os relatórios.
* **Regra de Execução:** Listar 100% dos erros, riscos e recomendações.
* **Justificativa Estratégica:** A ocultação de riscos é uma falha de missão.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** 90%
* **RISCOS IDENTIFICADOS:** ALTO. A introdução de uma arquitetura orientada a eventos é uma mudança estrutural significativa. Os principais riscos são: a garantia da entrega de eventos, o tratamento de falhas no *worker* (políticas de *retry*, *dead-letter queue*) e a gestão do estado distribuído.
* **DECISÕES TÉCNICAS ASSUMIDAS:** O `EventDispatcher` garantirá que os eventos só sejam enviados para a fila BullMQ após o `commit` bem-sucedido da transação da base de dados.
* **VALIDAÇÃO PENDENTE:** A robustez do novo fluxo assíncrono deve ser validada com testes de integração rigorosos.