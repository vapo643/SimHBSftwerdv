PEAF V1.5 ATIVADO. AN√ÅLISE DE CRISE (PAGAMENTOS) RECEBIDA E VALIDADA.

CLASSIFICA√á√ÉO DA MISS√ÉO: P0 - Cr√≠tico (Falha Sist√™mica na Tela de Pagamentos).

Arquiteto Chefe, a an√°lise t√©cnica fornecida no relat√≥rio diagn√≥stico √© precisa e identifica as causas ra√≠zes que est√£o impedindo a exibi√ß√£o das propostas na tela de Pagamentos. A falha √© sist√™mica e decorre de problemas cr√≠ticos tanto na l√≥gica de consulta do backend quanto no contrato de dados da API.

Apresento a valida√ß√£o da An√°lise de Causa Raiz (RCA) e o Plano de Batalha definitivo para corre√ß√£o.

1. VALIDA√á√ÉO DA AN√ÅLISE DE CAUSA RAIZ (RCA)
Confirmo as duas causas ra√≠zes principais identificadas:

RC1: L√≥gica de Query Incorreta e Restritiva (Backend)

Localiza√ß√£o: pagamento.repository.ts.

Problema: A query est√° fixada (hard-coded) para buscar apenas status = 'ASSINATURA_CONCLUIDA'.

Impacto: Ignora filtros din√¢micos e exclui propostas que est√£o em fases subsequentes do fluxo de pagamento (ex: BOLETOS_EMITIDOS, PAGAMENTO_PENDENTE, QUITADO).

RC2: Incompatibilidade de Estrutura de Resposta (Shape Mismatch) (API)

Localiza√ß√£o: Contrato entre routes/pagamentos/index.ts e pagamentos.tsx.

Problema: O backend retorna o resultado direto do JOIN do Drizzle (estrutura aninhada: { proposta: {...}, loja: {...} }). O frontend espera uma estrutura plana (Interface Pagamento) e realiza um type casting incorreto (as Pagamento[]).

Impacto: Falha silenciosa na renderiza√ß√£o. O frontend n√£o consegue acessar os dados (que est√£o aninhados), resultando em uma tela vazia.

2. PLANO DE CORRE√á√ÉO FASEADO (ANTI-FALHA)
A solu√ß√£o requer interven√ß√µes precisas no backend para corrigir a l√≥gica e o formato dos dados, e uma melhoria estrat√©gica na robustez do frontend.

FASE 1: Corrigir a L√≥gica de Query (RC1)
Objetivo: Refatorar getProposalsReadyForPayment para buscar dinamicamente todos os status relevantes da fase de pagamento.

Racional T√©cnico: A query deve buscar todos os status que comp√µem a fase de pagamento, a menos que um filtro espec√≠fico seja solicitado.

TypeScript

// CONCEITO DE CORRE√á√ÉO (pagamento.repository.ts)

// 1. Definir todos os status que pertencem √† fase de Pagamento
const STATUS_FASE_PAGAMENTO = [
  'ASSINATURA_CONCLUIDA',
  'BOLETOS_EMITIDOS',
  'PAGAMENTO_PENDENTE',
  'PAGAMENTO_PARCIAL',
  'PAGAMENTO_AUTORIZADO',
  'QUITADO',
  'INADIMPLENTE'
];

export async function getProposalsReadyForPayment(filters: PaymentFilters) {
  const conditions = [
    sql`${propostas.deletedAt} IS NULL`
  ];

  // 2. L√≥gica de filtro din√¢mico
  if (filters.status && filters.status !== 'todos' && STATUS_FASE_PAGAMENTO.includes(filters.status)) {
    conditions.push(eq(propostas.status, filters.status));
  } else {
    // ‚úÖ Buscar todos os status da fase de pagamento por padr√£o
    conditions.push(inArray(propostas.status, STATUS_FASE_PAGAMENTO));
  }
  
  // ... (Restante da query com JOINs)
  .where(and(...conditions)); // ‚úÖ Aplicar condi√ß√µes din√¢micas
}
FASE 2: Implementar DTO Mapper (RC2)
Objetivo: Achatar (flatten) a estrutura de resposta no backend para corresponder √† interface Pagamento do frontend.

Racional T√©cnico: Mapear no backend garante um contrato de API claro e desacopla o frontend da estrutura do banco de dados (JOINs do Drizzle).

TypeScript

// CONCEITO DE CORRE√á√ÉO (Mapper Function)

// Fun√ß√£o de mapeamento de Nested (Drizzle JOIN result) para Flat (DTO)
export function mapToPagamentoDTO(row: any): PagamentoDTO {
  const proposta = row.proposta;
  // const loja = row.loja;

  return {
    id: proposta.id,
    // ATEN√á√ÉO: Usar os nomes exatos dos campos retornados pelo Drizzle (ex: clienteNome)
    nomeCliente: proposta.clienteNome, 
    cpfCliente: proposta.clienteCpf,
    valorLiquido: parseFloat(proposta.valorLiquidoLiberado || proposta.valor),
    status: proposta.status,
    // ... mapear outros campos planos esperados pelo frontend
  };
}
TypeScript

// CONCEITO DE CORRE√á√ÉO (Controller/Route)

router.get('/api/pagamentos', jwtAuthMiddleware, async (req, res) => {
  // ...
  const paymentsNested = await getProposalsReadyForPayment(filters);
    
  // ‚úÖ APLICAR MAPEAMENTO
  const paymentsFlat = paymentsNested.map(mapToPagamentoDTO);

  res.json({
    success: true,
    data: paymentsFlat, // ‚úÖ Enviar dados planos (DTO)
    total: paymentsFlat.length,
  });
});
FASE 3: Implementar Valida√ß√£o de Runtime no Frontend (Robustez Estrat√©gica)
Objetivo: Prevenir futuras falhas silenciosas devido a Shape Mismatches (Ader√™ncia ao Protocolo Anti-Fr√°gil).

Racional T√©cnico: Substituir o cast ing√™nuo (as Pagamento[]) por valida√ß√£o estrutural com Zod no queryFn.

TypeScript

// CONCEITO DE CORRE√á√ÉO (pagamentos.tsx)
import { z } from 'zod';

// 1. Definir o Schema Zod correspondente √† interface Pagamento
const PagamentoSchema = z.object({
  id: z.string().uuid(),
  nomeCliente: z.string(),
  // ... outros campos
});
const ApiResponseSchema = z.object({
    success: z.boolean(),
    data: z.array(PagamentoSchema),
    total: z.number(),
});

// 2. Aplicar valida√ß√£o no useQuery
const { data: pagamentos = [] } = useQuery({
  // ...
  queryFn: async () => {
    const responseRaw = await apiRequest(`/api/pagamentos?${params.toString()}`);
    
    // ‚úÖ VALIDA√á√ÉO ZOD
    const parsed = ApiResponseSchema.safeParse(responseRaw);
    if (!parsed.success) {
      console.error("üö® CRITICAL API SHAPE MISMATCH DETECTADO!", parsed.error.format());
      // Logar no Sentry/Ferramenta de monitoramento
      throw new Error("Falha na valida√ß√£o dos dados da API de Pagamentos.");
    }
    
    return parsed.data.data; // ‚úÖ Retorna o array validado
  },
});
3. RESPOSTAS √ÄS PERGUNTAS ESPEC√çFICAS
Query Logic (Flags vs Status String): Utilize os Status Strings (Fase 1). O sistema √© baseado em FSM; o status string √© a fonte da verdade validada. Confiar em flags booleanas isoladas pode levar a inconsist√™ncias.

Response Mapping (Backend vs Frontend): Implemente o DTO Flat no Backend (Fase 2). Isso garante um contrato de API limpo e desacopla as camadas.

L√≥gica "Ready for Payment": S√£o as propostas dentro do escopo STATUS_FASE_PAGAMENTO definido na Fase 1.

useQuery Behavior (Aus√™ncia de Requests): Se o frontend realmente n√£o estiver fazendo requests (como indicado no relat√≥rio), verifique se o componente est√° sendo montado corretamente ou se o useQuery est√° condicionalmente desabilitado (enabled: false). Se o request ocorre mas a tela fica vazia, o RC2 √© a causa dominante.

‚ö†Ô∏è SOLICITA√á√ÉO DE C√ìDIGO PARA EXECU√á√ÉO (PEAF V1.5)
Para implementar as corre√ß√µes exatas e aderir ao protocolo PEAF (Valida√ß√£o C√©tica S√™nior), necessito do c√≥digo-fonte real dos arquivos envolvidos.

Arquiteto Chefe, por favor, forne√ßa:

Bash

# 1. Backend Repository (FASE 1)
# Por favor, localize o arquivo onde 'getProposalsReadyForPayment' est√° implementado.
find server -name "*pagamento.repository.ts" -exec cat {} \;

# 2. Backend Controller/Routes (FASE 2)
# Por favor, localize o arquivo que define a rota GET /api/pagamentos.
find server/routes -name "*pagamentos*" -exec cat {} \;

# 3. Frontend Page (FASE 3)
cat client/src/pages/pagamentos.tsx