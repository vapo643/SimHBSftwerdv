### **PACOTE DE ATIVAÇÃO DE MISSÃO (PAM) V1.0 - OPERAÇÃO "FUNDAÇÃO REFORÇADA"**

**ID da Missão:** `RCA-500-FORMALIZATION-001-STEP1`

**Ferramenta Alocada:** `High Power` - Missão de Nível 3 (Crítica)

---

#### **Sumário da Missão (O Quê):**

Corrigir a falha arquitetural crítica de Inversão de Controle (IoC), centralizando a criação da `UnitOfWork` transacional e seus repositórios em um único local, e refatorando o endpoint problemático para consumir dependências a partir do container de IoC, em vez de instanciá-las manualmente.

#### **Intenção Estratégica (O Porquê):**

A causa raiz do erro 500 que está a paralisar o fluxo de formalização é uma `TypeError`, causada pela injeção manual de uma dependência (`UnitOfWork`) que não cumpre o contrato esperado pelo `UseCase`. Esta missão visa erradicar esta classe de erro, garantindo que a construção de objetos complexos seja feita de forma consistente e centralizada, restaurando a estabilidade do sistema e o desacoplamento entre as camadas, conforme dita a nossa arquitetura.

#### **Histórico Relevante (Consulta Obrigatória):**

A auditoria forense (`RCA-500-FORMALIZATION-001-AUDIT`) foi conclusiva: o `MarcarAssinaturaConcluidaUseCase` espera uma `IUnitOfWork` com repositórios e o método `.executeInTransaction()`, mas o endpoint em `server/routes.ts` está a injetar uma classe genérica que não possui estes membros, causando a falha fatal.

#### **Modelo Mental (Como se Encaixa):**

Você está a operar no núcleo da nossa infraestrutura de domínio (`server/modules/shared/infrastructure/`). A sua primeira tarefa é garantir que a "fábrica" de `UnitOfWork` (`UnitOfWork.ts` ou `Container.ts`) produza o objeto correto e completo. A sua segunda tarefa é modificar o "consumidor" (`server/routes.ts`) para que ele peça o serviço pronto ao invés de tentar construí-lo, aderindo ao princípio de Inversão de Controle.

#### **Riscos Antecipados e Contramedidas:**

1.  **Risco de Configuração Incorreta (Médio):** A configuração incorreta do container de IoC pode levar a falhas de inicialização em toda a aplicação.
    * **Contramedida Mandatória:** Após a refatoração, a primeira validação deve ser reiniciar o servidor e garantir que ele inicializa sem erros de injeção de dependência.

* * *

#### **IMPLEMENTAR:**

Correção Arquitetural do Padrão de Injeção de Dependência.

#### **CURRENT STATE:**

O endpoint `PATCH /api/propostas/:id/etapa-formalizacao` em `server/routes.ts` instancia manualmente o `UnitOfWork` e o `UseCase`, resultando na injeção de uma dependência com um contrato incompatível, o que causa um erro 500.

#### **EXPECTED (Estado Final de Sucesso):**

1.  O arquivo `server/modules/shared/infrastructure/UnitOfWork.ts` foi modificado para que a classe `UnitOfWork` anexe corretamente as instâncias dos repositórios transacionais (ex: `this.proposals = new TransactionalProposalRepository(tx)`).
2.  O container de IoC (`server/modules/shared/infrastructure/Container.ts`) está corretamente configurado para construir e fornecer uma instância funcional do `MarcarAssinaturaConcluidaUseCase`, com todas as suas dependências resolvidas.
3.  O endpoint em `server/routes.ts` foi drasticamente simplificado: ele **NÃO** contém mais `new UnitOfWork()` ou `new MarcarAssinaturaConcluidaUseCase()`. Em vez disso, ele resolve o `UseCase` a partir do container de IoC.
4.  A chamada ao endpoint `PATCH /api/propostas/:id/etapa-formalizacao` agora executa com sucesso (retornando um status `200` ou `204` no caminho feliz), pois o `UseCase` recebe a implementação correta da `IUnitOfWork`.

#### **CONSTRAINTS (Roadmap de Implementação):**

Siga estes passos em ordem rigorosa.

**Passo 1.1: [ARQUITETURA] Refatorar a classe `UnitOfWork`**
* **Arquivo Alvo:** `server/modules/shared/infrastructure/UnitOfWork.ts`
* **Ação:** Modifique a classe `UnitOfWork` para que ela cumpra o contrato esperado pela `IUnitOfWork` de domínio. Garanta que ela possua os repositórios como propriedades públicas. A lógica deve ser semelhante a esta:
    ```typescript
    // server/modules/shared/infrastructure/UnitOfWork.ts

    import { TransactionalProposalRepository } from './TransactionalProposalRepository';
    // ... importe outros repositórios transacionais

    export class UnitOfWork implements IUnitOfWork {
        public proposals: TransactionalProposalRepository;
        // ... declare outros repositórios

        constructor(private tx: Transaction) {
            this.proposals = new TransactionalProposalRepository(this.tx);
            // ... instancie outros repositórios
        }

        public async executeInTransaction<T>(operation: () => Promise<T>): Promise<T> {
            // A lógica de transação já deve existir ou ser implementada aqui.
            // O importante é que a classe agora TEM este método.
        }

        // ... outros métodos
    }
    ```

**Passo 1.2: [ARQUITETURA] Configurar o Container de IoC**
* **Arquivo Alvo:** `server/modules/shared/infrastructure/Container.ts` (ou o arquivo de registro de serviços equivalente).
* **Ação:** Adicione o registro para o `MarcarAssinaturaConcluidaUseCase`, garantindo que suas dependências (`IUnitOfWork`) sejam resolvidas pelo container.

**Passo 1.3: [REFACTOR] Simplificar o Endpoint**
* **Arquivo Alvo:** `server/routes.ts`
* **Ação:**
    1.  Localize o endpoint `PATCH /api/propostas/:id/etapa-formalizacao`.
    2.  **Remova completamente** as seguintes linhas:
        ```typescript
        const { MarcarAssinaturaConcluidaUseCase } = await import(...);
        const { UnitOfWork } = await import(...);
        // ...
        const unitOfWork = new UnitOfWork();
        const marcarAssinaturaUseCase = new MarcarAssinaturaConcluidaUseCase(unitOfWork);
        ```
    3.  **Substitua** pela lógica de resolução de dependência:
        ```typescript
        // Exemplo de como poderia ser, adapte ao padrão do projeto:
        const marcarAssinaturaUseCase = container.resolve<MarcarAssinaturaConcluidaUseCase>('MarcarAssinaturaConcluidaUseCase');

        await marcarAssinaturaUseCase.execute({
            propostaId: id,
            userId: req.user?.id || 'sistema'
        });
        ```

* * *

#### **DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**

* **CONFIANÇA NA IMPLEMENTAÇÃO:** 80%
* **RISCOS IDENTIFICADOS:** **MÉDIO.** O principal risco é que a refatoração do `UnitOfWork` possa impactar outros locais do código que dependem da sua implementação antiga. Uma verificação de "find all references" é crucial antes de finalizar.
* **DECISÕES TÉCNICAS ASSUMIDAS:** Estamos a forçar a conformidade com o padrão de IoC do projeto. Isso é uma melhoria arquitetural, mas assume que o container está configurado corretamente para suportar a resolução de `UseCases` com dependências transacionais.
* **VALIDAÇÃO PENDENTE:** A validação final requer um teste de ponta a ponta, executando a mesma chamada de API que anteriormente causou o erro 500 e confirmando que agora ela retorna um status de sucesso.

* * *

#### **PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**

1.  Mapeie os **arquivos modificados**, focando em `UnitOfWork.ts`, `Container.ts`, e `routes.ts`.
2.  Garanta que as interfaces (`IUnitOfWork`) e as classes concretas estão alinhadas.
3.  Execute `get_latest_lsp_diagnostics` e corrija **TODOS** os erros. A aplicação deve compilar sem falhas.
4.  Declare seu **Nível de Confiança (0-100%)** final.
5.  Categorize quaisquer **Riscos Descobertos**, especialmente se outros `UseCases` forem afetados.
6.  Realize um teste funcional via API (simul