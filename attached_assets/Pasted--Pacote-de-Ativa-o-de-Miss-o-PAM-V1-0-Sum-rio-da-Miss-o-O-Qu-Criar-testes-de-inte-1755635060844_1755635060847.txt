### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Criar testes de integração para o `statusFsmService` e o `status-context-helper` para garantir a robustez, a correção e a atomicidade da lógica de transição de status.
* **Intenção Estratégica (O Porquê):** Mitigar o risco de regressões na lógica de negócio mais crítica da aplicação. Testes automatizados garantirão que futuras alterações no complexo sistema de status não introduzam bugs ou inconsistências de dados, servindo como uma "documentação viva" do comportamento esperado.
* **Histórico Relevante (Consulta Obrigatória):** A auditoria identificou que a lógica de status, apesar de refatorada, carece de cobertura de testes automatizados. O sistema já utiliza `vitest` e possui um padrão para testes de integração.
* **Modelo Mental (Como se Encaixa):** Esta missão criará uma suíte de testes que valida o "contrato" do nosso sistema de status. Ela irá simular cenários de negócio reais, forçando transições válidas e inválidas, e verificando o estado do banco de dados para confirmar o resultado.
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** Os testes podem ser lentos ou instáveis se dependerem de um banco de dados compartilhado.
    * **Contramedida:** Os testes devem ser projetados para rodar contra um banco de dados de teste isolado e devem incluir uma lógica rigorosa de `setup` e `teardown` para garantir que cada teste seja independente.

---

**IMPLEMENTAR:**
Suíte de Testes de Integração para o Sistema de Status

**CURRENT STATE:**
A lógica de transição de status, encapsulada no `statusFsmService` e no `status-context-helper`, não possui cobertura de testes automatizados, representando um risco significativo de regressão.

**EXPECTED (Estado Final de Sucesso):**
1.  Um novo arquivo de teste, `tests/integration/status-system.test.ts`, é criado.
2.  A suíte de testes utiliza `vitest`.
3.  O arquivo implementa uma lógica de `beforeEach` para limpar as tabelas relevantes e criar uma proposta de teste em um estado inicial. Um `afterEach` garante a limpeza pós-teste.
4.  São criados testes para cobrir os seguintes cenários:
    * **Cenário 1 (Transição Válida):** Um teste que chama `transitionTo` com uma transição válida (ex: de `DOCUMENTOS_PENDENTES` para `APROVADO`). As asserções (`expect`) devem verificar se o status na tabela `propostas` foi atualizado corretamente e se um novo registro foi criado na tabela `proposta_logs`.
    * **Cenário 2 (Transição Inválida):** Um teste que chama `transitionTo` com uma transição inválida (ex: de `APROVADO` para `REJEITADO`). A asserção deve verificar se a função lança a exceção `InvalidTransitionError`.
    * **Cenário 3 (Atomicidade da Dupla Escrita):** Um teste que valida a função `updateStatusWithContext` diretamente, garantindo que a escrita na tabela `propostas` e na tabela `status_contextuais` ocorra de forma atômica (ou ambas bem-sucedidas ou nenhuma).

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Crie o Arquivo de Teste:** Crie o novo arquivo `tests/integration/status-system.test.ts`.
2.  **Use `vitest`:** Utilize as funções `describe`, `it`, `beforeEach`, `afterEach`, e `expect` do `vitest`.
3.  **Banco de Dados de Teste:** O teste deve se conectar a um banco de dados de teste. Assuma que a configuração para isso já existe e que a instância `db` importada apontará para o banco correto no ambiente de teste.
4.  **Setup e Teardown:**
    * No `beforeEach`, use o Drizzle para deletar todos os registros das tabelas `propostas`, `proposta_logs`, e `status_contextuais`. Em seguida, crie uma proposta de teste com um status inicial conhecido.
    * No `afterEach`, execute a limpeza novamente para garantir o isolamento.
5.  **Implemente os Testes:** Codifique os três cenários descritos em `EXPECTED`, com asserções claras e específicas. Para o teste de transição inválida, use `expect(...).rejects.toThrow(InvalidTransitionError)`.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO. Risco de configuração do ambiente de teste.]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Ex: "Assumi que o ambiente de teste (`vitest.config.ts`) está configurado para gerenciar variáveis de ambiente e a conexão com o banco de dados de teste."]
* **VALIDAÇÃO PENDENTE:** [A execução da suíte de testes em um ambiente de CI para garantir que não haja instabilidade ("flakiness").]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear ficheiros e funções exatas afetadas (criação do novo arquivo de teste).
2.  Garantir importações e tipos corretos para as funções de teste e o Drizzle.
3.  Executar `get_latest_lsp_diagnostics` para garantir 0 erros no novo arquivo.
4.  **Declarar Nível de Confiança (100%)** na criação dos testes.
5.  **Categorizar Riscos Descobertos**.
6.  **Realizar teste funcional completo** (executar a nova suíte de testes e garantir que todos os testes passem).
7.  **Documentar Decisões Técnicas** como a estrutura do setup/teardown dos testes.