O plano para implementar a "Esteira de Análise" foi validado.

Sua tarefa agora é executar o seguinte plano de 3 etapas para dar vida ao "Painel de Análise Manual":

**1. Atualize o Backend com as Novas Rotas:**
Modifique o arquivo de rotas do seu servidor Express.js (provavelmente `/server/routes.ts`). Adicione/substitua os endpoints de proposta para incluir a lógica de atualização e a busca de logs:

```typescript
// server/routes.ts

// ATUALIZAR status da proposta e criar log
app.put("/api/propostas/:id/status", authMiddleware, async (req, res) => {
    try {
        const id = req.params.id;
        const { status, observacao } = req.body;
        
        // Supondo que 'req.user.id' é disponibilizado pelo authMiddleware
        const userId = (req as any).user?.id; 
        if (!userId) return res.status(401).json({ message: "Usuário não autenticado." });

        await storage.updatePropostaStatus(id, status);
        await storage.createLog({ proposta_id: id, user_id: userId, status_novo: status, observacao });

        res.status(200).json({ message: "Status atualizado com sucesso" });
    } catch (error) {
        console.error("Erro ao atualizar status da proposta:", error);
        res.status(500).json({ message: 'Erro ao atualizar status da proposta' });
    }
});

// BUSCAR logs de uma proposta
app.get("/api/propostas/:id/logs", authMiddleware, async (req, res) => {
    try {
        const id = req.params.id;
        const logs = await storage.getPropostaLogs(id);
        
        if (!logs) {
            return res.status(404).json({ message: "Nenhum log encontrado para esta proposta." });
        }
        
        res.status(200).json(logs);
    } catch (error) {
        console.error("Erro ao buscar logs da proposta:", error);
        res.status(500).json({ message: 'Erro ao buscar histórico de decisões' });
    }
});
2. Crie o Componente de Histórico no Frontend:
Crie um novo arquivo em /client/src/components/analise/HistoricoComunicao.tsx e cole o seguinte código exato dentro dele:

TypeScript

import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface Log {
    id: number;
    status_novo: string;
    observacao: string | null;
    user_id: string; // No futuro, buscaríamos o nome do usuário
    created_at: string;
}

const fetchLogs = async (propostaId: string | undefined) => {
    if (!propostaId) return [];
    const response = await fetch(`/api/propostas/${propostaId}/logs`);
    if (!response.ok) {
        throw new Error('Erro ao carregar histórico');
    }
    return response.json();
}

const HistoricoComunicao: React.FC<{ propostaId: string | undefined }> = ({ propostaId }) => {
  const { data: logs, isLoading, isError } = useQuery<Log[]>(
      ['proposta_logs', propostaId], 
      () => fetchLogs(propostaId), 
      { enabled: !!propostaId }
  );

  return (
    <Card>
      <CardHeader>
        <CardTitle>Histórico e Comunicação</CardTitle>
      </CardHeader>
      <CardContent>
        {isLoading && <p className="text-sm text-muted-foreground">Carregando histórico...</p>}
        {isError && <p className="text-sm text-red-500">Erro ao carregar histórico.</p>}
        {!isLoading && !isError && (
          <ul className="space-y-4">
            {logs && logs.length > 0 ? logs.map(log => (
              <li key={log.id} className="text-sm border-b pb-2">
                <p><strong>Status:</strong> <span className="font-semibold">{log.status_novo}</span></p>
                <p><strong>Observação:</strong> {log.observacao || "Nenhuma observação."}</p>
                <p className="text-xs text-muted-foreground mt-1">
                  por: {log.user_id.substring(0, 8)}... em {new Date(log.created_at).toLocaleString('pt-BR')}
                </p>
              </li>
            )) : <p className="text-sm text-muted-foreground">Nenhum histórico para esta proposta.</p>}
          </ul>
        )}
      </CardContent>
    </Card>
  );
};

export default HistoricoComunicao;
3. Integre a Lógica Completa na Página de Análise:
Substitua todo o conteúdo do arquivo /client/src/pages/credito/analise.tsx pelo seguinte código exato, que agora conecta o formulário à API e exibe o histórico:

TypeScript

import React from 'react';
import { useRoute, Link } from 'wouter';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import DashboardLayout from '@/components/DashboardLayout';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import HistoricoComunicao from '@/components/analise/HistoricoComunicao';

const fetchProposta = async (id: string | undefined) => {
    if (!id) throw new Error("ID da proposta não fornecido.");
    const res = await fetch(`/api/propostas/${id}`);
    if (!res.ok) throw new Error('Proposta não encontrada');
    return res.json();
}

const updatePropostaStatus = async ({ id, status, observacao }: { id: string, status: string, observacao?: string }) => {
    const res = await fetch(`/api/propostas/${id}/status`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status, observacao })
    });
    if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || 'Falha ao atualizar status');
    }
    return res.json();
}

const decisionSchema = z.object({
  status: z.enum(['Aprovada', 'Negada', 'Pendente com Observação']),
  observacao: z.string().optional(),
});

type DecisionFormData = z.infer<typeof decisionSchema>;

const AnaliseManualPage: React.FC = () => {
  const [match, params] = useRoute("/credito/analise/:id");
  const propostaId = params?.id;
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  const { data: proposta, isLoading, isError } = useQuery(['proposta', propostaId], () => fetchProposta(propostaId), { enabled: !!propostaId });
  
  const { register, handleSubmit, control } = useForm<DecisionFormData>({
    resolver: zodResolver(decisionSchema),
  });

  const mutation = useMutation(updatePropostaStatus, {
      onSuccess: () => {
          toast({ title: "Sucesso!", description: "O status da proposta foi atualizado." });
          queryClient.invalidateQueries({ queryKey: ['proposta', propostaId] });
          queryClient.invalidateQueries({ queryKey: ['proposta_logs', propostaId] });
      },
      onError: (error: Error) => {
          toast({ title: "Erro!", description: error.message, variant: "destructive" });
      }
  });

  const onSubmit = (data: DecisionFormData) => {
      if (!propostaId) return;
      mutation.mutate({ id: propostaId, ...data });
  };

  if (isLoading) return <DashboardLayout title="Análise Manual"><p className="p-6">Carregando proposta...</p></DashboardLayout>;
  if (isError || !proposta) return <DashboardLayout title="Erro"><p className="p-6">Proposta não encontrada. <Link to="/credito/fila" className="text-blue-500 hover:underline">Voltar para a fila.</Link></p></DashboardLayout>;

  return (
    <DashboardLayout title={`Análise Manual - Proposta #${proposta.id}`}>
      <div className="grid md:grid-cols-3 gap-6">
        <div className="md:col-span-2 space-y-6">
            <Card>
              <CardHeader><CardTitle>Detalhes da Proposta</CardTitle></CardHeader>
              <CardContent>
                <p><strong>Cliente:</strong> {proposta.clienteNome || 'N/A'}</p>
                {/* Outros detalhes da proposta */}
              </CardContent>
            </Card>
            <Card>
                <CardHeader><CardTitle>Painel de Decisão</CardTitle></CardHeader>
                <CardContent>
                    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
                        <div>
                            <Label>Decisão</Label>
                             <Controller 
                                name="status" 
                                control={control} 
                                render={({ field }) => (
                                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                                        <SelectTrigger><SelectValue placeholder="Selecione uma decisão..." /></SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="Aprovada">Aprovar Proposta</SelectItem>
                                            <SelectItem value="Negada">Negar Proposta</SelectItem>
                                            <SelectItem value="Pendente com Observação">Pendenciar</SelectItem>
                                        </SelectContent>
                                    </Select>
                                )} 
                            />
                        </div>
                        <div>
                            <Label htmlFor="observacao">Observações (obrigatório se pendenciar)</Label>
                            <Textarea id="observacao" {...register('observacao')} />
                        </div>
                        <Button type="submit" className="w-full" disabled={mutation.isPending}>
                            {mutation.isPending ? "Salvando..." : "Confirmar Decisão"}
                        </Button>
                    </form>
                </CardContent>
            </Card>
        </div>
        <div className="md:col-span-1">
            <HistoricoComunicao propostaId={propostaId} />
        </div>
      </div>
    </DashboardLayout>
  );
}

export default AnaliseManualPage;
Execute este plano de 3 etapas.