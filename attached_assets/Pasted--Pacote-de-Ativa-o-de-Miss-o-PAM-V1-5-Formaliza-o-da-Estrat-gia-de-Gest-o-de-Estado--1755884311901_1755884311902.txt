### Pacote de Ativação de Missão (PAM) V1.5 (Formalização da Estratégia de Gestão de Estado)

* **Sumário da Missão (O Quê):** Gerar o documento `state-management-strategy.md`, detalhando a nossa doutrina para a gestão de estado no cliente, com base nos "Subtópicos Obrigatórios" do Ponto 59 da nossa Doutrina Arquitetural.
* **Intenção Estratégica (O Porquê):** Padronizar a nossa abordagem à gestão de estado no frontend. Uma estratégia clara previne a complexidade acidental, o "prop drilling" e o estado inconsistente, garantindo que a nossa UI seja previsível, performática e de fácil manutenção.
* **Histórico Relevante (Consulta Obrigatória):** A nossa base de código já utiliza um conjunto de ferramentas de gestão de estado (TanStack Query, Context API, useReducer). Esta missão irá formalizar as "regras de engajamento" para cada uma, transformando a prática existente em doutrina oficial.
* **Modelo Mental (Como se Encaixa):** Aja como um Arquiteto de Frontend Sênior. Sua tarefa é criar o "manual de regras" que os desenvolvedores devem seguir ao decidir como gerir um novo pedaço de estado na aplicação.

---

**IMPLEMENTAR:**
Documento de Estratégia de Gestão de Estado no Cliente

**CURRENT STATE:**
Utilizamos várias ferramentas de gestão de estado, mas as regras para quando usar cada uma existem apenas de forma implícita, o que pode levar a inconsistências no futuro.

**EXPECTED (Estado Final de Sucesso):**
Um novo arquivo Markdown, `architecture/02-technical/state-management-strategy.md`, é criado. O arquivo deve conter as seguintes seções, conforme o Ponto 59:

1.  **A Doutrina de Separação de Estado:** Uma seção introdutória que explica a distinção fundamental entre:
    * **Estado do Servidor (Server Cache State):** Dados que vivem no backend e que nós armazenamos em cache no frontend.
    * **Estado da UI (Client UI State):** Dados que vivem apenas no navegador e descrevem o estado da interface.
2.  **Estratégia para Estado do Servidor:** Formalizar o uso do **`TanStack Query`** como a nossa ferramenta padrão para todo o estado do servidor. Detalhar as nossas políticas para:
    * Caching (`staleTime`, `cacheTime`).
    * Sincronização em segundo plano.
    * Invalidação de queries após mutações.
3.  **Estratégia para Estado Global da UI:** Formalizar o uso da **`React Context API`** para o estado global que é partilhado por toda a aplicação, mas que vive no cliente.
    * **Exemplos de Uso:** Autenticação do usuário (`AuthContext`), Tema da UI (`ThemeContext`), Feature Flags (`FeatureFlagContext`).
4.  **Estratégia para Estado Local Complexo:** Formalizar o uso do hook **`useReducer`**, muitas vezes combinado com um Context Provider local, para formulários complexos de múltiplas etapas ou componentes com muitos estados interdependentes (ex: `ProposalContext`).
5.  **Estratégia de Persistência de Estado no Cliente:** Descrever a nossa política para o uso do `LocalStorage`, por exemplo, para persistir o tema da UI ou dados de formulários não submetidos.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Ex: "Assumi que a combinação TanStack Query + Context API + useReducer é a stack de gestão de estado ideal para as nossas necessidades atuais."]
* **VALIDAÇÃO PENDENTE:** [O documento gerado deve ser revisado e ratificado pelo Arquiteto Chefe.]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear o ficheiro exato a ser criado.
2.  Garantir que todas as seções obrigatórias que definem a nossa estratégia de estado estão completas.
3.  Executar `get_latest_lsp_diagnostics` para garantir que o ambiente está estável.
4.  **Declarar Nível de Confiança (0 a 100%)**.
5.  **Categorizar Riscos Descobertos**.
6.  **Realizar teste funcional completo** (revisão do documento Markdown gerado).
7.  **Documentar Decisões Técnicas**.