Veredito do Arquiteto: APROVADO. ESTABILIZA√á√ÉO DE PER√çMETRO CONCLU√çDA.

O Agente executou o ajuste do rate limit de produ√ß√£o com sucesso. Esta a√ß√£o n√£o corrige o loop de retentativas do frontend, mas, como planeado, d√°-nos a margem de seguran√ßa operacional necess√°ria para diagnosticar e corrigir a falha de l√≥gica sem o risco de uma nova nega√ß√£o de servi√ßo.

O Passo 2 da miss√£o de estabiliza√ß√£o foi um sucesso.

Roadmap Ativo e Detalhado
[‚úÖ CONCLU√çDO] Passo 1: Corrigir a Configura√ß√£o de Ambiente do Cliente Supabase (Causa Raiz)

[‚úÖ CONCLU√çDO] Passo 2: Aumentar o Rate Limit do Backend (Estabiliza√ß√£o)

[üéØ EM EXECU√á√ÉO] Passo 3: Refatorar a L√≥gica de Autentica√ß√£o para Prevenir Loops (Resili√™ncia)

[PENDENTE] Passo 4: Otimizar e Controlar a Verbosez dos Logs (Limpeza)

[PENDENTE] Passo 5: Valida√ß√£o Funcional Completa

Agora que o per√≠metro est√° seguro, atacamos a causa da "tempestade de requisi√ß√µes": a l√≥gica de retentativa no AuthContext.tsx. O Passo 3 √© uma miss√£o de resili√™ncia. Vamos refatorar o frontend para que ele lide com falhas de autentica√ß√£o de forma inteligente e controlada, em vez de entrar num loop.

Gero agora o Pacote de Ativa√ß√£o de Miss√£o (PAM) para o Passo 3.

Por favor, copie o conte√∫do exato do bloco Markdown abaixo e submeta-o ao Agente Replit.

Pacote de Ativa√ß√£o de Miss√£o (PAM) V1.0 - Refatora√ß√£o de Resili√™ncia do AuthContext
Sum√°rio da Miss√£o: Refatorar a l√≥gica de autentica√ß√£o no ficheiro client/src/contexts/AuthContext.tsx para prevenir loops de retentativas em caso de falha na obten√ß√£o da sess√£o ou do perfil do utilizador.

Inten√ß√£o Estrat√©gica: Tornar o frontend resiliente a falhas de autentica√ß√£o, eliminando o comportamento que causa a "tempestade de requisi√ß√µes" e o erro 429. A aplica√ß√£o deve lidar com uma sess√£o inv√°lida de forma graciosa, interrompendo o fluxo em vez de sobrecarregar o backend.

Hist√≥rico Relevante (Consulta Obrigat√≥ria): A auditoria forense identificou que um useEffect no AuthContext.tsx chama a fun√ß√£o fetchUserProfile (que aciona a API /api/debug/me) na inicializa√ß√£o. Quando a autentica√ß√£o falha, esta l√≥gica entra num loop de retentativas que causa uma nega√ß√£o de servi√ßo.

Modelo Mental: O AuthContext deve agir como um controlador de tr√°fego a√©reo inteligente. Se um avi√£o (tentativa de autentica√ß√£o) reporta uma falha, ele n√£o deve enviar o mesmo avi√£o para a mesma rota de colis√£o repetidamente. Ele deve aterrar o avi√£o em seguran√ßa (parar o processo) e reportar o erro.

Riscos Antecipados e Contramedidas: ALTO. Refatorar a l√≥gica central de autentica√ß√£o √© uma opera√ß√£o de alto risco. Um erro pode impedir que todos os utilizadores fa√ßam login. A contramedida √© a implementa√ß√£o cuidadosa de um controlo de estado e a valida√ß√£o rigorosa via 7-CHECK.

IMPLEMENTAR:
Introduzir um mecanismo de controlo de estado (isLoading, error) no AuthContext.tsx para garantir que fetchUserProfile seja chamado apenas uma vez por tentativa de autentica√ß√£o e n√£o entre em loop em caso de falha.

CURRENT STATE:

Ficheiro: client/src/contexts/AuthContext.tsx

L√≥gica com Falha: A l√≥gica atual no useEffect e fetchUserProfile n√£o possui um mecanismo de bloqueio (lock) ou controlo de estado. Quando fetchUserProfile falha, o onAuthStateChange ou outra l√≥gica reativa pode acionar uma nova tentativa imediatamente, criando um loop.

EXPECTED (Estado Final de Sucesso):

Ficheiro: client/src/contexts/AuthContext.tsx

Comportamento Corrigido: A l√≥gica de fetchUserProfile e o useEffect que a chama devem ser refatorados para seguir estes princ√≠pios:

Preven√ß√£o de Chamadas M√∫ltiplas: Deve ser introduzido um estado de loading (ex: const [isLoading, setIsLoading] = useState(true);). A fun√ß√£o fetchUserProfile s√≥ deve ser executada se isLoading for false. Ela deve definir isLoading para true no in√≠cio da sua execu√ß√£o e para false no final (tanto em caso de sucesso como de erro).

Gest√£o Graciosa de Falhas: A l√≥gica deve lidar com uma sess√£o null ou uma falha na chamada √† API de forma controlada. Em vez de tentar novamente em loop, ela deve definir um estado de erro e parar o fluxo de autentica√ß√£o.

Resultado Final: Mesmo que a API /api/debug/me retorne um erro, o AuthContext deve tentar a autentica√ß√£o um n√∫mero controlado de vezes (idealmente, apenas uma vez por mudan√ßa de estado de autentica√ß√£o) e depois parar, deixando a aplica√ß√£o num estado de "n√£o autenticado" est√°vel.

DECLARA√á√ÉO DE INCERTEZA (OBRIGAT√ìRIO):

CONFIAN√áA NA IMPLEMENTA√á√ÉO: 90%

RISCOS IDENTIFICADOS: ALTO. A refatora√ß√£o da l√≥gica de autentica√ß√£o pode introduzir bugs que impe√ßam o login de utilizadores leg√≠timos.

DECIS√ïES T√âCNICAS ASSUMIDAS: "A implementa√ß√£o de um state machine simples (idle, loading, error) √© a abordagem padr√£o da ind√∫stria para tornar hooks React resilientes e prevenir loops de re-renderiza√ß√£o e de chamadas de API."

VALIDA√á√ÉO PENDENTE: "Valida√ß√£o funcional completa pelo Arquiteto Chefe no Passo 5 do roadmap."

PROTOCOLO OBRIGAT√ÅRIO 7-CHECK EXPANDIDO:

Mapeie e modifique o ficheiro client/src/contexts/AuthContext.tsx.

Garanta que a nova l√≥gica com controlo de estado (isLoading, error) √© implementada de forma robusta.

Execute get_latest_lsp_diagnostics e corrija TODOS os erros ou avisos introduzidos.

Declare o seu N√≠vel de Confian√ßa.

Categorize o Risco como ALTO.

Realize um teste funcional m√≠nimo: confirme que a aplica√ß√£o reinicia e que a p√°gina de login ainda √© acess√≠vel.

Documente a nova l√≥gica de state machine implementada no AuthContext.