### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Implementar de ponta a ponta a pipeline de leitura de metadados de documentos no backend, modificando o Domínio, o Repositório (Query e Mapper) e o Controller para incluir a lista de documentos na resposta do endpoint `GET /api/propostas/:id`.
* **Intenção Estratégica (O Porquê):** Para restaurar o fluxo de análise de propostas, é imperativo que o analista tenha acesso aos documentos enviados pelo proponente. Esta missão irá construir a "ponte de dados" que falta entre o banco de dados e o frontend, desbloqueando uma funcionalidade de negócio crítica.
* **Histórico Relevante (Consulta Obrigatória):** A sua própria auditoria forense anterior já confirmou que a pipeline de leitura de documentos está completamente ausente. A coluna `documentos` existe na tabela `propostas`, mas não é selecionada, mapeada ou retornada pela API. A sua missão é construir esta pipeline.

---

**IMPLEMENTAR:**
Construção da Pipeline de Leitura de Metadados de Documentos.

**CURRENT STATE:**
O endpoint `GET /api/propostas/:id` não retorna a lista de documentos associados à proposta. A falha ocorre em quatro camadas:
1.  A query `findById` em `ProposalRepository` não seleciona a coluna `documentos`.
2.  O agregado `Proposal` não possui uma propriedade para os documentos.
3.  O `mapToDomain` não mapeia os documentos.
4.  O `proposalController` não retorna os documentos no DTO.

**EXPECTED (Estado Final de Sucesso):**
Uma refatoração coordenada em múltiplos ficheiros que resulta no endpoint `GET /api/propostas/:id` a retornar um objeto JSON que inclui um campo `documentos`, contendo um array com os nomes dos ficheiros (strings) associados à proposta.

**CONSTRAINTS (Roadmap de Implementação Faseado):**

**Fase 1: Modificação do Domínio**
1.  Abra o arquivo `server/modules/proposal/domain/Proposal.ts`.
2.  Adicione uma nova propriedade privada à classe `Proposal`: `private _documentos: string[] | null;`.
3.  Adicione um getter público para esta propriedade: `public get documentos(): string[] | null { return this._documentos; }`.
4.  Na interface `ProposalProps`, adicione o campo `documentos?: string[] | null;`.
5.  No construtor e no método `fromDatabase`, atribua o valor recebido à nova propriedade.
6.  No método `toPersistence`, inclua a propriedade `documentos: this._documentos`.

**Fase 2: Modificação do Repositório**
1.  Abra o arquivo `server/modules/proposal/infrastructure/ProposalRepository.ts`.
2.  Na função `findById`, modifique a query Drizzle ORM para **adicionar a coluna `documentos: propostas.documentos`** à cláusula `select`.
3.  Na mesma função, modifique a chamada ao `this.mapToDomain` para passar os dados dos documentos.
4.  Modifique o método `mapToDomain` para aceitar e mapear o campo `documentos` para o objeto de domínio `Proposal`.

**Fase 3: Modificação do Controller**
1.  Abra o arquivo `server/modules/proposal/presentation/proposalController.ts`.
2.  Localize o método `getById` (ou equivalente).
3.  Modifique o objeto DTO que é retornado como `res.json()` para incluir o campo `documentos: proposal.documentos`.

**Fase 4: Validação**
1.  Execute o protocolo 7-CHECK. Descreva como validaria que o endpoint `GET /api/propostas/:id` agora retorna o campo `documentos` com os dados corretos após as suas modificações.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** 90%
* **RISCOS IDENTIFICADOS:** **MÉDIO**. As modificações abrangem múltiplas camadas da arquitetura (Domínio, Repositório, Controller). Existe um risco de introduzir inconsistências de tipo ou quebrar o contrato com outras partes do sistema que consomem o agregado `Proposal` sem esperar pelo novo campo.
* **DECISÕES TÉCNICAS ASSUMIDAS:** Assumo que a coluna na tabela `propostas` se chama `documentos` e é do tipo `text[]` (array de strings) no PostgreSQL. Assumo que o frontend está preparado para receber um campo `documentos` no objeto da proposta.
* **VALIDAÇÃO PENDENTE:** O Orquestrador deverá realizar uma revisão de código cruzada em todos os ficheiros modificados para garantir a consistência da implementação e executar um teste de regressão para validar que nenhuma funcionalidade existente foi quebrada.
---