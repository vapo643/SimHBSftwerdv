### Pacote de Ativação de Missão (PAM) V1.0 - Operação "Velocidade de Escape" / Missão 3: Otimização de Connection Pooling

* **Sumário da Missão (O Quê):** Auditar e otimizar a configuração de conexão da base de dados Supabase/PostgreSQL, implementando um *connection pool* robusto para gerir e reutilizar conexões de forma eficiente.
* **Intenção Estratégica (O Porquê):** Reduzir a latência de I/O da base de dados, que é um dos principais contribuintes para a nossa alta latência P95. Um *connection pool* elimina o *overhead* de estabelecer uma nova conexão para cada query, o que é crucial em ambientes de alta concorrência.
* **Modelo Mental (Como se Encaixa):** Você é um engenheiro de SRE especializado em otimização de base de dados. A sua tarefa é configurar a camada de acesso a dados para máxima eficiência e resiliência.

---
### **DOUTRINA DE EXECUÇÃO OBRIGATÓRIA: PEO V2.0**
* **MODO DE OPERAÇÃO:** **MODO_EXECUÇÃO**.
* **PERSONA:** **"Executor de Elite"**.
* **VALIDAÇÃO (7-CHECK ADAPTATIVO):** O risco desta missão é **ALTO**, pois afeta o coração da nossa conectividade de dados. Execute o **"7-CHECK FULL"** na sua validação final.
---

**IMPLEMENTAR (Plano de Otimização):**

**Passo 1: Auditar e Refatorar a Conexão com a Base de Dados**
1.1. Localize o ficheiro responsável pela inicialização do cliente PostgreSQL (provavelmente `server/lib/supabase.ts` ou um ficheiro de configuração de base de dados).
1.2. A nossa biblioteca `postgres` já suporta *pooling* por padrão. A sua tarefa é garantir que a configuração esteja otimizada. Modifique a instanciação do cliente para incluir parâmetros de *pooling* explícitos e robustos.
    ```typescript
    // Exemplo de configuração otimizada
    import postgres from 'postgres';
    
    const sql = postgres(process.env.DATABASE_URL!, {
      max: 20, // Número máximo de conexões no pool
      idle_timeout: 30, // Tempo em segundos para uma conexão inativa ser fechada
      connect_timeout: 10, // Tempo de espera para estabelecer uma conexão
      onnotice: () => {}, // Suprimir notices do PostgreSQL nos logs
    });
    ```

**Passo 2: Validação Final (Execução do 7-CHECK FULL)**
2.1. **(Check 1-3):** Apresente o código refatorado da configuração de conexão e execute `get_latest_lsp_diagnostics` para garantir zero erros.
2.2. **(Check 4):** Declare o seu nível de confiança (0-100%) na implementação.
2.3. **(Check 5):** Categorize quaisquer novos riscos descobertos (BAIXO/MÉDIO/ALTO/CRÍTICO).
2.4. **(Check 6):** Realize um teste funcional rápido (ex: um `curl` no endpoint `/api/propostas`) para validar que a conectividade com a base de dados permanece funcional após a alteração.
2.5. **(Check 7):** Documente a decisão técnica de usar um *pool* de 20 conexões como um padrão inicial para a nossa carga projetada.
2.6. **Relatório:** Gere o "Relatório de Execução V2 com Prova".

---
### **PROTOCOLO DE DIVULGAÇÃO TOTAL (PDT) V1.0 (MANDATÓRIO)**
Apresente a lista exaustiva de TODAS as suas descobertas, riscos e recomendações.