2° - Desenvolvedor Full-Stack V7.7- Orquestrador de Refinamento de IA
Gem personalizado

Mostrar raciocínio
Este é um diagnóstico crítico e um plano de ação para resolver a falha de autenticação no download de PDFs.

Comandante, este é um problema clássico e frustrante. A discrepância entre o funcionamento da autenticação em rotas normais (JSON) e a falha em rotas de download de ficheiros (PDF) aponta quase sempre para uma área específica de complexidade no desenvolvimento web moderno.

1. Diagnóstico: A Causa Raiz Provável
O culpado mais provável aqui é o CORS (Cross-Origin Resource Sharing).

Quando o seu frontend usa fetch para obter dados JSON, o navegador gere a troca de headers de forma relativamente simples. No entanto, quando você usa fetch para fazer download de um ficheiro (blob) e adiciona headers personalizados (como Authorization), o navegador impõe verificações CORS muito mais rigorosas.

O que provavelmente está a acontecer:

O navegador faz uma requisição "preflight" (OPTIONS) antes do GET real para verificar se o servidor permite a requisição com o header Authorization.

Se o seu backend (Express) não estiver configurado explicitamente para responder a esta requisição OPTIONS com o header Access-Control-Allow-Headers: Authorization, o navegador recusa-se a enviar a requisição GET real, ou envia-a sem o token.

O resultado é que o seu jwtAuthMiddleware nunca recebe o token, ou a requisição falha antes mesmo de chegar ao middleware, resultando num erro 401 (Unauthorized) ou num erro de CORS no frontend.

2. A Solução: Configuração Robusta de CORS e Logging Definitivo
Precisamos de garantir que o nosso backend esteja totalmente em conformidade com os requisitos de CORS para headers personalizados e melhorar o nosso logging para ter visibilidade absoluta do que o middleware está a receber.

3. Alternativa (Plano B): URLs Assinadas
Se a correção de CORS não funcionar devido a complexidades de infraestrutura (proxies, etc.), a abordagem padrão da indústria é usar URLs Assinadas. Em vez de transmitir o PDF através de uma rota protegida por JWT, a rota autenticada gera um link temporário e criptograficamente assinado para o download direto, que o frontend utiliza. No entanto, vamos primeiro resolver o problema da forma atual.

Aqui está o prompt em linguagem natural para o Agente Replit implementar as correções táticas.

PARA O AGENTE REPLIT: MISSÃO CRÍTICA - RESOLVER FALHA 401 NO DOWNLOAD DE PDF (CORS & LOGGING)

Olá Agente.

Estamos com um bloqueio crítico: o download de PDFs (boletos) está a falhar com erro 401, apesar do token JWT ser válido e funcionar nas outras rotas. Suspeito fortemente de um problema de configuração de CORS ou de falta de visibilidade no nosso middleware de autenticação.

Precisamos de uma abordagem em duas frentes para diagnosticar e corrigir isto definitivamente.

Frente 1: Visibilidade Total no Middleware de Autenticação

A primeira coisa é saber exatamente o que o middleware está a receber. Modifique o server/lib/jwt-auth-middleware.ts para adicionar logs detalhados.

Log da Rota: No início da função, registe a rota que está a ser acedida (ex: console.log('[JWT DEBUG] Rota acessada: ${req.path}')).

Log da Presença do Header: Registe se o req.headers.authorization existe (ex: console.log('[JWT DEBUG] Header Auth presente: ${!!authHeader}')).

Log do Erro Exato do Supabase: Na secção onde verifica if (error || !user), é CRUCIAL registar o erro exato retornado pelo Supabase (ex: console.error('[JWT DEBUG] Falha na validação Supabase. Erro: ${error?.message}')).

Frente 2: Fortalecer a Configuração de CORS

O problema mais provável é que o navegador esteja a bloquear o header Authorization devido a uma política de CORS incompleta. Precisamos garantir que o nosso servidor Express esteja a permitir explicitamente este header.

Localizar a Configuração Global do Express: Encontre onde o middleware cors está a ser configurado (geralmente server/index.ts ou server/app.ts).

Permitir Explicitamente Authorization: Garanta que a configuração do cors() inclua explicitamente Authorization na lista de allowedHeaders.

Exemplo de configuração robusta (ajuste a origin conforme necessário):

TypeScript

app.use(cors({
  origin: ['http://localhost:3000', 'URL_DO_SEU_FRONTEND_PROD'], // Ajuste
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'x-request-id'], // <-- CRUCIAL
}));
Gestão de Preflight: Garanta que as requisições OPTIONS (preflight) estão a ser geridas corretamente. Muitas vezes, adicionar app.options('*', cors()) antes das outras rotas ajuda.

Execute estas duas frentes imediatamente. Isto deve resolver o problema de CORS ou dar-nos o log exato do porquê o Supabase está a rejeitar o token nesta rota específica.