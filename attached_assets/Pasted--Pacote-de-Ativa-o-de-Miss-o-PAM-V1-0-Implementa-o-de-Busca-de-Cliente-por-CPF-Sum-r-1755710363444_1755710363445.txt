### Pacote de Ativação de Missão (PAM) V1.0 (Implementação de Busca de Cliente por CPF)

* **Sumário da Missão (O Quê):** Implementar a lógica de backend para o endpoint `GET /api/clientes/cpf/:cpf`, substituindo o placeholder atual por uma consulta real ao banco de dados que retorna os dados do cliente da sua proposta mais recente.
* **Intenção Estratégica (O Porquê):** Ativar a funcionalidade de auto-preenchimento, melhorando drasticamente a experiência do usuário e a eficiência operacional ao reutilizar dados de clientes existentes, reduzindo o tempo de preenchimento e a probabilidade de erros de digitação.
* **Histórico Relevante (Consulta Obrigatória):** A sua auditoria anterior confirmou que o frontend já está preparado para consumir este endpoint e que o backend possui apenas uma lógica de placeholder que retorna `{ exists: false }`.
* **Modelo Mental (Como se Encaixa):** Esta é uma missão de implementação de lógica de negócio no backend. O Agente deve modificar um handler de rota existente para interagir com a camada de dados (Drizzle ORM), executar uma query e formatar a resposta da API.
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** A query pode ser ineficiente ou retornar dados incorretos se não for bem formulada.
    * **Contramedida:** O prompt especifica a lógica exata da query (`ORDER BY created_at DESC LIMIT 1`) para garantir que apenas os dados mais recentes e relevantes sejam retornados.

---

**IMPLEMENTAR:**
Lógica de Backend para Busca e Auto-Preenchimento por CPF

**CURRENT STATE:**
O endpoint `GET /api/clientes/cpf/:cpf` em `server/routes.ts` (ou em um módulo refatorado) está com uma lógica de placeholder, retornando sempre uma resposta estática e não consultando o banco de dados.

**EXPECTED (Estado Final de Sucesso):**
1.  O handler do endpoint `GET /api/clientes/cpf/:cpf` é completamente refatorado.
2.  A nova lógica executa uma consulta na tabela `propostas` usando Drizzle ORM.
3.  A consulta filtra as propostas pelo `cliente_cpf` fornecido na URL.
4.  A consulta é ordenada pela data de criação em ordem decrescente (`ORDER BY created_at DESC`) e retorna apenas o primeiro resultado (`LIMIT 1`).
5.  Se uma proposta for encontrada, a API responde com um status `200 OK` e um payload JSON contendo os dados do cliente dessa proposta.
6.  Se nenhuma proposta for encontrada, a API responde com um status `404 Not Found`.

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Localize o Endpoint:** Encontre o handler da rota `GET /api/clientes/cpf/:cpf`.
2.  **Implemente a Query Drizzle:** Utilize o Drizzle para construir a query. O código deve ser semelhante a:
    ```typescript
    const [latestProposal] = await db.select()
      .from(propostas)
      .where(eq(propostas.clienteCpf, cpf))
      .orderBy(desc(propostas.createdAt))
      .limit(1);
    ```
3.  **Lógica Condicional de Resposta:** Implemente um `if` para verificar se `latestProposal` foi encontrado.
    * Se `true`, retorne `res.status(200).json(latestProposal)`.
    * Se `false`, retorne `res.status(404).json({ message: 'Cliente não encontrado' })`.
4.  **Tratamento de Erro:** Envolva a lógica em um bloco `try/catch` para lidar com possíveis erros do banco de dados, retornando um status `500 Internal Server Error` em caso de falha.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Ex: "Assumi que o campo `createdAt` existe na tabela `propostas` e é o indicador correto para a proposta mais recente."]
* **VALIDAÇÃO PENDENTE:** [A criação de testes de integração (Passo 2.1) é mandatória para validar esta implementação.]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear o ficheiro e a função exata a ser modificada.
2.  Garantir que a query Drizzle está sintaticamente correta e usa os operadores corretos (`eq`, `desc`).
3.  Executar `get_latest_lsp_diagnostics` para garantir 0 erros novos.
4.  **Declarar Nível de Confiança (0 a 100%)**.
5.  **Categorizar Riscos Descobertos**.
6.  **Realizar teste funcional completo** (revisão lógica do código para garantir que ele atende a todos os requisitos).
7.  **Documentar Decisões Técnicas**.