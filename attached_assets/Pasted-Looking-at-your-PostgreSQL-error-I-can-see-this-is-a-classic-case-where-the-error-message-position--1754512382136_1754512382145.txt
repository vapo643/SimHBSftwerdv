Looking at your PostgreSQL error, I can see this is a classic case where the error message position gives us the exact clue we need to solve this mystery. Let me walk you through the detective work step by step.

Understanding the Error Position
The key detail in your error is position: '46'. This tells us exactly where PostgreSQL found the problematic column reference - at character position 46 in the SQL query. This isn't a random reference hiding somewhere in your codebase; it's happening in a specific query that's being executed.

The Hidden Culprit: Complex Queries and Subqueries
Even though you've removed all the obvious orderBy(desc(interCollections.createdAt)) references, the issue likely stems from one of these common scenarios:

1. Drizzle's Internal Query Generation When you do a select() without specifying columns, Drizzle generates SQL that includes ALL columns from the schema. If there's any mismatch between your schema definition and the actual database structure, this can cause the error.

2. Hidden Joins or Subqueries Looking at your endpoint, you mentioned there might be additional code after the boletos query. Often, these errors occur in complex queries with joins or subqueries that aren't immediately obvious.

Systematic Debugging Approach
Let me give you a step-by-step debugging strategy to find the exact source:

Step 1: Enable Detailed SQL Logging First, let's see exactly what SQL is being generated. Add this to your endpoint temporarily:

typescript
// At the top of your pagamentos.ts file
import { sql } from 'drizzle-orm';

// In your endpoint, replace the boletos query with this debug version:
console.log('[DEBUG] About to execute boletos query...');
try {
  const query = db
    .select()
    .from(interCollections)
    .where(eq(interCollections.propostaId, id));
  
  // This will show us the exact SQL being generated
  console.log('[DEBUG] Generated SQL:', query.toSQL());
  
  boletos = await query;
  console.log('[DEBUG] Boletos found:', boletos.length);
} catch (boletoError) {
  console.error('[DEBUG] SQL Error details:', {
    message: boletoError.message,
    position: boletoError.position,
    code: boletoError.code
  });
  throw boletoError; // Re-throw to see full context
}
Step 2: Test with Explicit Column Selection Instead of select(), try selecting only the columns you actually need:

typescript
boletos = await db
  .select({
    id: interCollections.id,
    propostaId: interCollections.propostaId,
    codigoSolicitacao: interCollections.codigoSolicitacao,
    valorNominal: interCollections.valorNominal,
    situacao: interCollections.situacao,
    dataVencimento: interCollections.dataVencimento
    // Add only the fields you actually need in the response
  })
  .from(interCollections)
  .where(eq(interCollections.propostaId, id));
This approach bypasses any potential schema mapping issues by being explicit about what you want.

The Most Likely Root Cause
Based on your error pattern, I suspect the issue is in the part of your endpoint code you marked as "Resposta continua..." There's probably additional code that does one of these:

A join with another table that references created_at
A subquery or CTE that includes created_at
An aggregation or window function that tries to use created_at
A conditional query that sometimes adds created_at based on parameters
Quick Fix Strategy
While you're debugging, implement this temporary workaround to get your production system working:

typescript
// Wrap the entire endpoint in more granular error handling
router.get("/:id/detalhes-completos", jwtAuthMiddleware, async (req: AuthenticatedRequest, res) => {
  try {
    const { id } = req.params;
    console.log(`[PAGAMENTOS] Buscando detalhes completos da proposta: ${id}`);
    
    // Step 1: Get proposta (this works)
    const [propostaData] = await db
      .select()
      .from(propostas)
      .where(eq(propostas.id, id))
      .limit(1);
    
    if (!propostaData) {
      return res.status(404).json({ error: "Proposta n√£o encontrada" });
    }

    // Step 2: Get boletos with minimal data first
    let boletos: any[] = [];
    try {
      boletos = await db
        .select({
          id: interCollections.id,
          valorNominal: interCollections.valorNominal,
          situacao: interCollections.situacao,
          dataVencimento: interCollections.dataVencimento
        })
        .from(interCollections)
        .where(eq(interCollections.propostaId, id));
    } catch (boletoError) {
      console.error('[BOLETOS ERROR]:', boletoError);
      // Continue without boletos for now
      boletos = [];
    }

    // Return minimal response to unblock your production
    return res.json({
      proposta: propostaData,
      boletos: boletos,
      // Add other required fields with default values
    });

  } catch (error) {
    console.error('[PAGAMENTOS] Erro completo:', error);
    return res.status(500).json({ 
      error: "Erro interno do servidor",
      details: error.message 
    });
  }
});
Finding the Complete Solution
The complete solution requires you to share the rest of your endpoint code (the "Resposta continua..." part). That's where the created_at reference is hiding. It's likely in:

Additional queries that fetch related data
Aggregation queries for totals or summaries
Audit log insertions
Complex joins for enriching the response
Once you run the debugging steps above and share the complete endpoint code, we can pinpoint the exact query causing the issue and fix it permanently.

Would you like to try the debugging steps first, or can you share the complete endpoint code so we can identify the hidden created_at reference directly?