### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Injetar a lógica de persistência de dados faltante na função `updateStatusWithContext` para garantir que as observações de comunicação sejam corretamente salvas na tabela `observacoes_cobranca` durante a mudança de status de uma proposta.

* **Intenção Estratégica (O Porquê):** O sistema está a sofrer de uma falha crítica de integridade de dados onde a comunicação vital entre analistas e atendentes não está a ser registada. Esta correção é mandatória para restaurar a auditabilidade e a funcionalidade do fluxo de análise de propostas.

* **Histórico Relevante (Consulta Obrigatória):** Uma auditoria forense anterior (`Operação Tinta Seca`) já confirmou que a função `updateStatusWithContext` no arquivo `server/lib/status-context-helper.ts` é o ponto exato da falha. A função recebe os dados da observação, mas não os persiste na tabela `observacoes_cobranca`.

---

**IMPLEMENTAR:**
Correção da Pipeline de Persistência do Histórico de Comunicação.

**CURRENT STATE:**
A função `updateStatusWithContext` no arquivo `server/lib/status-context-helper.ts` executa uma transação de banco de dados que atualiza o status da proposta e cria logs, mas omite o `INSERT` na tabela `observacoes_cobranca`.

**EXPECTED (Estado Final de Sucesso):**
1.  O arquivo `server/lib/status-context-helper.ts` deve ser modificado.
2.  Dentro da transação `db.transaction(async (tx) => { ... })` da função `updateStatusWithContext`, uma nova operação de escrita deve ser adicionada.
3.  Esta operação deve inserir um novo registo na tabela `observacoesCobranca` utilizando os dados (`propostaId`, `userId`, `observacoes`, etc.) que já estão disponíveis no escopo da função.
4.  A inserção deve ser idempotente ou segura para garantir que não quebre em casos de reprocessamento.

**CONSTRAINTS (Roadmap de Implementação):**
1.  Abra o arquivo `server/lib/status-context-helper.ts`.
2.  Localize a função `updateStatusWithContext`.
3.  Dentro do bloco `db.transaction(async (tx) => { ... })`, após a lógica existente de `tx.update(propostas)` e `tx.insert(statusContextuais)`, adicione a seguinte lógica de inserção:

    ```typescript
    if (observacoes && typeof observacoes === 'string' && observacoes.trim() !== '') {
      console.log(`[Status FSM] Persistindo observação na tabela 'observacoes_cobranca' para a proposta ${propostaId}`);
      await tx.insert(observacoesCobranca).values({
        propostaId: propostaId,
        userId: userId || 'sistemico', // Fallback para 'sistemico' se userId for nulo
        userName: userName || 'Sistema', // Fallback para 'Sistema'
        observacao: observacoes,
        tipoContato: 'INTERNO', // Define um tipo padrão para estas observações
        createdAt: new Date(),
      });
    }
    ```
4.  Certifique-se de que `observacoesCobranca` está corretamente importado do `@shared/schema`.
5.  Execute o protocolo 7-CHECK, descrevendo como você validaria a correção. O teste ideal envolveria mudar o status de uma proposta com uma observação e depois verificar a tabela `observacoes_cobranca` com uma query SQL.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO e uma breve descrição]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Listar decisões, ex: "Assumido que o `userName` está disponível no escopo da função; caso contrário, 'Sistema' é um fallback aceitável."]
* **VALIDAÇÃO PENDENTE:** [Listar ações que o Orquestrador deve validar, ex: "Validar visualmente a funcionalidade e auditar o código final de `status-context-helper.ts`."]
---