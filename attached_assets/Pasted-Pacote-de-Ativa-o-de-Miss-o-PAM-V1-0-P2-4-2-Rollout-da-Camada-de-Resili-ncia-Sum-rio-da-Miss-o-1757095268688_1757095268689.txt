Pacote de Ativação de Missão (PAM) V1.0 - P2.4.2: Rollout da Camada de Resiliência
Sumário da Missão (O Quê): Executar a refatoração completa de todos os métodos restantes no proposalController.ts para que utilizem o middleware de tratamento de erros global (errorHandler), eliminando todos os blocos try/catch inconsistentes e verbosos.

Intenção Estratégica (O Porquê): Esta é a continuação da Ação P2.4. Na missão anterior (P2.4.1), estabelecemos a "rede de segurança" do errorHandler e realizamos uma refatoração piloto. Agora, vamos aplicar este padrão de resiliência em toda a extensão do controller mais crítico do sistema. Isto irá padronizar 100% do tratamento de erros, aumentar a observabilidade e simplificar drasticamente a manutenção do código.

Histórico Relevante (Consulta Obrigatória): A execução da missão P2.4.1 provou a eficácia do middleware server/middleware/errorHandler.ts e estabeleceu o padrão de refatoração no método getById do proposalController.ts. Esta missão irá aplicar esse mesmo padrão a todos os outros métodos.

Modelo Mental (Como se Encaixa): Se a missão anterior instalou a "caixa preta" no avião, esta missão consiste em conectar todos os sensores dos motores a ela. Vamos percorrer cada método do proposalController, remover a sua lógica de alarme local e inconsistente (console.error), e conectá-lo ao sistema de alerta centralizado (next(error)), garantindo que nenhuma falha passe despercebida.

Riscos Antecipados e Contramedidas:

Risco (BAIXO): A refatoração, se feita incorretamente, poderia fazer com que um erro não fosse passado para a função next, resultando num "request pendurado" (hanging request).

Contramedida: O padrão de refatoração é simples e repetitivo. A validação com testes de ponta a ponta no final da Fase P2 garantirá que todos os fluxos de erro resultem numa resposta HTTP correta.

IMPLEMENTAR: Rollout Completo do Padrão de Error Handling no proposalController

CONTEXT: O proposalController.ts foi parcialmente refatorado para usar o novo middleware de erro global. No entanto, a maioria dos seus métodos ainda contém a lógica de tratamento de erro antiga, verbosa e inconsistente. Precisamos completar a refatoração para garantir 100% de conformidade com o novo padrão de resiliência.

CURRENT STATE: Uma mistura de padrões de tratamento de erro dentro do mesmo arquivo, com apenas o método getById utilizando o errorHandler global.

EXPECTED (Estado Final de Sucesso):

TODOS os métodos dentro do arquivo server/modules/proposal/presentation/proposalController.ts que contêm um bloco try/catch para erros de servidor devem ser refatorados.

O bloco catch em cada um destes métodos deve ser simplificado para uma única linha: next(error);.

Toda a lógica de console.error e res.status(500).json(...) dentro dos catch deve ser eliminada do controller.

O sistema deve compilar com ZERO erros de LSP e permanecer 100% funcional.

CONSTRAINTS (Roadmap de Implementação Faseado):

Fase 1: Auditoria e Mapeamento de Alvos

Abra server/modules/proposal/presentation/proposalController.ts.

Identifique todos os métodos (exceto getById, que já foi refatorado) que possuem um bloco try/catch com a lógica de erro antiga.

Fase 2: Refatoração Sistemática

Para cada método identificado, aplique o seguinte padrão de refatoração:

Localize o bloco catch (error: any) { ... }.

Delete todo o conteúdo dentro do bloco.

Substitua pelo novo padrão de delegação:

TypeScript

catch (error: any) {
  next(error);
}
Fase 3: Validação Final

Após refatorar todos os métodos-alvo, execute get_latest_lsp_diagnostics. O resultado DEVE ser ZERO erros.

Reinicie o servidor para garantir que a aplicação continua a iniciar corretamente.

Apresente um relatório de execução final, confirmando que o proposalController está agora 100% aderente ao padrão de tratamento de erros centralizado.

DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):

CONFIANÇA NA IMPLEMENTAÇÃO: [Preencher com a porcentagem de 0 a 100%]

RISCOS IDENTIFICADOS: [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO]

DECISÕES TÉCNICAS ASSUMIDAS: [Ex: "Assumi que todos os erros capturados nos try/catch existentes são, de facto, erros de servidor (500) e podem ser delegados ao errorHandler global."]

VALIDAÇÃO PENDENTE: [Ex: "A refatoração de outros controllers da aplicação seguirá como uma missão separada para manter o escopo desta tarefa focado e controlado."]