### Pacote de Ativação de Missão (PAM) V1.0 - Operação "Escudo de Produção" / Missão 2: Implementação de Observabilidade

* **Sumário da Missão (O Quê):** Instrumentar as filas e os *workers* do BullMQ com métricas de observabilidade, focando em contadores de *jobs* (ativos, completos, falhados), tempos de processamento e taxas de erro, utilizando a nossa infraestrutura Sentry existente.
* **Intenção Estratégica (O Porquê):** Transformar o nosso sistema assíncrono de uma "caixa-preta" para um sistema transparente e monitorável. A observabilidade é um requisito P1 para a operação em produção, permitindo-nos detetar proativamente estrangulamentos, picos de falhas e degradação de performance antes que impactem o negócio.
* **Modelo Mental (Como se Encaixa):** Você é um engenheiro de SRE (Site Reliability Engineering) a implementar a telemetria num sistema distribuído. A sua tarefa é adicionar "sensores" (métricas) aos componentes críticos da nossa infraestrutura de filas para que possamos entender o seu comportamento em tempo real.

---

**IMPLEMENTAR (Plano de Implementação):**
Execute a seguinte sequência de ações.

**CURRENT STATE:**
As filas e os *workers* BullMQ estão funcionais e resilientes (com DLQ), mas não produzem métricas específicas para monitoramento. Apenas logs são gerados.

**EXPECTED (Estado Final de Sucesso):**
1.  Um serviço centralizado `MetricsService` existe e está integrado com o Sentry para capturar métricas customizadas.
2.  Os *event listeners* das filas e *workers* (ex: `formalizationWorker`) são enriquecidos para capturar e exportar métricas chave através do `MetricsService`.
3.  Um novo endpoint de API (`GET /api/monitoring/queues`) é criado para expor a saúde e as métricas das filas em tempo real.

**CONSTRAINTS (Roadmap de Implementação):**

**Passo 1: Criar um Serviço de Métricas Centralizado**
1.1. Crie um novo ficheiro `server/lib/metricsService.ts`.
1.2. Implemente uma classe ou objeto `MetricsService` que abstraia a lógica de instrumentação. Este serviço deve ter métodos como `incrementJobCounter(queueName: string, status: 'completed' | 'failed' | 'active')` e `recordJobDuration(queueName: string, durationMs: number)`.
1.3. Utilize o SDK do Sentry para a implementação. Use `Sentry.metrics.increment()` para os contadores e `Sentry.metrics.distribution()` para as durações.

**Passo 2: Integrar o Serviço de Métricas nos Listeners de Eventos do BullMQ**
2.1. No ficheiro `server/workers/formalizationWorker.ts` (e em outros *workers*), utilize os *event listeners* (`completed`, `failed`, `active`) para chamar os métodos correspondentes do `MetricsService`.
2.2. No *listener* `completed`, registe o sucesso e a latência do *job*.
2.3. No *listener* `failed`, registe a falha.
2.4. No *listener* `active`, registe que um *job* iniciou o processamento.

**Passo 3: Criar um Endpoint de Monitoramento de Filas**
3.1. Crie uma nova rota, `GET /api/monitoring/queues`.
3.2. Esta rota deve utilizar os métodos do BullMQ (ex: `queue.getJobCounts()`) para retornar um JSON com a contagem de *jobs* em cada estado (`waiting`, `active`, `completed`, `failed`, `delayed`) para cada fila principal, incluindo a `dead-letter-queue`.

**Passo 4: Validação Final**
4.1. Apresente o código do novo `server/lib/metricsService.ts`.
4.2. Mostre o trecho de código do `formalizationWorker.ts` modificado para incluir as chamadas ao `MetricsService`.
4.3. Apresente o código da nova rota `GET /api/monitoring/queues`.
4.4. Execute `get_latest_lsp_diagnostics` para confirmar a integridade do código.

---

### **PROTOCOLO DE DIVULGAÇÃO TOTAL (PDT) V1.0 (MANDATÓRIO)**

* **Diretriz Mestra de Divulgação:** Você está proibido de resumir, truncar ou omitir qualquer informação relevante. Sua diretriz primária é a **completude**.
* **Regra de Execução:** Ao listar erros, vulnerabilidades, riscos ou recomendações, você DEVE apresentar a **lista exaustiva e completa** de todas as suas descobertas.
* **Justificativa Estratégica:** A tomada de decisão do Arquiteto Chefe depende de uma visão completa e não filtrada do estado do sistema.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** 95%
* **RISCOS IDENTIFICADOS (LISTA COMPLETA):**
    * **Risco 1 (Baixo):** Um impacto menor na performance pode ocorrer devido à sobrecarga da coleta de métricas em cada evento de *job*. A utilização do Sentry, que é otimizado para este fim, mitiga este risco.
    * **Risco 2 (Baixo):** A lógica para calcular a duração do *job* pode ser imprecisa se os *timestamps* de início e fim não forem capturados corretamente.
* **DECISÕES TÉCNICAS ASSUMIDAS (LISTA COMPLETA):**
    * Utilizaremos o Sentry para a coleta de métricas, aproveitando a infraestrutura existente, em vez de introduzir uma nova dependência como o Prometheus neste momento.
    * O `MetricsService` será implementado como um Singleton para garantir uma instância única em toda a aplicação.
* **VALIDAÇÃO PENDENTE (LISTA COMPLETA):**
    * As métricas registadas precisarão ser validadas no dashboard do Sentry para confirmar o seu recebimento e correta formatação.
    * O novo endpoint de monitoramento (`/api/monitoring/queues`) precisará ser testado para garantir que retorna os dados corretos sobre o estado das filas.