### **Pacote de Ativação de Missão (PAM) V5.1 - CONF-001 (Reparar Idempotência de Pagamentos)**

**[DIRETRIZ MESTRA DE DIVULGAÇÃO - PDT V2.0 ATIVADA]**
*Sua resposta deve ser exaustiva. Reporte a realidade técnica sem omissão. A transparência radical é mandatória.*

* **Sumário da Missão (O Quê):** Refatorar o serviço de integração com o Banco Inter (provavelmente `interBankService.ts` ou `pagamentoService.ts`) para garantir a idempotência no nível da aplicação, prevenindo a criação de jobs de pagamento duplicados.
* **Intenção Estratégica (O Porquê):** Eliminar o risco de cobranças duplicadas, que representa uma falha financeira e de reputação catastrófica. A idempotência no nível do BullMQ (`jobId`) é uma camada de defesa, mas a verdadeira segurança de nível bancário exige uma verificação explícita na lógica de negócio.
* **Histórico Relevante (Consulta Obrigatória):** Sua auditoria (`GL-001`) identificou que, embora um identificador único (`seuNumero`) seja usado, não há uma verificação de duplicatas antes de enfileirar o job.

---

**IMPLEMENTAR:**
User Story GL-001.1: Implementar Verificação de Idempotência na Criação de Pagamentos

**CONTEXT:**
Nossa auditoria de negócio revelou uma falha crítica: o serviço que cria boletos através da API do Banco Inter não verifica se um boleto para a mesma proposta e parcela já foi solicitado. Isso abre uma brecha para a criação de jobs duplicados na nossa fila de pagamentos, o que pode levar a cobranças duplicadas para o cliente.

**CURRENT STATE:**
O serviço de pagamentos (ex: `interBankService.ts`) recebe uma requisição para criar uma cobrança e imediatamente adiciona um job à `paymentsQueue` do BullMQ, usando `seuNumero` como um identificador, mas sem uma verificação prévia de existência.

**EXPECTED (Estado Final de Sucesso):**
1.  **Lógica de Verificação Implementada:** Antes de adicionar um novo job à `paymentsQueue`, o serviço deve primeiro consultar o banco de dados (a tabela `inter_collections` ou similar) para verificar se já existe um registro com o mesmo `seuNumero` (ou outra chave de idempotência única).
2.  **Prevenção de Duplicatas:**
    * Se **não** houver um registro existente, o serviço deve prosseguir normalmente: criar o registro no banco de dados com um status inicial (ex: `PENDING_QUEUE`) e adicionar o job à fila.
    * Se um registro **já existir**, o serviço deve **ignorar** a criação de um novo job e retornar uma resposta indicando que a solicitação já está em processamento, prevenindo a duplicata.
3.  **Prova de Funcionamento:** Um teste de integração deve ser criado ou modificado para provar que a lógica funciona:
    * A primeira chamada à API com dados específicos deve resultar em um novo job na fila.
    * Uma segunda chamada imediata com os **mesmos dados** **não deve** criar um segundo job, e o tamanho da fila deve permanecer o mesmo.

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Localizar Serviço Alvo:** Identifique o arquivo de serviço (`interBankService.ts`, `pagamentoService.ts`, etc.) e a função (`createPayment`, `gerarCobranca`, etc.) responsável por iniciar o processo de pagamento.
2.  **Refatorar Lógica:** Modifique a função identificada. Introduza uma etapa de verificação (`SELECT ... WHERE seuNumero = ?`) antes da chamada para `paymentsQueue.add()`.
3.  **Implementar Fluxo Condicional:** Adicione a lógica `if/else` para tratar os casos de registro existente vs. não existente.
4.  **Criar/Modificar Teste de Integração:** Crie um novo teste ou modifique um existente para simular o cenário de chamada dupla e validar que apenas um job é criado.
5.  **Executar e Validar:** Execute o teste e forneça o output que comprova a prevenção da duplicata.
6.  **Verificação Final:** Execute o protocolo `7-CHECK FULL`.