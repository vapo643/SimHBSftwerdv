// ============================================
// ARQUIVO 1: server/services/statusFsmService.ts
// ============================================

import { db } from '../lib/db';
import { propostas, historicoPropostas } from '../../shared/schema';
import { eq, sql } from 'drizzle-orm';

// Mapeamento completo de transi√ß√µes permitidas
const STATUS_TRANSITIONS = {
  'RASCUNHO': ['EM_ANALISE', 'CANCELADA'],
  'EM_ANALISE': ['APROVADA', 'REPROVADA', 'PENDENTE_DOCUMENTACAO', 'CANCELADA'],
  'PENDENTE_DOCUMENTACAO': ['EM_ANALISE', 'CANCELADA'],
  'APROVADA': ['CCB_GERADA', 'CANCELADA'],
  'CCB_GERADA': ['AGUARDANDO_ASSINATURA', 'ASSINATURA_CONCLUIDA', 'CANCELADA'],
  'AGUARDANDO_ASSINATURA': ['ASSINATURA_CONCLUIDA', 'CCB_GERADA', 'CANCELADA'],
  'ASSINATURA_CONCLUIDA': ['CONCLUIDA', 'CANCELADA'],
  'CONCLUIDA': ['ARQUIVADA'],
  'REPROVADA': ['ARQUIVADA'],
  'CANCELADA': ['ARQUIVADA'],
  'ARQUIVADA': [] // Estado final
};

// Normaliza√ß√£o de status para evitar problemas de casing
function normalizeStatus(status: string): string {
  return status.toUpperCase().replace(/-/g, '_');
}

export class StatusFSMService {
  private readonly maxRetries = 3;
  private readonly lockTimeout = 5000; // 5 segundos

  async processStatusTransition(
    propostaId: string,
    newStatus: string,
    userId: string,
    metadata?: Record<string, any>
  ): Promise<{ success: boolean; data?: any; error?: string }> {
    console.log(`[FSM] üöÄ Iniciando transi√ß√£o para proposta ${propostaId}`);
    console.log(`[FSM] üìä Novo status desejado: ${newStatus}`);

    // Normaliza o status para evitar problemas de casing
    const normalizedNewStatus = normalizeStatus(newStatus);
    
    // Retry logic com exponential backoff
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        // Usa transa√ß√£o com lock pessimista
        const result = await db.transaction(async (tx) => {
          // 1. Obt√©m proposta com lock FOR UPDATE
          const [proposta] = await tx
            .select()
            .from(propostas)
            .where(eq(propostas.id, propostaId))
            .for('update')
            .execute();

          if (!proposta) {
            throw new Error(`Proposta ${propostaId} n√£o encontrada no banco de dados`);
          }

          const currentStatus = normalizeStatus(proposta.status);
          console.log(`[FSM] üìç Status atual: ${currentStatus}`);

          // 2. Valida transi√ß√£o
          if (currentStatus === normalizedNewStatus) {
            console.log(`[FSM] ‚úÖ Status j√° est√° em ${normalizedNewStatus}, nada a fazer`);
            return { success: true, data: proposta, noChange: true };
          }

          const allowedTransitions = STATUS_TRANSITIONS[currentStatus] || [];
          if (!allowedTransitions.includes(normalizedNewStatus)) {
            throw new Error(
              `Transi√ß√£o n√£o permitida: ${currentStatus} ‚Üí ${normalizedNewStatus}. ` +
              `Transi√ß√µes permitidas: ${allowedTransitions.join(', ')}`
            );
          }

          // 3. Executa hooks pr√©-transi√ß√£o
          await this.executePreTransitionHooks(currentStatus, normalizedNewStatus, proposta, metadata);

          // 4. Atualiza status com timestamp
          const updatedAt = new Date();
          const [updatedProposta] = await tx
            .update(propostas)
            .set({
              status: normalizedNewStatus,
              updatedAt,
              updatedBy: userId
            })
            .where(eq(propostas.id, propostaId))
            .returning();

          // 5. Registra no hist√≥rico
          await tx.insert(historicoPropostas).values({
            id: crypto.randomUUID(),
            propostaId,
            statusAnterior: currentStatus,
            statusNovo: normalizedNewStatus,
            usuarioId: userId,
            createdAt: updatedAt,
            metadata: JSON.stringify({
              ...metadata,
              transitionTimestamp: updatedAt.toISOString(),
              attempt: attempt + 1
            })
          });

          // 6. Executa hooks p√≥s-transi√ß√£o
          await this.executePostTransitionHooks(
            currentStatus, 
            normalizedNewStatus, 
            updatedProposta, 
            metadata
          );

          console.log(`[FSM] ‚úÖ Transi√ß√£o conclu√≠da: ${currentStatus} ‚Üí ${normalizedNewStatus}`);
          return { success: true, data: updatedProposta };
        });

        // Se chegou aqui, transa√ß√£o foi bem-sucedida
        return result;

      } catch (error) {
        console.error(`[FSM] ‚ùå Tentativa ${attempt + 1} falhou:`, error);
        
        if (attempt === this.maxRetries - 1) {
          // √öltima tentativa falhou
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Erro desconhecido'
          };
        }

        // Aguarda antes de tentar novamente (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }

    return {
      success: false,
      error: 'M√°ximo de tentativas excedido'
    };
  }

  private async executePreTransitionHooks(
    fromStatus: string,
    toStatus: string,
    proposta: any,
    metadata?: any
  ): Promise<void> {
    // Valida√ß√µes espec√≠ficas por transi√ß√£o
    
    if (toStatus === 'CCB_GERADA') {
      // Valida se todos os documentos necess√°rios foram enviados
      if (!proposta.documentosCompletos) {
        throw new Error('Documenta√ß√£o incompleta para gerar CCB');
      }
    }

    if (toStatus === 'ASSINATURA_CONCLUIDA') {
      // Valida se existe documento na ClickSign
      if (!metadata?.clicksignDocumentId && !proposta.clicksignDocumentId) {
        throw new Error('Documento n√£o encontrado na ClickSign');
      }
    }

    if (toStatus === 'CONCLUIDA') {
      // Valida se assinatura foi conclu√≠da
      if (fromStatus !== 'ASSINATURA_CONCLUIDA') {
        throw new Error('Proposta precisa ter assinatura conclu√≠da antes de ser marcada como conclu√≠da');
      }
    }
  }

  private async executePostTransitionHooks(
    fromStatus: string,
    toStatus: string,
    proposta: any,
    metadata?: any
  ): Promise<void> {
    // A√ß√µes ap√≥s transi√ß√£o bem-sucedida
    
    if (toStatus === 'ASSINATURA_CONCLUIDA') {
      // Trigger integra√ß√£o com Banco Inter
      await this.triggerInterBankIntegration(proposta.id);
    }

    if (toStatus === 'CONCLUIDA') {
      // Envia notifica√ß√µes
      await this.sendCompletionNotifications(proposta);
    }

    if (toStatus === 'CANCELADA' || toStatus === 'REPROVADA') {
      // Limpa recursos alocados
      await this.cleanupProposalResources(proposta.id);
    }
  }

  private async triggerInterBankIntegration(propostaId: string): Promise<void> {
    try {
      console.log(`[FSM] üè¶ Triggering Inter Bank integration for ${propostaId}`);
      // Implementa√ß√£o da integra√ß√£o com Banco Inter
      // Este √© um placeholder - implemente conforme sua l√≥gica
    } catch (error) {
      console.error('[FSM] ‚ùå Inter Bank integration failed:', error);
      // N√£o falha a transa√ß√£o, mas registra o erro
    }
  }

  private async sendCompletionNotifications(proposta: any): Promise<void> {
    try {
      console.log(`[FSM] üìß Sending completion notifications for ${proposta.id}`);
      // Implementa√ß√£o de notifica√ß√µes
    } catch (error) {
      console.error('[FSM] ‚ùå Notification sending failed:', error);
    }
  }

  private async cleanupProposalResources(propostaId: string): Promise<void> {
    try {
      console.log(`[FSM] üßπ Cleaning up resources for ${propostaId}`);
      // Limpa arquivos tempor√°rios, cancela jobs pendentes, etc.
    } catch (error) {
      console.error('[FSM] ‚ùå Resource cleanup failed:', error);
    }
  }
}

// ============================================
// ARQUIVO 2: server/routes.ts (Rotas corrigidas)
// ============================================

// ROTA: Marcar como conclu√≠da
app.put('/api/propostas/:id/marcar-concluida', authenticateUser, async (req, res) => {
  const propostaId = req.params.id; // Mant√©m como string!
  const userId = req.user?.id;
  
  console.log(`[ROUTE] PUT /marcar-concluida - Proposta: ${propostaId}, User: ${userId}`);
  
  try {
    // Valida UUID
    if (!propostaId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
      return res.status(400).json({ 
        error: 'ID de proposta inv√°lido',
        receivedId: propostaId 
      });
    }

    const fsmService = new StatusFSMService();
    const result = await fsmService.processStatusTransition(
      propostaId,
      'CONCLUIDA',
      userId,
      {
        source: 'MANUAL_COMPLETION',
        timestamp: new Date().toISOString(),
        ...req.body
      }
    );

    if (!result.success) {
      console.error('[ROUTE] FSM transition failed:', result.error);
      return res.status(400).json({ 
        error: result.error,
        details: 'Transi√ß√£o de status falhou'
      });
    }

    // Se n√£o houve mudan√ßa (j√° estava conclu√≠da)
    if (result.noChange) {
      return res.status(200).json({
        message: 'Proposta j√° estava conclu√≠da',
        data: result.data
      });
    }

    console.log('[ROUTE] ‚úÖ Proposta marcada como conclu√≠da com sucesso');
    res.json({
      success: true,
      data: result.data,
      message: 'Proposta marcada como conclu√≠da'
    });

  } catch (error) {
    console.error('[ROUTE] ‚ùå Error in marcar-concluida:', error);
    res.status(500).json({ 
      error: 'Erro interno ao processar requisi√ß√£o',
      message: error instanceof Error ? error.message : 'Erro desconhecido'
    });
  }
});

// ROTA: Atualizar status gen√©rico
app.patch('/api/propostas/:id', authenticateUser, async (req, res) => {
  const propostaId = req.params.id; // Mant√©m como string!
  const { status, metadata } = req.body;
  const userId = req.user?.id;
  
  console.log(`[ROUTE] PATCH /propostas/${propostaId} - New status: ${status}`);
  
  try {
    // Valida√ß√µes
    if (!propostaId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
      return res.status(400).json({ error: 'ID de proposta inv√°lido' });
    }

    if (!status) {
      return res.status(400).json({ error: 'Status √© obrigat√≥rio' });
    }

    const fsmService = new StatusFSMService();
    const result = await fsmService.processStatusTransition(
      propostaId,
      status,
      userId,
      metadata || {}
    );

    if (!result.success) {
      return res.status(400).json({ 
        error: result.error,
        currentStatus: result.data?.status
      });
    }

    res.json({
      success: true,
      data: result.data,
      message: `Status atualizado para ${status}`
    });

  } catch (error) {
    console.error('[ROUTE] ‚ùå Error in PATCH proposta:', error);
    res.status(500).json({ 
      error: 'Erro ao atualizar status',
      details: error instanceof Error ? error.message : 'Erro desconhecido'
    });
  }
});

// ROTA: ClickSign com atualiza√ß√£o de status
app.post('/api/propostas/:id/clicksign/enviar', authenticateUser, async (req, res) => {
  const propostaId = req.params.id;
  const { forceStatusUpdate, targetStatus } = req.body;
  const userId = req.user?.id;
  
  console.log(`[ROUTE] POST /clicksign/enviar - Proposta: ${propostaId}`);
  
  try {
    // 1. Envia documento para ClickSign
    const clickSignResult = await clickSignService.sendDocument(propostaId);
    
    if (!clickSignResult.success) {
      throw new Error(`ClickSign error: ${clickSignResult.error}`);
    }

    // 2. Atualiza status se solicitado
    if (forceStatusUpdate && targetStatus) {
      const fsmService = new StatusFSMService();
      const statusResult = await fsmService.processStatusTransition(
        propostaId,
        targetStatus,
        userId,
        {
          source: 'CLICKSIGN_INTEGRATION',
          clicksignDocumentId: clickSignResult.documentId,
          timestamp: new Date().toISOString()
        }
      );

      if (!statusResult.success) {
        // Log mas n√£o falha a requisi√ß√£o
        console.error('[ROUTE] Status update after ClickSign failed:', statusResult.error);
      }
    }

    res.json({
      success: true,
      documentId: clickSignResult.documentId,
      message: 'Documento enviado para assinatura',
      statusUpdated: forceStatusUpdate && targetStatus
    });

  } catch (error) {
    console.error('[ROUTE] ‚ùå Error in ClickSign send:', error);
    res.status(500).json({ 
      error: 'Erro ao enviar para ClickSign',
      details: error instanceof Error ? error.message : 'Erro desconhecido'
    });
  }
});

// ============================================
// ARQUIVO 3: server/lib/db-transaction-manager.ts
// ============================================

import { db } from './db';

export class TransactionManager {
  private static readonly LOCK_TIMEOUT = 5000;
  private static readonly MAX_RETRIES = 3;

  static async executeWithRetry<T>(
    operation: (tx: any) => Promise<T>,
    options?: {
      maxRetries?: number;
      retryDelay?: number;
      lockTimeout?: number;
    }
  ): Promise<T> {
    const maxRetries = options?.maxRetries || this.MAX_RETRIES;
    const retryDelay = options?.retryDelay || 1000;
    const lockTimeout = options?.lockTimeout || this.LOCK_TIMEOUT;

    let lastError: Error | null = null;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        // Define timeout para a transa√ß√£o
        const result = await Promise.race([
          db.transaction(operation),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Transaction timeout')), lockTimeout)
          )
        ]) as T;

        return result;

      } catch (error) {
        lastError = error as Error;
        console.error(`[TRANSACTION] Attempt ${attempt + 1} failed:`, error);

        // Se √© um deadlock ou conflito de lock, retry com backoff
        if (this.isRetryableError(error)) {
          if (attempt < maxRetries - 1) {
            await new Promise(resolve => 
              setTimeout(resolve, retryDelay * Math.pow(2, attempt))
            );
            continue;
          }
        }

        // Para outros erros, falha imediatamente
        throw error;
      }
    }

    throw lastError || new Error('Transaction failed after max retries');
  }

  private static isRetryableError(error: any): boolean {
    const message = error?.message?.toLowerCase() || '';
    return (
      message.includes('deadlock') ||
      message.includes('lock timeout') ||
      message.includes('concurrent update') ||
      message.includes('could not serialize')
    );
  }
}

// ============================================
// ARQUIVO 4: server/lib/role-guards.ts (RLS Fix)
// ============================================

export async function checkPropostaAccess(
  userId: string,
  propostaId: string,
  requiredPermission: 'read' | 'write' | 'delete'
): Promise<boolean> {
  try {
    // Consulta com JOIN para verificar acesso
    const result = await db
      .select({
        hasAccess: sql<boolean>`
          CASE 
            WHEN p.created_by = ${userId} THEN true
            WHEN u.role = 'admin' THEN true
            WHEN u.role = 'manager' AND p.loja_id = u.loja_id THEN true
            WHEN u.role = 'user' AND p.created_by = ${userId} THEN true
            ELSE false
          END
        `
      })
      .from(propostas)
      .innerJoin(users, eq(users.id, userId))
      .where(eq(propostas.id, propostaId))
      .limit(1);

    return result[0]?.hasAccess || false;

  } catch (error) {
    console.error('[ROLE GUARD] Error checking access:', error);
    return false;
  }
}

// Middleware para validar acesso
export function requirePropostaAccess(permission: 'read' | 'write' | 'delete') {
  return async (req: Request, res: Response, next: NextFunction) => {
    const userId = req.user?.id;
    const propostaId = req.params.id;

    if (!userId || !propostaId) {
      return res.status(401).json({ error: 'N√£o autorizado' });
    }

    const hasAccess = await checkPropostaAccess(userId, propostaId, permission);
    
    if (!hasAccess) {
      console.warn(`[ROLE GUARD] Access denied for user ${userId} on proposta ${propostaId}`);
      return res.status(403).json({ 
        error: 'Acesso negado',
        details: 'Voc√™ n√£o tem permiss√£o para acessar esta proposta'
      });
    }

    next();
  };
}