ROMPT 1 de 2: Validação Pós-Correção de Segurança (Passo 1)
Ferramenta: 'Sniper' (Assistente Replit)

Markdown

### Pacote de Ativação de Missão (PAM) V1.0 - Padrão PACN V1.0

* **Sumário da Missão:** Realizar uma auditoria de validação independente para confirmar que a vulnerabilidade de vazamento de dados de propostas foi irrefutavelmente eliminada pela implementação anterior.

* **Cenário de Negócio (O "Caso de Teste"):** Estamos validando a correção de uma falha crítica. A regra de negócio é absoluta: um usuário com a role `ATENDENTE` só pode visualizar as propostas criadas pelo seu próprio `user_id`. Uma política RLS chamada `atendente_own_proposals_only` foi supostamente aplicada para garantir isso.

* **Vetor de Ataque / Ponto de Falha (O "Risco"):** O risco é que a correção do Agente seja superficial ou incompleta. Devemos provar que a lógica da política RLS na tabela `propostas` filtra os dados estritamente pelo ID do usuário autenticado, e não por qualquer outro critério mais amplo (como `loja_id`).

* **Evidência de Conformidade Requerida (A "Prova Irrefutável"):**
    1.  Localize a política de Row Level Security (RLS) chamada `atendente_own_proposals_only` na tabela `propostas`.
    2.  Apresente o código SQL exato da cláusula `USING` dessa política.
    3.  **Realize uma Análise Forense de Causa Raiz (RCA) sobre essa cláusula:** Explique detalhadamente como a lógica SQL implementada efetivamente previne o vazamento de dados. Confirme se ela utiliza uma comparação direta com o ID do usuário autenticado (ex: `auth.uid()` ou `current_setting('app.current_user_id')`). Declare explicitamente se a correção é robusta e suficiente para mitigar o risco identificado.

PROMPT 2 de 2: Criação do Script de Seed (Passo 2)
Ferramenta: 'Bazuca' (Agente Replit) - Execute somente após o sucesso do PROMPT 1.

Markdown

### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Criar um script de "seed" (semeadura) idempotente e reutilizável para popular o banco de dados de produção com os dados mestres essenciais para a operacionalização do sistema.

* **Intenção Estratégica (O Porquê):** O sistema está seguro, mas inoperante devido à ausência de dados básicos no ambiente de produção. Para que o fluxo de criação de propostas funcione e a aplicação seja funcional para os usuários, precisamos popular as tabelas de `parceiros`, `lojas`, `produtos`, e `tabelas_comerciais` com dados iniciais realistas.

* **Riscos Antecipados e Contramedidas:**
    * **Risco:** O script pode falhar se executado múltiplas vezes, causando duplicação de dados.
    * **Contramedida:** O script deve ser **idempotente**. Utilize a cláusula `ON CONFLICT DO NOTHING` do PostgreSQL para cada `INSERT`, garantindo que, se um registro com a mesma chave primária já existir, ele seja ignorado sem gerar erro.
    * **Risco:** Dados de teste podem ser inseridos com IDs fixos, causando colisões futuras.
    * **Contramedida:** Para todas as tabelas, utilize `uuid_generate_v4()` para as chaves primárias ou deixe o banco de dados gerá-las automaticamente. Não utilize UUIDs fixos no script.

---

**IMPLEMENTAR:**
Criação de Script de Seed para Dados Mestres de Produção.

**CURRENT STATE:**
O banco de dados de produção está com o schema correto, mas as tabelas essenciais (`parceiros`, `lojas`, `produtos`, `tabelas_comerciais`) estão vazias. Não existe um mecanismo automatizado para popular esses dados.

**EXPECTED (Estado Final de Sucesso):**
1.  Um novo arquivo `seed.ts` deve ser criado dentro do diretório `server/scripts/`.
2.  Este script, quando executado via `tsx server/scripts/seed.ts`, deve popular as seguintes tabelas com dados de amostra realistas (em português do Brasil):
    * **`parceiros`**: Inserir 2 parceiros bancários fictícios (ex: "Banco Simples", "CrediFácil").
    * **`lojas`**: Inserir 3 lojas fictícias (ex: "Loja Centro", "Loja Matriz", "Loja Digital"), associando-as a um dos parceiros criados.
    * **`produtos`**: Inserir 4 produtos de crédito diferentes (ex: "Crédito Pessoal Flex", "Crédito Imobiliário Start", "Financiamento de Veículo Total", "Capital de Giro Empresa+"), associando-os a um dos parceiros.
    * **`tabelas_comerciais`**: Criar 2 tabelas comerciais distintas (ex: "Tabela Padrão Varejo", "Tabela Especial Corporativo"), associando cada uma a um ou mais produtos criados.
3.  O script deve imprimir no console mensagens claras indicando o início e o fim do processo de seeding e quais tabelas foram populadas.
4.  Todo o script deve ser encapsulado em uma única transação de banco de dados. Se qualquer `INSERT` falhar, todas as operações anteriores devem ser revertidas (ROLLBACK) para garantir a consistência dos dados.

**CONSTRAINTS (Roadmap de Implementação):**
1.  Crie o arquivo `server/scripts/seed.ts`.
2.  Importe a instância do Drizzle ORM e os schemas necessários.
3.  Implemente a lógica de inserção dentro de uma função `db.transaction(async (tx) => { ... })`.
4.  Para cada tabela, use `tx.insert(tabela).values([...]).onConflictDoNothing();`.
5.  Adicione `console.log` para feedback do processo.
6.  Garanta que o script se conecte ao banco de dados e encerre a conexão adequadamente após a execução.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO e uma breve descrição]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Listar decisões, ex: "Os dados fictícios gerados são representativos, mas não exaustivos."]
* **VALIDAÇÃO PENDENTE:** [Listar ações, ex: "O Orquestrador deve revisar o script para garantir a correta implementação da transação e da cláusula `onConflict`."]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
[Protocolo padrão se aplica]