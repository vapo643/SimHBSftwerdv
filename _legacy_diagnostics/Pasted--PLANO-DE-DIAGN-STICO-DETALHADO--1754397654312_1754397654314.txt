// ==========================================
// PLANO DE DIAGN√ìSTICO DETALHADO
// ==========================================

/**
 * FASE 1: DIAGN√ìSTICO IMEDIATO
 * Execute estes comandos no console do navegador para identificar o problema
 */

// 1. Verificar se o token JWT est√° v√°lido
async function step1_checkJWTValidity() {
  console.log('=== STEP 1: JWT VALIDITY CHECK ===');
  
  try {
    const { TokenManager } = await import('@/lib/apiClient');
    const tokenManager = TokenManager.getInstance();
    const token = await tokenManager.getValidToken();
    
    console.log('Token status:', {
      exists: !!token,
      length: token?.length || 0,
      preview: token?.substring(0, 20) + '...' || 'N/A'
    });
    
    if (!token) {
      console.error('‚ùå NO TOKEN - User needs to login again');
      return false;
    }
    
    // Test token with a simple API call
    const testResponse = await fetch('/api/auth/me', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    console.log('Token validation test:', {
      status: testResponse.status,
      valid: testResponse.ok
    });
    
    if (!testResponse.ok) {
      const error = await testResponse.text();
      console.error('‚ùå TOKEN INVALID:', error);
      return false;
    }
    
    console.log('‚úÖ TOKEN IS VALID');
    return true;
    
  } catch (error) {
    console.error('‚ùå TOKEN CHECK FAILED:', error);
    return false;
  }
}

// 2. Testar endpoint de PDF diretamente
async function step2_testPdfEndpoint(propostaId, codigoSolicitacao) {
  console.log('=== STEP 2: PDF ENDPOINT TEST ===');
  
  try {
    const { TokenManager } = await import('@/lib/apiClient');
    const tokenManager = TokenManager.getInstance();
    const token = await tokenManager.getValidToken();
    
    const url = `/api/inter/collections/${propostaId}/${codigoSolicitacao}/pdf`;
    console.log('Testing URL:', url);
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/pdf'
      }
    });
    
    console.log('PDF endpoint response:', {
      status: response.status,
      statusText: response.statusText,
      contentType: response.headers.get('content-type'),
      contentLength: response.headers.get('content-length'),
      allHeaders: Object.fromEntries(response.headers.entries())
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå PDF ENDPOINT ERROR:', errorText);
      
      // Espec√≠fico para erro 401
      if (response.status === 401) {
        console.error('üîç 401 ANALYSIS:');
        console.error('- Token may be expired');
        console.error('- Token format may be wrong');
        console.error('- Backend JWT validation may be failing');
        console.error('- User may not have permission for this resource');
      }
      
      return false;
    }
    
    const blob = await response.blob();
    console.log('‚úÖ PDF BLOB RECEIVED:', {
      size: blob.size,
      type: blob.type
    });
    
    if (blob.size === 0) {
      console.error('‚ùå EMPTY PDF BLOB');
      return false;
    }
    
    console.log('‚úÖ PDF ENDPOINT WORKING');
    return true;
    
  } catch (error) {
    console.error('‚ùå PDF ENDPOINT TEST FAILED:', error);
    return false;
  }
}

// 3. Testar CORS e headers
async function step3_testCORS() {
  console.log('=== STEP 3: CORS TEST ===');
  
  try {
    // Fazer uma requisi√ß√£o OPTIONS para verificar CORS
    const response = await fetch('/api/inter/collections/test/test/pdf', {
      method: 'OPTIONS'
    });
    
    console.log('CORS preflight response:', {
      status: response.status,
      allowOrigin: response.headers.get('Access-Control-Allow-Origin'),
      allowMethods: response.headers.get('Access-Control-Allow-Methods'),
      allowHeaders: response.headers.get('Access-Control-Allow-Headers'),
      allowCredentials: response.headers.get('Access-Control-Allow-Credentials')
    });
    
    // Verificar se Authorization header √© permitido
    const allowedHeaders = response.headers.get('Access-Control-Allow-Headers');
    const authHeaderAllowed = allowedHeaders?.toLowerCase().includes('authorization');
    
    console.log('Authorization header allowed:', authHeaderAllowed);
    
    if (!authHeaderAllowed) {
      console.error('‚ùå AUTHORIZATION HEADER NOT ALLOWED BY CORS');
      return false;
    }
    
    console.log('‚úÖ CORS CONFIGURATION OK');
    return true;
    
  } catch (error) {
    console.error('‚ùå CORS TEST FAILED:', error);
    return false;
  }
}

// 4. Comparar com requisi√ß√£o que funciona
async function step4_compareWorkingEndpoint() {
  console.log('=== STEP 4: COMPARE WITH WORKING ENDPOINT ===');
  
  try {
    const { TokenManager } = await import('@/lib/apiClient');
    const tokenManager = TokenManager.getInstance();
    const token = await tokenManager.getValidToken();
    
    // Testar um endpoint que sabemos que funciona
    const workingResponse = await fetch('/api/propostas', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    console.log('Working endpoint response:', {
      status: workingResponse.status,
      contentType: workingResponse.headers.get('content-type'),
      headers: Object.fromEntries(workingResponse.headers.entries())
    });
    
    if (workingResponse.ok) {
      console.log('‚úÖ WORKING ENDPOINT CONFIRMS TOKEN IS VALID');
      console.log('üîç ISSUE IS SPECIFIC TO PDF ENDPOINT');
    } else {
      console.error('‚ùå EVEN WORKING ENDPOINT FAILS - GLOBAL AUTH ISSUE');
    }
    
  } catch (error) {
    console.error('‚ùå WORKING ENDPOINT TEST FAILED:', error);
  }
}

/**
 * FASE 2: DIAGN√ìSTICO AVAN√áADO
 * Para casos onde o problema n√£o √© √≥bvio
 */

// Interceptar requisi√ß√µes de rede para an√°lise detalhada
function step5_networkInterception() {
  console.log('=== STEP 5: NETWORK INTERCEPTION ===');
  
  // Interceptar fetch para logar todas as requisi√ß√µes
  const originalFetch = window.fetch;
  
  window.fetch = async (...args) => {
    const [url, options] = args;
    
    console.log('üåê FETCH INTERCEPTED:', {
      url: url.toString(),
      method: options?.method || 'GET',
      hasAuth: !!(options?.headers as any)?.Authorization,
      headers: options?.headers
    });
    
    const response = await originalFetch(...args);
    
    console.log('üì° FETCH RESPONSE:', {
      url: url.toString(),
      status: response.status,
      statusText: response.statusText,
      headers: Object.fromEntries(response.headers.entries())
    });
    
    return response;
  };
  
  console.log('‚úÖ Network interception enabled. Try the PDF download now.');
}

// Verificar se h√° problemas de timing
async function step6_timingAnalysis() {
  console.log('=== STEP 6: TIMING ANALYSIS ===');
  
  const { TokenManager } = await import('@/lib/apiClient');
  const tokenManager = TokenManager.getInstance();
  
  console.log('Getting token...');
  const start = Date.now();
  const token = await tokenManager.getValidToken();
  const tokenTime = Date.now() - start;
  
  console.log('Making PDF request...');
  const requestStart = Date.now();
  
  try {
    const response = await fetch('/api/inter/collections/test/test/pdf', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    const requestTime = Date.now() - requestStart;
    
    console.log('Timing analysis:', {
      tokenObtainTime: tokenTime + 'ms',
      requestTime: requestTime + 'ms',
      totalTime: (Date.now() - start) + 'ms'
    });
    
    if (requestTime > 5000) {
      console.warn('‚ö†Ô∏è REQUEST TAKING TOO LONG - May be timeout issue');
    }
    
  } catch (error) {
    console.error('‚ùå TIMING ANALYSIS FAILED:', error);
  }
}

/**
 * FASE 3: SOLU√á√ïES ALTERNATIVAS
 * Se o diagn√≥stico n√£o resolver, testar estas alternativas
 */

// Alternativa 1: URL Tempor√°ria Assinada
async function alternative1_signedUrl(propostaId, codigoSolicitacao) {
  console.log('=== ALTERNATIVE 1: SIGNED URL ===');
  
  try {
    const { apiClient } = await import('@/lib/apiClient');
    
    // Solicitar URL tempor√°ria assinada
    const { downloadUrl } = await apiClient(`/inter/collections/${propostaId}/${codigoSolicitacao}/signed-url`, {
      method: 'POST'
    });
    
    console.log('Signed URL received:', downloadUrl);
    
    // Usar URL assinada para download direto (sem Authorization header)
    const a = document.createElement('a');
    a.href = downloadUrl;
    a.download = `boleto-${codigoSolicitacao}.pdf`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    console.log('‚úÖ SIGNED URL DOWNLOAD INITIATED');
    
  } catch (error) {
    console.error('‚ùå SIGNED URL FAILED:', error);
  }
}

// Alternativa 2: Download via iframe
async function alternative2_iframe(propostaId, codigoSolicitacao) {
  console.log('=== ALTERNATIVE 2: IFRAME DOWNLOAD ===');
  
  try {
    const { TokenManager } = await import('@/lib/apiClient');
    const tokenManager = TokenManager.getInstance();
    const token = await tokenManager.getValidToken();
    
    // Criar form tempor√°rio para POST com token
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = `/api/inter/collections/${propostaId}/${codigoSolicitacao}/pdf-download`;
    form.target = '_blank';
    form.style.display = 'none';
    
    const tokenInput = document.createElement('input');
    tokenInput.type = 'hidden';
    tokenInput.name = 'token';
    tokenInput.value = token;
    
    form.appendChild(tokenInput);
    document.body.appendChild(form);
    form.submit();
    document.body.removeChild(form);
    
    console.log('‚úÖ IFRAME DOWNLOAD INITIATED');
    
  } catch (error) {
    console.error('‚ùå IFRAME DOWNLOAD FAILED:', error);
  }
}

/**
 * EXECUTOR PRINCIPAL - Execute esta fun√ß√£o no console
 */
async function runFullDiagnosis(propostaId = 'test', codigoSolicitacao = 'test') {
  console.log('üîç STARTING FULL PDF DOWNLOAD DIAGNOSIS');
  console.log('=====================================');
  
  const results = {
    jwtValid: false,
    pdfEndpointWorking: false,
    corsOk: false
  };
  
  // Executar testes em sequ√™ncia
  results.jwtValid = await step1_checkJWTValidity();
  
  if (results.jwtValid) {
    results.pdfEndpointWorking = await step2_testPdfEndpoint(propostaId, codigoSolicitacao);
  }
  
  results.corsOk = await step3_testCORS();
  
  await step4_compareWorkingEndpoint();
  
  console.log('üîç DIAGNOSIS RESULTS:', results);
  
  // Recomenda√ß√µes baseadas nos resultados
  if (!results.jwtValid) {
    console.log('üìã RECOMMENDATION: Fix JWT authentication first');
    console.log('   - Check if user is properly logged in');
    console.log('   - Verify TokenManager configuration');
    console.log('   - Check Supabase session status');
  } else if (!results.pdfEndpointWorking) {
    console.log('üìã RECOMMENDATION: Fix PDF endpoint');
    console.log('   - Check backend JWT middleware logs');
    console.log('   - Verify PDF generation service');
    console.log('   - Check database permissions');
  } else if (!results.corsOk) {
    console.log('üìã RECOMMENDATION: Fix CORS configuration');
    console.log('   - Add Authorization to allowed headers');
    console.log('   - Check preflight response');
  } else {
    console.log('üìã All tests passed - issue may be browser-specific');
    console.log('   - Try alternative download methods');
    console.log('   - Check browser console for errors');
  }
  
  return results;
}

// Para usar no console do navegador:
// 1. Cole todo este c√≥digo no console
// 2. Execute: runFullDiagnosis('sua-proposta-id', 'seu-codigo-solicitacao')
// 3. Analise os resultados e siga as recomenda√ß√µes

console.log('üîß PDF Download Diagnostic Tools loaded');
console.log('Execute: runFullDiagnosis("propostaId", "codigoSolicitacao")');

/**
 * LOGS DE BACKEND ADICIONAIS
 * Adicione estes logs ao seu backend para melhor diagn√≥stico
 */

/*
// No seu middleware JWT, adicione logs mais detalhados:
console.log(`[JWT_DEBUG] Full request analysis:`, {
  path: req.path,
  method: req.method,
  userAgent: req.headers['user-agent'],
  origin: req.headers.origin,
  referer: req.headers.referer,
  authHeader: req.headers.authorization ? 'Present' : 'Missing',
  authHeaderLength: req.headers.authorization?.length || 0,
  allHeaders: Object.keys(req.headers),
  timestamp: new Date().toISOString()
});

// No seu handler de PDF, adicione:
console.log(`[PDF_DEBUG] PDF request details:`, {
  propostaId,
  codigoSolicitacao,
  userId: req.user?.id,
  userEmail: req.user?.email,
  requestId: Math.random().toString(36).substring(7),
  contentLength: 'Will be determined',
  timestamp: new Date().toISOString()
});
*/