// ==========================================
// client/src/lib/apiClient.ts - MELHORIAS PARA BLOB DOWNLOAD
// ==========================================

interface ApiClientOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  data?: any;
  headers?: Record<string, string>;
  responseType?: 'json' | 'blob' | 'text';
  timeout?: number;
  retries?: number;
}

export class TokenManager {
  private static instance: TokenManager;
  private tokenCache: {
    token: string;
    expiresAt: number;
  } | null = null;

  static getInstance(): TokenManager {
    if (!TokenManager.instance) {
      TokenManager.instance = new TokenManager();
    }
    return TokenManager.instance;
  }

  /**
   * MÉTODO MELHORADO: Get valid token com force refresh
   */
  async getValidToken(forceRefresh: boolean = false): Promise<string | null> {
    try {
      // Se force refresh ou token expirado, buscar novo
      if (forceRefresh || !this.tokenCache || Date.now() >= this.tokenCache.expiresAt) {
        console.log('[TOKEN_MANAGER] Getting fresh token from Supabase...');
        
        const supabase = createClient(
          import.meta.env.VITE_SUPABASE_URL,
          import.meta.env.VITE_SUPABASE_ANON_KEY
        );

        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error || !session?.access_token) {
          console.error('[TOKEN_MANAGER] Failed to get session:', error);
          this.tokenCache = null;
          return null;
        }

        // Cache token with 5 minute buffer before expiration
        const expiresAt = session.expires_at ? (session.expires_at * 1000) - (5 * 60 * 1000) : Date.now() + (50 * 60 * 1000);
        
        this.tokenCache = {
          token: session.access_token,
          expiresAt
        };

        console.log('[TOKEN_MANAGER] ✅ Fresh token cached');
      }

      return this.tokenCache?.token || null;
    } catch (error) {
      console.error('[TOKEN_MANAGER] Error getting token:', error);
      this.tokenCache = null;
      return null;
    }
  }

  /**
   * Clear cached token (useful for logout or token errors)
   */
  clearToken(): void {
    this.tokenCache = null;
  }
}

/**
 * API CLIENT MELHORADO com suporte a blob downloads
 */
export async function apiClient<T = any>(
  endpoint: string, 
  options: ApiClientOptions = {}
): Promise<T> {
  const {
    method = 'GET',
    data,
    headers = {},
    responseType = 'json',
    timeout = 30000,
    retries = 1
  } = options;

  const tokenManager = TokenManager.getInstance();
  let lastError: Error | null = null;

  // Retry logic
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      console.log(`[API_CLIENT] Request attempt ${attempt}/${retries}:`, {
        endpoint,
        method,
        responseType,
        hasData: !!data
      });

      // Get fresh token for each attempt (especially important for downloads)
      const token = await tokenManager.getValidToken(attempt > 1);
      
      if (!token) {
        throw new Error('No authentication token available');
      }

      const url = endpoint.startsWith('/') ? `/api${endpoint}` : endpoint;
      
      const requestHeaders: HeadersInit = {
        'Authorization': `Bearer ${token}`,
        ...headers
      };

      // Don't set Content-Type for FormData or when downloading
      if (responseType !== 'blob' && !(data instanceof FormData)) {
        requestHeaders['Content-Type'] = 'application/json';
      }

      console.log(`[API_CLIENT] Making request to: ${url}`, {
        method,
        responseType,
        headerKeys: Object.keys(requestHeaders)
      });

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);

      const response = await fetch(url, {
        method,
        headers: requestHeaders,
        body: data ? (data instanceof FormData ? data : JSON.stringify(data)) : undefined,
        signal: controller.signal,
        credentials: 'include' // Important for CORS
      });

      clearTimeout(timeoutId);

      console.log(`[API_CLIENT] Response received:`, {
        status: response.status,
        statusText: response.statusText,
        contentType: response.headers.get('content-type'),
        contentLength: response.headers.get('content-length')
      });

      // Handle non-success status codes
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[API_CLIENT] HTTP Error ${response.status}:`, errorText);
        
        // If 401 and we have retries left, try with fresh token
        if (response.status === 401 && attempt < retries) {
          tokenManager.clearToken(); // Force refresh on next attempt
          lastError = new Error(`Authentication failed (attempt ${attempt}): ${errorText}`);
          continue;
        }
        
        throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
      }

      // Handle different response types
      let result: any;
      
      switch (responseType) {
        case 'blob':
          result = await response.blob();
          console.log(`[API_CLIENT] Blob received:`, {
            size: result.size,
            type: result.type
          });
          
          if (result.size === 0) {
            throw new Error('Received empty blob');
          }
          break;
          
        case 'text':
          result = await response.text();
          break;
          
        case 'json':
        default:
          const text = await response.text();
          if (!text) {
            result = {};
          } else {
            try {
              result = JSON.parse(text);
            } catch (parseError) {
              console.warn('[API_CLIENT] Failed to parse JSON, returning text:', parseError);
              result = text;
            }
          }
          break;
      }

      console.log(`[API_CLIENT] ✅ Request successful`);
      return result as T;

    } catch (error) {
      lastError = error as Error;
      console.error(`[API_CLIENT] ❌ Attempt ${attempt} failed:`, error);
      
      if (attempt === retries) {
        break; // Last attempt failed
      }
      
      // Delay before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }

  // All attempts failed
  throw lastError || new Error('All API client attempts failed');
}

// ==========================================
// UTILITY FUNCTIONS PARA DEBUGGING
// ==========================================

export class DownloadDebugger {
  /**
   * Test JWT token validity
   */
  static async testTokenValidity(): Promise<void> {
    try {
      console.log('[DEBUG] Testing token validity...');
      
      const tokenManager = TokenManager.getInstance();
      const token = await tokenManager.getValidToken();
      
      if (!token) {
        console.error('[DEBUG] ❌ No token available');
        return;
      }

      console.log('[DEBUG] ✅ Token obtained:', {
        length: token.length,
        preview: token.substring(0, 20) + '...'
      });

      // Test token with a simple API call
      const response = await fetch('/api/auth/me', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      console.log('[DEBUG] Auth test response:', {
        status: response.status,
        statusText: response.statusText
      });

      if (response.ok) {
        const user = await response.json();
        console.log('[DEBUG] ✅ Token is valid for user:', user.id);
      } else {
        const error = await response.text();
        console.error('[DEBUG] ❌ Token validation failed:', error);
      }

    } catch (error) {
      console.error('[DEBUG] ❌ Token test failed:', error);
    }
  }

  /**
   * Test PDF download endpoint directly
   */
  static async testPdfEndpoint(propostaId: string, codigoSolicitacao: string): Promise<void> {
    try {
      console.log('[DEBUG] Testing PDF endpoint directly...');

      const tokenManager = TokenManager.getInstance();
      const token = await tokenManager.getValidToken();
      
      if (!token) {
        console.error('[DEBUG] ❌ No token for PDF test');
        return;
      }

      const url = `/api/inter/collections/${propostaId}/${codigoSolicitacao}/pdf`;
      console.log('[DEBUG] Testing URL:', url);

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/pdf'
        }
      });

      console.log('[DEBUG] PDF endpoint response:', {
        status: response.status,
        statusText: response.statusText,
        contentType: response.headers.get('content-type'),
        contentLength: response.headers.get('content-length'),
        headers: Object.fromEntries(response.headers.entries())
      });

      if (response.ok) {
        const blob = await response.blob();
        console.log('[DEBUG] ✅ PDF blob received:', {
          size: blob.size,
          type: blob.type
        });
      } else {
        const errorText = await response.text();
        console.error('[DEBUG] ❌ PDF endpoint failed:', errorText);
      }

    } catch (error) {
      console.error('[DEBUG] ❌ PDF endpoint test failed:', error);
    }
  }
}