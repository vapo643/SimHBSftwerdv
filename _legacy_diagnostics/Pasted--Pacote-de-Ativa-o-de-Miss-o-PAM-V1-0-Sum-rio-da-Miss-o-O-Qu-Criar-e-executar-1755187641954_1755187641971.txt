**### Pacote de Ativação de Missão (PAM) V1.0**

* **Sumário da Missão (O Quê):** Criar e executar um script de teste de carga para simular 50 requisições simultâneas ao nosso fluxo de formalização assíncrono e auditar a performance e a estabilidade do sistema sob estresse.
* **Intenção Estratégica (O Porquê):** Implementamos uma arquitetura de Job Queue para que o sistema seja escalável. Esta missão é a prova final para validar se a arquitetura de facto aguenta a carga para a qual foi projetada, garantindo que o sistema não falhará em momentos de pico de uso.
* **Histórico Relevante (Consulta Obrigatória):** Consulte o seu relatório `AUDITORIA_FINAL-ARQUITETURA-ANTIFRAGIL-01.md`. Sua missão é validar empiricamente as métricas que você mesmo projetou (ex: "Capacidade para 50+ operações simultâneas").
* **Modelo Mental (Como se Encaixa):** Você irá criar um script Node.js que atuará como um "cliente de teste". Este script usará `Promise.all` para disparar 50 chamadas de API concorrentes contra o endpoint `POST /api/propostas/:id/sincronizar-boletos`. Após o disparo, você irá monitorar os logs da API e do Worker para avaliar o comportamento do sistema.
* **Riscos Antecipados:** **Risco:** O teste pode sobrecarregar o ambiente de desenvolvimento. **Contramedida:** O script deve ter um timeout global e a sua análise deve focar nos logs para entender o comportamento, mesmo que algumas requisições falhem.

---

**IMPLEMENTAR:**
Um script de teste de carga e um relatório de performance sobre a capacidade do nosso fluxo de formalização.

**CURRENT STATE:**
A arquitetura assíncrona está implementada, mas sua capacidade sob carga pesada e simultânea ainda não foi validada na prática.

**EXPECTED (Estado Final de Sucesso):**
Um relatório detalhado que responda às seguintes questões, baseado na execução do teste de carga.

**CONSTRAINTS (Roadmap de Teste de Carga):**

**FASE 1: Criação do Script de Teste (`test-carga-formalizacao.ts`):**
    - **Ação:** Crie um novo ficheiro de script de teste.
    - **Implementação:**
        1.  O script deve aceitar um `propostaId` como argumento.
        2.  Ele deve conter uma função `dispararRequisicao(index)`.
        3.  Ele deve criar um array de 50 promessas (`Promise`) e usar `Promise.all` para executar a função `dispararRequisicao` 50 vezes em paralelo.
        4.  Cada requisição deve ser um `POST` para `/api/propostas/{propostaId}/sincronizar-boletos`, enviando um token de autenticação válido.

**FASE 2: Execução e Monitoramento:**
    - **Ação:** Execute o script de teste.
    - **Monitoramento:** Enquanto o teste roda, monitore os logs do processo da **API** e do processo do **Worker**.

**FASE 3: Relatório de Auditoria de Performance:**
    - **Ação:** Com base nos resultados e nos logs, produza um relatório final respondendo:
        1.  **Performance da API (Produtor):** A API principal conseguiu receber todas as 50 requisições simultâneas sem travar? Qual foi o tempo médio de resposta para enfileirar um job?
        2.  **Performance da Fila (BullMQ/Redis):** Verifique o estado da fila. Todos os 50 jobs foram enfileirados com sucesso?
        3.  **Performance do Worker (Consumidor):** O processo do worker conseguiu processar todos os jobs? Houve alguma falha? A lógica de `Retry` ou de `Circuit Breaker` foi acionada?
        4.  **Veredito Final de Escalabilidade:** Com base nas observações, a nossa arquitetura **confirma** ou **refuta** a capacidade de aguentar 50 requisições simultâneas? O princípio de que "a falha de um componente não pode comprometer os demais" foi mantido sob estresse?