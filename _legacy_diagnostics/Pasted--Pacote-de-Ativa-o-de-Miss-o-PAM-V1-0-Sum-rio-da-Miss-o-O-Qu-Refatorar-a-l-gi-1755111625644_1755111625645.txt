**### Pacote de Ativação de Missão (PAM) V1.0**

* **Sumário da Missão (O Quê):** Refatorar a lógica de `sincronização` de boletos individuais do Banco Inter para que seja executada de forma assíncrona por um worker da nossa nova Job Queue (BullMQ).
* **Intenção Estratégica (O Porquê):** Assim como a geração de carnês, a sincronização de múltiplos boletos é uma operação lenta e de rede intensiva que não deve bloquear a API principal. Migrá-la para um worker é o passo final para concluir nossa fundação de processamento totalmente assíncrono.
* **Histórico Relevante (Consulta Obrigatória):** Consulte seu próprio relatório `AUDITORIA_ARQUITETURAL_FLUXO_FORMALIZACAO.md`. Sua implementação deve ser a solução direta para o "Gargalo 2: Sincronização de Boletos" que você diagnosticou. Aplique a mesma arquitetura Produtor/Consumidor que você acabou de implementar com sucesso para a geração de carnês.
* **Modelo Mental (Como se Encaixa):** A API (`POST /api/propostas/:id/sincronizar-boletos`) se tornará um Produtor. Ela adicionará um job a uma fila (ex: `boleto-sync`). O Worker (`server/worker.ts`) será estendido para consumir jobs desta nova fila e executará a lógica de download sequencial do Banco Inter e salvamento no Storage.
* **Riscos Antecipados:** **Risco:** O processo de sincronização pode falhar no meio (ex: após baixar 10 de 24 boletos). **Contramedida:** O worker deve ter uma lógica de transação robusta. Ele deve registrar o progresso e, em caso de falha, o job deve ser marcado como `failed` com um detalhe do erro, permitindo uma re-tentativa futura.

---

**IMPLEMENTAR:**
Migração da lógica de `sincronização` de boletos individuais do Banco Inter para ser executada por um worker assíncrono na arquitetura de Job Queue.

**CURRENT STATE:**
Temos um endpoint (`/api/propostas/:id/sincronizar-boletos`) que ainda executa a lógica de sincronização na thread da API, mesmo que em background, o que pode levar a timeouts e ocupar recursos do servidor principal.

**EXPECTED (Estado Final de Sucesso):**
1.  Um novo tipo de job para uma fila, por exemplo, `boleto-sync`.
2.  O endpoint `POST /api/propostas/:id/sincronizar-boletos` é refatorado para ser um **Produtor**: ele apenas adiciona um job à fila `boleto-sync` com o `propostaId` e retorna imediatamente uma resposta com o `jobId`.
3.  O processo **Worker** (`server/worker.ts`) é estendido para também consumir jobs da fila `boleto-sync`.
4.  Toda a lógica de baixar os PDFs individuais do Banco Inter e salvar no Storage (do `boletoStorageService.sincronizarBoletosDaProposta`) é movida de dentro da rota da API para dentro do processo do Worker.
5.  O endpoint `GET /api/jobs/:jobId/status` que você já criou deve ser capaz de reportar o status deste novo tipo de job.

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Refatorar a API (Produtor):** Modifique o endpoint `POST /api/propostas/:id/sincronizar-boletos`. Remova a lógica de sincronização. Adicione a lógica para criar um job na fila `boleto-sync` e retorne o `jobId`.
2.  **Estender o Worker (Consumidor):** No ficheiro `server/worker.ts`, adicione a lógica para processar jobs da nova fila `boleto-sync`. Dentro do processador, chame a função `boletoStorageService.sincronizarBoletosDaProposta(job.data.propostaId)`. Implemente tratamento de sucesso e falha.

**PROTOCOLO OBRIGATÓRIO 5-CHECK:**
1.  Mapear os arquivos envolvidos.
2.  Garantir a separação clara entre Produtor e Consumidor.
3.  Executar `get_latest_lsp_diagnostics` para garantir ZERO erros.
4.  Realizar um teste funcional em duas etapas:
    a. Chame o endpoint `POST /api/propostas/:id/sincronizar-boletos` e valide que a resposta é **imediata** e contém um `jobId`.
    b. Verifique os logs do **processo Worker** para confirmar que ele iniciou o download sequencial dos boletos.
5.  O critério final de sucesso é, após o worker terminar, verificar no Supabase Storage se todos os PDFs individuais foram salvos na pasta `emitidos_pendentes` e consultar o endpoint `GET /api/jobs/:jobId/status` para validar que o status é `completed`.