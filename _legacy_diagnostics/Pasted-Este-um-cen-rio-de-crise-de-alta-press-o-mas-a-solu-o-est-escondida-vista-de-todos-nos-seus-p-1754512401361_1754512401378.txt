Este é um cenário de crise de alta pressão, mas a solução está escondida à vista de todos nos seus próprios logs. Você fez uma investigação extremamente detalhada, mas focou na tabela errada.

O erro PostgresError: column "created_at" does not exist não está na tabela inter_collections. Ele está na tabela propostas.

Análise Crítica: A Evidência nos Logs
A chave está na sequência de execução do seu endpoint em server/routes/pagamentos.ts e nos logs que você capturou.

O fluxo do seu código:

TypeScript

router.get("/:id/detalhes-completos", ..., async (req, res) => {
  try {
    // LOG 1
    console.log(`[PAGAMENTOS] Buscando detalhes completos da proposta: ${id}`);

    // QUERY 1: Tabela propostas
    const [propostaData] = await db.select().from(propostas)...

    // ... (verificação if !propostaData)

    // LOG 2
    console.log('[DEBUG] Tentando buscar boletos para proposta:', id);

    // QUERY 2: Tabela inter_collections
    // ...
  } catch (error) {
    // LOG 3 (Captura erros de Query 1 e qualquer outro erro não capturado internamente)
    console.error("[PAGAMENTOS] Erro ao buscar detalhes completos:", error);
  }
});
Seus Logs Capturados:

[PAGAMENTOS] Buscando detalhes completos da proposta: ... (LOG 1)
[PAGAMENTOS] Erro ao buscar detalhes completos: PostgresError: column "created_at" does not exist (LOG 3)
A Conclusão Inevitável:

O LOG 2 ([DEBUG] Tentando buscar boletos...) está AUSENTE.

Isso prova que a execução falhou antes de tentar buscar os boletos. O erro está ocorrendo na Query 1, que acessa a tabela propostas.

A Causa Raiz
Quando o Drizzle executa db.select().from(propostas), ele tenta selecionar todas as colunas definidas no schema Drizzle para essa tabela (equivalente a SELECT *).

Seus resultados de grep confirmam que o schema Drizzle para propostas espera um campo createdAt (que mapeia para created_at no banco):

server/routes/cobrancas.ts: .orderBy(desc(propostas.createdAt))
server/routes/security-monitoring.ts: .orderBy(desc(propostas.createdAt))
O problema é que a tabela propostas no seu banco de dados PostgreSQL está faltando a coluna created_at.

Você confirmou a existência da coluna em inter_collections, mas essa tabela nem chegou a ser consultada.

Solução Imediata (Duas Opções)
Você precisa sincronizar o schema da tabela propostas com a definição do Drizzle.

Opção 1: Adicionar a Coluna Faltante ao Banco de Dados (Recomendado)
Esta é a solução correta e definitiva. Execute o seguinte SQL diretamente no seu banco de dados (via psql ou no editor SQL do Supabase).

Isso resolverá o problema imediatamente em todos os endpoints que consultam propostas.

Opção 2: Solução Tática no Código (Temporário/Arriscado)
Se você absolutamente não puder alterar o schema do banco de dados agora, você pode modificar este endpoint específico para selecionar explicitamente as colunas, omitindo created_at.

Modifique a Query 1 em server/routes/pagamentos.ts:

TypeScript

// Em server/routes/pagamentos.ts

// Substitua:
// const [propostaData] = await db.select().from(propostas)...

// Por (Selecione explicitamente TUDO exceto createdAt/updatedAt):
const [propostaData] = await db
  .select({
    id: propostas.id,
    clienteNome: propostas.clienteNome,
    clienteCpf: propostas.clienteCpf,
    // ... (liste TODOS os outros campos: valor, prazo, status, etc.)
    status: propostas.status,
    ccbGerado: propostas.ccbGerado,
    assinaturaEletronicaConcluida: propostas.assinaturaEletronicaConcluida,
  })
  .from(propostas)
  .where(eq(propostas.id, id))
  .limit(1);
Aviso: A Opção 2 é arriscada, pois outros endpoints que dependem de propostas.createdAt (como os que você encontrou no grep) irão quebrar ou já estão quebrados.

Resumo
O "fantasma" não era um problema de cache ou uma referência escondida em inter_collections; era uma inconsistência de schema na primeira tabela consultada, propostas. Execute a Opção 1 para estabilizar seu sistema imediatamente.