### Pacote de Ativação de Missão (PAM) V1.0

* **Sumário da Missão (O Quê):** Implementar uma camada de cache L2 usando Redis para a função que busca as tabelas comerciais disponíveis para um parceiro e produto.
* **Intenção Estratégica (O Porquê):** Mitigar o risco de performance crítico identificado na auditoria. O cache irá reduzir drasticamente a carga no banco de dados para queries repetitivas, melhorando a latência e a escalabilidade do sistema, especialmente para usuários com muitas permissões (gerentes) que acionam queries complexas com RLS.
* **Histórico Relevante (Consulta Obrigatória):** A auditoria identificou que queries de configuração, como as de tabelas comerciais, são executadas frequentemente, mas seus dados mudam raramente. O sistema já possui uma conexão `ioredis` configurada para o BullMQ que deve ser reutilizada.
* **Modelo Mental (Como se Encaixa):** Esta missão implementará o padrão de cache "cache-aside". A lógica de negócio será modificada para, primeiro, tentar ler os dados do cache (Redis). Se os dados não existirem ("cache miss"), ela buscará no banco de dados, salvará o resultado no cache para futuras requisições e, então, retornará os dados.
* **Riscos Antecipados e Contramedidas:**
    * **Risco:** Uma implementação de cache incorreta pode servir dados desatualizados (stale data).
    * **Contramedida:** O cache terá um TTL (Time-To-Live) definido para expirar automaticamente, garantindo que os dados sejam atualizados periodicamente.

---

**IMPLEMENTAR:**
Serviço de Cache L2 com Redis para Tabelas Comerciais

**CURRENT STATE:**
A função que busca tabelas comerciais (provavelmente em um serviço como `commercialTableService.ts`) executa uma query complexa no PostgreSQL a cada chamada, representando um potencial gargalo de performance.

**EXPECTED (Estado Final de Sucesso):**
1.  Um novo serviço de cache (`server/services/cacheService.ts`) é criado, utilizando a conexão `ioredis` existente.
2.  A função de negócio que busca as tabelas comerciais é refatorada para usar o novo serviço de cache.
3.  A nova lógica segue estritamente o padrão "cache-aside":
    a. Gera uma chave de cache única e determinística (ex: `tabelas-comerciais:produtoId:${produtoId}:parceiroId:${parceiroId}`).
    b. Tenta buscar os dados do Redis usando a chave.
    c. Se houver um "cache hit" (dados encontrados), retorna os dados do cache.
    d. Se houver um "cache miss" (dados não encontrados), executa a query original no banco de dados.
    e. Armazena o resultado da query no Redis com um TTL de 1 hora (3600 segundos).
    f. Retorna o resultado da query.
4.  A implementação inclui `console.log` para `cache hit` e `cache miss` para fins de depuração.

**CONSTRAINTS (Roadmap de Implementação):**
1.  **Reutilize a Conexão Existente:** Localize a instância `ioredis` existente no projeto (usada pelo BullMQ) e reutilize-a. Não crie uma nova conexão Redis.
2.  **Crie o `cacheService.ts`:** Crie um novo arquivo `server/services/cacheService.ts`. Ele deve exportar funções como `getFromCache(key)` e `setToCache(key, value, ttlInSeconds)`.
3.  **Padrão de Chave:** O padrão da chave de cache deve ser `dominio:chave1:valor1:chave2:valor2` para garantir que seja única e legível.
4.  **Serialização:** Os dados (que serão objetos/arrays) devem ser serializados com `JSON.stringify` antes de salvar no Redis e desserializados com `JSON.parse` ao ler.
5.  **Refatore o Serviço de Negócio:**
    a. Localize a função que busca as tabelas comerciais.
    b. Importe o novo `cacheService`.
    c. Implemente a lógica "cache-aside" conforme descrito em `EXPECTED`.
    d. O TTL (Time-To-Live) para o cache deve ser de `3600` segundos.

---
**DECLARAÇÃO DE INCERTEZA (OBRIGATÓRIO):**
* **CONFIANÇA NA IMPLEMENTAÇÃO:** [Preencher com a porcentagem de 0 a 100%]
* **RISCOS IDENTIFICADOS:** [Preencher com a categoria BAIXO/MÉDIO/ALTO/CRÍTICO. Risco de servir dados desatualizados se a lógica de invalidação/TTL for incorreta.]
* **DECISÕES TÉCNICAS ASSUMIDAS:** [Ex: "Assumi que um TTL de 1 hora é um balanço aceitável entre performance e atualização dos dados."]
* **VALIDAÇÃO PENDENTE:** [Testes de performance antes e depois da implementação são necessários para quantificar o ganho. Validar a estratégia de invalidação de cache quando uma tabela comercial for alterada.]
---

**PROTOCOLO OBRIGATÓRIO 7-CHECK EXPANDIDO:**
1.  Mapear ficheiros e funções exatas afetadas.
2.  Garantir importações e tipos corretos para o novo serviço de cache e `ioredis`.
3.  Executar `get_latest_lsp_diagnostics` para garantir 0 erros novos.
4.  **Declarar Nível de Confiança (0-100%)**.
5.  **Categorizar Riscos Descobertos**.
6.  **Realizar teste funcional completo** (verificar logs de `cache hit`/`cache miss` para confirmar que o cache está funcionando).
7.  **Documentar Decisões Técnicas** como o padrão de chave de cache e a escolha do TTL.