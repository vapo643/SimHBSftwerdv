Diagnosed mTLS API integration error with systematic troubleshooting approach.6 sVou analisar este problema complexo de integração com a API do Banco Inter. O usuário está recebendo erro 400 com corpo vazio, o que indica que a falha está ocorrendo antes da aplicação processar a requisição - provavelmente na camada de transporte ou autenticação mTLS.
Vou estruturar minha resposta em três seções principais como solicitado:

Análise da Causa Raiz: Vou examinar cuidadosamente a implementação mTLS, a formatação dos certificados, os headers, e o payload JSON para identificar possíveis problemas.
Código Refatorado: Vou melhorar o serviço com melhor tratamento de erros, formatação de certificados mais robusta, e debugging aprimorado.
Plano de Ação de Diagnóstico: Vou fornecer um plano passo a passo incluindo comandos curl para testar a integração.

Vou focar nas hipóteses mais prováveis:

Problemas na formatação dos certificados PEM
Configuração incorreta do agente mTLS (Undici vs. HTTPS nativo)
Headers faltando ou incorretos
Formato do payload JSON não compatível com a API v3

Vou prestar atenção especial aos detalhes técnicos mencionados no código, como a função customStringify para números decimais, a formatação de certificados com quebras de linha, e a configuração do Undici agent.Olhando para este problema complexo de integração com a API do Banco Inter, vou ajudá-lo a identificar e resolver a causa do erro 400 Bad Request com corpo vazio. Esta é uma situação típica onde o erro ocorre na camada de transporte antes da aplicação processar a requisição.
1. Análise da Causa Raiz
Após examinar detalhadamente seu código e payload, identifiquei várias possíveis causas para o erro 400 com corpo vazio:
Hipótese Principal: Problemas na Configuração mTLS
O erro mais provável está na configuração do cliente mTLS. Observei alguns pontos críticos no seu código:
Problema 1: Configuração Inconsistente do Undici Agent
Seu código usa dispatcher em vez de agent no fetch, mas a configuração está sendo criada como UndiciAgent. O Undici mudou sua API e a propriedade correta para mTLS no fetch moderno é diferente.
Problema 2: Formatação dos Certificados
Embora você tenha lógica para adicionar quebras de linha nos certificados PEM, existe uma inconsistência na detecção de certificados já formatados. Certificados mal formatados causam falhas silenciosas no handshake TLS.
Problema 3: Conflito entre Fetch e HTTPS Request
Seu código tenta usar fetch com Undici como fallback para https.request, mas as configurações mTLS são diferentes entre os dois métodos, criando inconsistências.
Hipótese Secundária: Headers Específicos da API
A API do Banco Inter pode estar esperando headers adicionais específicos que não estão sendo enviados. Observei que seu código inclui x-conta-corrente, mas pode haver outros headers obrigatórios não documentados.
Hipótese Terciária: Formato do Payload JSON
Sua função customStringify para preservar formato decimal pode estar causando problemas. APIs bancárias são muito sensíveis ao formato exato dos números.
2. Código Refatorado
Vou refatorar o interBankService.ts com melhorias focadas na resolução desses problemas:InterBankService Refatorado - Versão MelhoradaCódigo /**
 * Banco Inter API Integration Service - VERSÃO REFATORADA
 * Melhorias focadas na correção do erro 400 Bad Request
 * 
 * Principais mudanças:
 * - Configuração mTLS mais robusta e compatível
 * - Melhor formatação e validação de certificados PEAnalyzed API error and crafted diagnostic strategy for resolution.4 sO usuário pediu uma análise detalhada e refatoração do código para resolver o erro 400 com corpo vazio na API do Banco Inter. Acabei de criar o código refatorado, mas preciso completar a resposta com as seções 1 e 3 conforme solicitado.
Vou estruturar a resposta conforme o formato esperado:

Análise da Causa Raiz
Código Refatorado (já fornecido no artifact)
Plano de Ação de Diagnóstico

Preciso focar nas principais hipóteses e fornecer um plano de ação prático para diagnóstico.3. Plano de Ação de Diagnóstico
Se após implementar as correções do código refatorado o problema persistir, siga este plano diagnóstico passo a passo:
Fase 1: Diagnóstico Local dos Certificados
Passo 1: Validar Certificados Localmente
bash# Salve seus certificados em arquivos temporários
echo "$INTER_CERTIFICATE" > cert.pem
echo "$INTER_PRIVATE_KEY" > key.pem

# Validar formato PEM
openssl x509 -in cert.pem -text -noout
openssl rsa -in key.pem -check -noout

# Validar se certificado e chave correspondem
cert_modulus=$(openssl x509 -noout -modulus -in cert.pem | openssl md5)
key_modulus=$(openssl rsa -noout -modulus -in key.pem | openssl md5)
echo "Cert modulus: $cert_modulus"
echo "Key modulus: $key_modulus"
# Devem ser idênticos
Passo 2: Testar Conectividade TLS
bash# Testar handshake TLS com certificado
openssl s_client -connect cdpj.partners.bancointer.com.br:443 \
  -cert cert.pem -key key.pem -showcerts -verify_return_error

# Verificar se a conexão é estabelecida sem erros
Fase 2: Teste com cURL (Replicação Exata)
Passo 3: Comando cURL Completo para Token
bash# Teste de obtenção de token OAuth2 com mTLS
curl -v -X POST "https://cdpj.partners.bancointer.com.br/oauth/v2/token" \
  --cert cert.pem \
  --key key.pem \
  --header "Content-Type: application/x-www-form-urlencoded" \
  --header "Accept: application/json" \
  --header "User-Agent: SIMPIX-Inter-Integration/1.0" \
  --data-urlencode "client_id=SEU_CLIENT_ID" \
  --data-urlencode "client_secret=SEU_CLIENT_SECRET" \
  --data-urlencode "grant_type=client_credentials" \
  --data-urlencode "scope=boleto-cobranca.read boleto-cobranca.write webhook.read webhook.write" \
  --connect-timeout 30 \
  --max-time 60
Passo 4: Comando cURL para Criação de Cobrança
bash# Salvar token obtido no passo anterior
TOKEN="SEU_TOKEN_AQUI"

# Criar cobrança com payload exato
curl -v -X POST "https://cdpj.partners.bancointer.com.br/cobranca/v3/cobrancas" \
  --cert cert.pem \
  --key key.pem \
  --header "Authorization: Bearer $TOKEN" \
  --header "Content-Type: application/json" \
  --header "Accept: application/json" \
  --header "User-Agent: SIMPIX-Inter-Integration/1.0" \
  --header "x-conta-corrente: SUA_CONTA_CORRENTE" \
  --header "x-inter-conta-corrente: SUA_CONTA_CORRENTE" \
  --data '{
    "seuNumero": "TEST-12345",
    "valorNominal": 100.00,
    "dataEmissao": "2025-08-04",
    "dataVencimento": "2025-08-09",
    "numDiasAgenda": 30,
    "pagador": {
      "nome": "Teste da Silva",
      "cpfCnpj": "12345678901",
      "tipoPessoa": "FISICA",
      "email": "teste@exemplo.com",
      "ddd": "11",
      "telefone": "999999999",
      "endereco": "Rua de Teste",
      "numero": "100",
      "bairro": "Centro",
      "cidade": "São Paulo",
      "uf": "SP",
      "cep": "01000000"
    },
    "desconto": {
      "codigo": "PERCENTUALDATAINFORMADA",
      "taxa": 0,
      "quantidadeDias": 0
    },
    "multa": {
      "codigo": "PERCENTUAL",
      "taxa": 2.00
    },
    "mora": {
      "codigo": "TAXAMENSAL",
      "taxa": 1.00
    },
    "formasRecebimento": ["BOLETO", "PIX"]
  }' \
  --connect-timeout 30 \
  --max-time 60
Fase 3: Diagnóstico Avançado
Passo 5: Monitoramento de Rede
bash# Capturar tráfego de rede para análise detalhada
sudo tcpdump -i any -w inter_debug.pcap host cdpj.partners.bancointer.com.br

# Em paralelo, execute seu teste Node.js
# Analise o arquivo .pcap com Wireshark para ver o handshake TLS
Passo 6: Teste com Diferentes User-Agents e Headers
bash# Teste com User-Agent diferente
curl -v -X POST "https://cdpj.partners.bancointer.com.br/oauth/v2/token" \
  --cert cert.pem \
  --key key.pem \
  --header "User-Agent: Mozilla/5.0 (compatible; Inter-API-Client/1.0)" \
  [... outros headers iguais ...]

# Teste sem headers opcionais
curl -v -X POST "https://cdpj.partners.bancointer.com.br/oauth/v2/token" \
  --cert cert.pem \
  --key key.pem \
  --header "Content-Type: application/x-www-form-urlencoded" \
  --header "Accept: application/json" \
  [... apenas headers mínimos ...]
Fase 4: Testes de Ambiente
Passo 7: Comparação Sandbox vs. Produção
bash# Teste no ambiente sandbox primeiro
curl -v -X POST "https://cdpj-sandbox.partners.uatinter.co/oauth/v2/token" \
  --cert cert.pem \
  --key key.pem \
  [... mesmos parâmetros ...]

# Compare comportamento entre sandbox e produção
Passo 8: Verificação de IP e Firewall
bash# Verificar seu IP público
curl -s https://ipinfo.io/ip

# Testar conectividade básica
telnet cdpj.partners.bancointer.com.br 443

# Verificar se há bloqueios de firewall
nmap -p 443 cdpj.partners.bancointer.com.br
Fase 5: Contato com Suporte Técnico
Se todos os testes anteriores falharem, prepare um relatório completo para o suporte técnico do Banco Inter incluindo:

Logs completos dos testes cURL
Certificados validados (sem mostrar a chave privada)
IP de origem das requisições
Headers de resposta capturados (especialmente traceparent, server, etc.)
Timestamps exatos dos testes
Comparação entre sandbox e produção

Informações específicas para incluir no ticket de suporte:

Conta corrente: 346470536
Environment: Production
API Version: v3
Error Pattern: HTTP 400 with empty body
Client ID: (primeiros 8 caracteres)
Test timestamp e traceparent headers

Checklist de Verificação Rápida
Antes de implementar o plano completo, verifique rapidamente:
✅ Certificados válidos e não expirados
✅ Conta corrente ativa e com permissões para API v3
✅ Client ID/Secret corretos para ambiente de produção
✅ IP do servidor não está em blacklist
✅ Headers específicos da API v3 estão sendo enviados
✅ Payload JSON está exatamente conforme documentação
✅ Timeout adequado para requests mTLS (30+ segundos)
A implementação do código refatorado que forneci deve resolver a maioria dos problemas relacionados à configuração mTLS e formatação de dados. Se o problema persistir após essas mudanças, o plano diagnóstico ajudará a identificar se é um problema de infraestrutura, configuração de conta, ou alguma restrição específica da API v3 do Banco Inter.