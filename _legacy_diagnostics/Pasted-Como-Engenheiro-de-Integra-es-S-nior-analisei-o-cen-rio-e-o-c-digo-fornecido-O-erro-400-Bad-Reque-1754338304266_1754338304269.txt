Como Engenheiro de Integra√ß√µes S√™nior, analisei o cen√°rio e o c√≥digo fornecido. O erro 400 Bad Request com corpo vazio √© um sintoma cl√°ssico e frustrante, geralmente indicando uma falha na camada de transporte (mTLS) ou no gateway da API, antes que a l√≥gica da aplica√ß√£o possa processar o payload e retornar um erro estruturado em JSON.

A sua depura√ß√£o foi minuciosa, mas o problema reside em uma sutil, por√©m cr√≠tica, inconsist√™ncia na forma como as requisi√ß√µes mTLS s√£o tratadas no seu servi√ßo.

1. An√°lise da Causa Raiz
A causa raiz do problema √© dupla, consistindo em uma falha cr√≠tica na camada de transporte e m√∫ltiplos erros na constru√ß√£o do payload.

Causa Prim√°ria: Falha na Negocia√ß√£o mTLS na Requisi√ß√£o de Cobran√ßa

O diagn√≥stico principal √© que a sua fun√ß√£o makeRequest n√£o est√° utilizando a configura√ß√£o mTLS.

Autentica√ß√£o vs. Opera√ß√£o: A sua fun√ß√£o getAccessToken configura corretamente um undici.Agent com os certificados mTLS e o utiliza para obter o token de autentica√ß√£o. √â por isso que o OAuth2 funciona perfeitamente.

Falha na Requisi√ß√£o Subsequente: No entanto, a fun√ß√£o makeRequest, que √© usada para todas as outras chamadas √† API (incluindo emitirCobranca), utiliza o fetch global do Node.js sem passar o agente mTLS (dispatcher).

Consequ√™ncia: A requisi√ß√£o POST /cobranca/v3/cobrancas √© enviada sem o certificado de cliente. O gateway da API do Banco Inter, esperando uma conex√£o mTLS, n√£o recebe o certificado, resultando em uma falha no handshake TLS. Ele rejeita a conex√£o imediatamente com um erro gen√©rico 400 Bad Request e fecha a conex√£o antes que qualquer corpo de resposta possa ser enviado. Isso explica perfeitamente a aus√™ncia de um corpo de erro em JSON.

Causas Secund√°rias: Erros Cr√≠ticos no Payload JSON

Mesmo que o problema de mTLS fosse corrigido, a sua requisi√ß√£o ainda falharia devido a erros estruturais no payload enviado para a API v3:

Campo Inv√°lido dataEmissao: A documenta√ß√£o da API de Cobran√ßa v3 n√£o inclui o campo dataEmissao no corpo da requisi√ß√£o para cria√ß√£o de boletos. A sua presen√ßa causa uma falha de valida√ß√£o.  ¬† 

Campo Inv√°lido formasRecebimento: Este campo n√£o existe na especifica√ß√£o da API de Cobran√ßa v3 e deve ser removido.  ¬† 

Estrutura de desconto Incorreta: O objeto desconto no seu c√≥digo utiliza o campo quantidadeDias, que n√£o √© compat√≠vel com o codigo: 'PERCENTUALDATAINFORMADA'. Este c√≥digo exige um campo data (string no formato YYYY-MM-DD) para especificar at√© quando o desconto √© v√°lido.  ¬† 

Manipula√ß√£o de valorNominal: A fun√ß√£o customStringify √© uma solu√ß√£o complexa e fr√°gil para um problema que n√£o deveria existir. O JSON.stringify nativo lida corretamente com n√∫meros. O valor deve ser um tipo number com at√© duas casas decimais (ex: 1000.00) diretamente no objeto JavaScript.

2. C√≥digo Refatorado (interBankService.ts)
A seguir, apresento uma vers√£o refatorada do interBankService.ts. As mudan√ßas corrigem a falha de mTLS, os erros de payload e melhoram a estrutura geral, a resili√™ncia e a capacidade de depura√ß√£o do servi√ßo.

Principais Melhorias:

Agente mTLS Centralizado: Um √∫nico UndiciAgent √© criado no construtor e reutilizado para todas as requisi√ß√µes, garantindo que o mTLS seja aplicado consistentemente.

L√≥gica de Certificado Isolada: A formata√ß√£o dos certificados PEM foi movida para uma fun√ß√£o utilit√°ria (formatPem), tornando o c√≥digo mais limpo e test√°vel.

makeRequest Corrigido: A fun√ß√£o agora recebe e utiliza o dispatcher mTLS em todas as chamadas fetch.

Remo√ß√£o de Hacks: A fun√ß√£o customStringify foi removida.

Payload Corrigido: A fun√ß√£o criarCobrancaParaProposta foi ajustada para gerar um payload 100% compat√≠vel com a API v3.

Tratamento de Erros Aprimorado: O bloco catch agora loga os headers da resposta, o que pode fornecer trace-ids valiosos para o suporte do banco, mesmo com corpo vazio.

TypeScript

// server/services/interBankService.ts (Refatorado)

import { Agent as UndiciAgent, request } from 'undici';
import { URLSearchParams } from 'url';

// --- Interfaces (sem altera√ß√µes) ---
//... (mantenha todas as interfaces como no original)
interface InterBankConfig {
  apiUrl: string;
  clientId: string;
  clientSecret: string;
  certificate: string;
  privateKey: string;
  contaCorrente?: string;
  environment: 'sandbox' | 'production';
}

interface InterTokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  scope: string;
}

interface ClientData {
  cpfCnpj: string;
  tipoPessoa: 'FISICA' | 'JURIDICA';
  nome: string;
  email?: string;
  ddd?: string;
  telefone?: string;
  endereco: string;
  numero: string;
  complemento?: string;
  bairro: string;
  cidade: string;
  uf: string;
  cep: string;
}

interface CobrancaRequest {
  seuNumero: string;
  valorNominal: number;
  dataVencimento: string;
  numDiasAgenda: number;
  pagador: ClientData;
  desconto?: {
    codigo: 'VALORFIXODATAINFORMADA' | 'PERCENTUALDATAINFORMADA';
    data: string; // Corrigido: 'data' √© obrigat√≥rio para estes c√≥digos
    taxa: number;
  };
  multa?: {
    codigo: 'VALORFIXO' | 'PERCENTUAL';
    taxa: number;
  };
  mora?: {
    codigo: 'TAXAMENSAL' | 'VALORDIA'; // Corrigido: TAXADIARIA n√£o √© um enum v√°lido
    taxa: number;
  };
  mensagem?: {
    linha1?: string;
    linha2?: string;
    linha3?: string;
    linha4?: string;
    linha5?: string;
  };
}

//... (demais interfaces)

/**
 * Formata uma chave ou certificado PEM de linha √∫nica para o formato multi-linha
 * exigido pelo Node.js.
 * @param pemContent O conte√∫do PEM em linha √∫nica.
 * @returns O conte√∫do PEM formatado corretamente.
 */
const formatPem = (pemContent: string): string => {
  if (!pemContent |

| pemContent.includes('\n')) {
    return pemContent; // Retorna se vazio ou j√° formatado
  }

  const pemType = pemContent.includes('CERTIFICATE')? 'CERTIFICATE' : 'PRIVATE KEY';
  const match = pemContent.match(new RegExp(`-----BEGIN (.*?)-----(.*?)-----END (.*?)-----`));

  if (match && match[1]) {
    const header = `-----BEGIN ${match[2]}-----`;
    const footer = `-----END ${match[3]}-----`;
    const base64Content = match.[1]trim();
    const formattedContent = base64Content.match(/.{1,64}/g)?.join('\n') |

| base64Content;
    return `${header}\n${formattedContent}\n${footer}`;
  }

  console.warn(` ‚ö†Ô∏è Falha ao formatar conte√∫do PEM para: ${pemType}`);
  return pemContent;
};


class InterBankService {
  private config: InterBankConfig;
  private mTLSDispatcher: UndiciAgent;
  private tokenCache: {
    token: string;
    expiresAt: number;
  } | null = null;

  constructor() {
    const isProduction =!!process.env.INTER_CONTA_CORRENTE;

    this.config = {
      environment: isProduction? 'production' : 'sandbox',
      apiUrl: isProduction
       ? 'https://cdpj.partners.bancointer.com.br'
        : 'https://cdpj-sandbox.partners.uatinter.co',
      clientId: process.env.INTER_CLIENT_ID |

| '',
      clientSecret: process.env.INTER_CLIENT_SECRET |

| '',
      certificate: process.env.INTER_CERTIFICATE |

| '',
      privateKey: process.env.INTER_PRIVATE_KEY |

| '',
      contaCorrente: process.env.INTER_CONTA_CORRENTE |

| ''
    };

    if (!this.config.clientId ||!this.config.clientSecret ||!this.config.certificate ||!this.config.privateKey) {
      console.error(' ‚ùå Credenciais, certificados ou chave privada n√£o configurados. A integra√ß√£o falhar√°.');
    }

    // CR√çTICO: Cria um agente mTLS centralizado para ser usado em TODAS as requisi√ß√µes
    this.mTLSDispatcher = new UndiciAgent({
      connect: {
        cert: formatPem(this.config.certificate),
        key: formatPem(this.config.privateKey),
        rejectUnauthorized: this.config.environment === 'production' // Valida o certificado em produ√ß√£o
      }
    });

    console.log(` üè¶ Servi√ßo inicializado em modo ${this.config.environment}.`);
  }

  /**
   * Obt√©m um token de acesso OAuth2, utilizando cache.
   */
  private async getAccessToken(): Promise<string> {
    if (this.tokenCache && Date.now() < this.tokenCache.expiresAt) {
      return this.tokenCache.token;
    }

    console.log(' üîë Solicitando novo token de acesso...');

    const formBody = new URLSearchParams({
      'client_id': this.config.clientId,
      'client_secret': this.config.clientSecret,
      'grant_type': 'client_credentials',
      'scope': 'boleto-cobranca.read boleto-cobranca.write webhook.read webhook.write'
    });

    try {
      const response = await request(`${this.config.apiUrl}/oauth/v2/token`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: formBody.toString(),
        dispatcher: this.mTLSDispatcher // Utiliza o agente mTLS
      });

      if (response.statusCode!== 200) {
        const errorBody = await response.body.text();
        throw new Error(`Falha ao obter token: ${response.statusCode} - ${errorBody}`);
      }

      const tokenData: InterTokenResponse = await response.body.json();

      // Cache com 5 minutos de margem
      this.tokenCache = {
        token: tokenData.access_token,
        expiresAt: Date.now() + ((tokenData.expires_in - 300) * 1000)
      };

      console.log(` ‚úÖ Token de acesso obtido com sucesso.`);
      return tokenData.access_token;

    } catch (error) {
      console.error(' ‚ùå Erro catastr√≥fico ao obter token de acesso:', error);
      throw error;
    }
  }

  /**
   * Realiza uma requisi√ß√£o autenticada e com mTLS para a API do Inter.
   * Esta √© a fun√ß√£o central que garante a configura√ß√£o correta para todas as chamadas.
   */
  private async makeRequest<T>(endpoint: string, method: 'GET' | 'POST' | 'PATCH' | 'DELETE' | 'PUT' = 'GET', data?: any): Promise<T> {
    const token = await this.getAccessToken();
    const url = `${this.config.apiUrl}${endpoint}`;

    const headers: Record<string, string> = {
      'Authorization': `Bearer ${token}`,
      'Accept': 'application/json'
    };

    if (this.config.contaCorrente) {
      headers['x-conta-corrente'] = this.config.contaCorrente;
    } else {
      // Em produ√ß√£o, a conta corrente √© essencial.
      if (this.config.environment === 'production') {
        console.error(' ‚ùå ERRO CR√çTICO: x-conta-corrente n√£o configurado para ambiente de produ√ß√£o.');
        throw new Error('x-conta-corrente √© obrigat√≥rio em produ√ß√£o.');
      }
    }

    const options: Parameters<typeof request>[2] = {
      method,
      headers,
      dispatcher: this.mTLSDispatcher // CR√çTICO: Aplica mTLS a esta requisi√ß√£o
    };

    if (data && (method === 'POST' |

| method === 'PATCH' |
| method === 'PUT')) {
      headers = 'application/json; charset=utf-8';
      options.body = JSON.stringify(data); // Usa o stringify padr√£o
    }

    console.log(` -> ${method} ${url}`);
    if (options.body) {
      console.log(' -> Payload:', options.body);
    }

    try {
      const response = await request(url, options);

      console.log(` <- ${response.statusCode} ${method} ${url}`);

      // Para DELETE ou respostas sem conte√∫do
      if (response.statusCode === 204) {
        return { success: true } as T;
      }

      const responseText = await response.body.text();

      if (response.statusCode < 200 |

| response.statusCode >= 300) {
        console.error('---------- IN√çCIO ERRO INTER API ----------');
        console.error(` üö® Status: ${response.statusCode}`);
        console.error(' üö® Headers da Resposta:', response.headers); // Loga headers para obter trace-id
        console.error(` üö® Corpo do Erro: "${responseText}"`);
        console.error('----------- FIM ERRO INTER API -----------');
        throw new Error(`Erro na API do Inter: ${response.statusCode} - ${responseText |

| 'Corpo vazio'}`);
      }
      
      // Retorna o texto puro se n√£o for JSON v√°lido (ex: PDF)
      try {
        return JSON.parse(responseText) as T;
      } catch {
        return responseText as T;
      }

    } catch (error) {
      console.error(` ‚ùå Falha na requisi√ß√£o para ${endpoint}:`, error);
      throw error;
    }
  }

  /**
   * Cria uma cobran√ßa para uma proposta, montando o payload de acordo com a API v3.
   */
  async criarCobrancaParaProposta(proposalData: {
    id: string;
    valorTotal: number;
    dataVencimento: string;
    clienteData: ClientData;
  }): Promise<CobrancaResponse> {
    console.log(' üöÄ Criando cobran√ßa para proposta:', proposalData.id);

    // Gera um identificador √∫nico para a cobran√ßa
    const seuNumero = `${proposalData.id.substring(0, 13)}-${Date.now().toString().slice(-1)}`;

    // Garante que o valor est√° no formato num√©rico correto
    const valorNominal = parseFloat(proposalData.valorTotal.toFixed(2));

    // Limpa e formata dados do pagador
    const pagadorLimpo: ClientData = {
     ...proposalData.clienteData,
      cpfCnpj: proposalData.clienteData.cpfCnpj.replace(/\D/g, ''),
      cep: proposalData.clienteData.cep.replace(/\D/g, ''),
      nome: proposalData.clienteData.nome.trim(),
      endereco: proposalData.clienteData.endereco.trim(),
      bairro: proposalData.clienteData.bairro.trim(),
      cidade: proposalData.clienteData.cidade.trim(),
    };

    // Monta o payload ESTRITAMENTE de acordo com a documenta√ß√£o da API v3
    const cobrancaData: CobrancaRequest = {
      seuNumero,
      valorNominal,
      dataVencimento: proposalData.dataVencimento,
      numDiasAgenda: 30, // Permanecer ativa por 30 dias ap√≥s vencimento
      pagador: pagadorLimpo,
      multa: {
        codigo: 'PERCENTUAL',
        taxa: 2.00
      },
      mora: {
        codigo: 'TAXAMENSAL',
        taxa: 1.00
      },
      mensagem: {
        linha1: `Ref. Proposta: ${proposalData.id}`,
        linha2: 'Pague via PIX ou boleto banc√°rio.',
        linha3: 'D√∫vidas: contato@simpix.com.br'
      }
    };

    // REMOVIDO: dataEmissao - Campo inv√°lido na requisi√ß√£o
    // REMOVIDO: formasRecebimento - Campo inv√°lido na requisi√ß√£o
    // REMOVIDO: desconto - Opcional, e a estrutura estava incorreta. Adicionar apenas se necess√°rio e com a estrutura correta (com 'data').

    return this.makeRequest<CobrancaResponse>('/cobranca/v3/cobrancas', 'POST', cobrancaData);
  }

  // --- Mantenha os outros m√©todos do servi√ßo (recuperarCobranca, pesquisarCobrancas, etc.) ---
  // Eles agora usar√£o automaticamente o `makeRequest` refatorado e funcionar√£o corretamente.
  //...
}

export const interBankService = new InterBankService();
3. Plano de A√ß√£o de Diagn√≥stico
Se, ap√≥s aplicar o c√≥digo refatorado, o erro persistir, siga estes passos para um diagn√≥stico definitivo, isolando o problema da sua aplica√ß√£o Node.js.

Passo 1: Validar Vari√°veis de Ambiente

Certifique-se de que as vari√°veis de ambiente no seu servidor de produ√ß√£o est√£o corretas e acess√≠veis pelo processo Node.js:

INTER_CLIENT_ID

INTER_CLIENT_SECRET

INTER_CERTIFICATE (o conte√∫do completo do arquivo.crt, pode ser em linha √∫nica)

INTER_PRIVATE_KEY (o conte√∫do completo do arquivo.key, pode ser em linha √∫nica)

INTER_CONTA_CORRENTE (o n√∫mero da sua conta corrente)

Passo 2: Preparar Arquivos para curl

No seu servidor, crie os seguintes arquivos no mesmo diret√≥rio:

cert.pem: Cole o conte√∫do da sua vari√°vel INTER_CERTIFICATE neste arquivo.

key.pem: Cole o conte√∫do da sua vari√°vel INTER_PRIVATE_KEY neste arquivo.

payload.json: Crie um arquivo com o payload JSON corrigido.

JSON

{
  "seuNumero": "curl-teste-001",
  "valorNominal": 10.50,
  "dataVencimento": "2025-12-25",
  "numDiasAgenda": 30,
  "pagador": {
    "cpfCnpj": "20528464760",
    "tipoPessoa": "FISICA",
    "nome": "Teste Curl de Jesus",
    "endereco": "Rua do Teste",
    "numero": "123",
    "bairro": "Centro",
    "cidade": "Serra",
    "uf": "ES",
    "cep": "29165460"
  },
  "multa": {
    "codigo": "PERCENTUAL",
    "taxa": 2.0
  },
  "mora": {
    "codigo": "TAXAMENSAL",
    "taxa": 1.0
  }
}
Passo 3: Executar o Comando curl

Execute o comando curl abaixo, substituindo os placeholders <SEU_TOKEN> e <SUA_CONTA_CORRENTE>. Voc√™ pode obter um token v√°lido executando a sua aplica√ß√£o com o c√≥digo refatorado uma vez e copiando o token do log.

Bash

curl -v -X POST https://cdpj.partners.bancointer.com.br/cobranca/v3/cobrancas \
--cert./cert.pem \
--key./key.pem \
-H "Authorization: Bearer <SEU_TOKEN>" \
-H "x-conta-corrente: <SUA_CONTA_CORRENTE>" \
-H "Content-Type: application/json" \
-d @payload.json
An√°lise do Resultado do curl:

-v (verbose): A flag mais importante. Ela mostrar√° toda a negocia√ß√£o TLS.

Sucesso: Se voc√™ vir linhas como * SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384 e * Server certificate verify OK, e receber uma resposta 200 OK com um codigoSolicitacao, significa que suas credenciais e o payload est√£o corretos. O problema estava 100% na aplica√ß√£o Node.js, que o c√≥digo refatorado resolve.

Falha: Se o curl falhar com um erro de handshake, peer did not return a certificate, ou similar, o problema est√° nos seus arquivos de certificado/chave ou em alguma restri√ß√£o de firewall/rede no seu servidor. Se falhar com um 400 Bad Request e um corpo de erro JSON, analise as viola√ß√µes reportadas para ajustar o payload.json.