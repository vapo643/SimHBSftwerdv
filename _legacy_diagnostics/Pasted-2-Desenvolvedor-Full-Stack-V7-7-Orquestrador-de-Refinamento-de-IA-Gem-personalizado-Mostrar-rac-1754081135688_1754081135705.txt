2° - Desenvolvedor Full-Stack V7.7- Orquestrador de Refinamento de IA
Gem personalizado

Mostrar raciocínio
Debugging the API Interaction

I'm zeroing in on the inconsistent error messages. It seems the API's validation logic is tangled, potentially expecting both content and content_base64 simultaneously or misinterpreting the provided data. I'm focusing on the JSON:API structure and headers. I'll meticulously review the request payload to ensure it adheres to the expected format, looking at the JSON:API specifications.

Pinpointing the Endpoint Mismatch

Now, I'm focusing on the API's endpoint interactions. It seems like I might be using the wrong method. The API likely requires using a different endpoint for adding a document to an existing envelope, not the one for creating documents. I am now meticulously examining the API documentation to identify the correct endpoint, payload format, and any necessary headers. I must find the proper way to add the document as an attachment.

Unveiling the Root Cause

I'm now focusing on the core issue: the API validation. The contradictory messages about content and content_base64 imply internal inconsistencies. It appears the documentation is misaligned with the API's internal requirements. I'm exploring the hypothesis that the API expects the document data within the envelope's creation structure, rather than as a separate 'document' resource, as currently attempted.

Isolating the Root Cause

I'm now focusing on the data format and structure. The contradictory messages about content and content_base64, plus the MIME type error, point to a data-format issue. I'm hypothesizing that the API expects the document data to be nested within the envelope creation structure and possibly in a Data URI format with MIME type included, which would strictly adhere to the JSON:API standards.

Unraveling the Payload Structure

After intense analysis, the solution is becoming clearer. I'm focusing on crafting a payload that correctly reflects the JSON:API specification and the specific requirements of the ClickSign V3 API. The root problem now seems to be a mismatch between the expected structure and the format of the provided data, specifically the Base64 encoding. I believe I need to construct the document data within an envelope creation structure and include the correct Data URI prefix.

Refining the Envelope Payload

Now, I'm adjusting the payload structure for accurate envelope creation. It's clear that incorporating the document data directly during envelope creation, as an attribute, is the way to go, within a strict JSON:API format. I'm focusing on the data and attributes structure.

Esta é uma análise profunda (Deep Think) focada em diagnosticar e resolver definitivamente as falhas de integração com a API V3 da ClickSign. A situação que você enfrenta – erros contraditórios sobre campos obrigatórios e requisitos de MimeType – aponta para uma combinação de problemas no formato dos dados e na estrutura do fluxo de trabalho.

Vamos dissecar a evidência e formular a estratégia de resolução definitiva.

1. Análise dos Erros: A Contradição e a Evidência Crítica
Os erros parecem contraditórios, mas revelam a lógica interna (embora confusa) do validador da API:

Erro 1: content_base64 deve ser informado(a) (quando usa content)

Erro 2: content - não pode ficar em branco (quando usa content_base64)

Estes erros cruzados ocorrem quando a API não consegue validar com sucesso nenhum dos campos fornecidos. Ela tenta validar o Campo A, falha (devido a formato incorreto), tenta o Campo B, falha, e retorna uma mensagem de erro padrão ou confusa sobre qual campo está em falta.

A Evidência Crítica (O "Smoking Gun"): Erro 3

Erro 3: MimeType não informado no campo content_base64

Este erro é a chave. Ele informa inequivocamente:

A API está a tentar processar o campo content_base64.

A API NÃO ACEITA Base64 puro. Ela exige que a string Base64 inclua o prefixo MimeType, ou seja, deve estar no formato Data URI Scheme.

Diagnóstico Técnico: A causa imediata da falha de validação é o formato do Base64.

Incorreto (Puro): JVBERi0xLjQKJ...

Correto (Data URI): data:application/pdf;base64,JVBERi0xLjQKJ...

2. Análise do Fluxo de Processo (O Problema Arquitetural)
Além do formato dos dados, há um problema potencial no seu fluxo de trabalho:

Criar envelope (✅ FUNCIONANDO)

Adicionar documento ao envelope (❌ FALHANDO)

Você está a usar Content-Type: application/vnd.api+json, indicando que a API segue o padrão JSON:API. Na arquitetura da API V3 da ClickSign (e no padrão JSON:API), geralmente não se cria um envelope vazio e se adicionam documentos depois.

O fluxo correto é atómico: criar o envelope e fazer o upload dos documentos numa única chamada para POST /api/v3/envelopes.

O seu Passo 1 pode estar a retornar sucesso, mas está a criar um envelope vazio. O Passo 2 está a falhar porque o método para adicionar documentos após a criação pode não ser suportado da forma que você espera.

3. A Estrutura Correta do Payload (A Solução Definitiva)
A solução requer a combinação do fluxo correto (criação atómica) com o formato correto (Data URI).

Existem duas formas principais de fazer isso no JSON:API: através de atributos aninhados (simplificado) ou através de Documentos Compostos (padrão estrito).

Hipótese Principal: Estrutura Simplificada (Mais Provável para ClickSign)
Muitas implementações JSON:API permitem aninhar recursos relacionados diretamente nos attributes para simplificar a criação.

TypeScript

const rawBase64Content = "..."; // Seu PDF em Base64 puro do Supabase
const dataUriContent = `data:application/pdf;base64,${rawBase64Content}`;

const requestBody = {
  // 1. O recurso principal é o envelope
  "data": {
    "type": "envelopes",
    "attributes": {
      "name": `Envelope CCB - Proposta ${proposalId}`,
      // ... outros atributos do envelope (deadline_at, requester, etc.)

      // 2. Documentos são incluídos aqui como um array
      "documents": [
        {
          "filename": `ccb_proposta_${proposalId}.pdf`,
          // 3. Usar content_base64 com o formato Data URI completo
          "content_base64": dataUriContent
        }
      ]
    }
  }
};

// Enviar para POST /api/v3/envelopes
Hipótese Secundária: JSON:API Estrito (Compound Documents)
Se a hipótese principal falhar, a API pode exigir o padrão estrito, usando relationships e included.

JSON

const requestBody = {
  "data": {
    "type": "envelopes",
    "attributes": {
      "name": `Envelope CCB - Proposta ${proposalId}`
    },
    "relationships": {
      "documents": {
        // Referência a um ID temporário que será definido abaixo
        "data": [{ "type": "documents", "id": "temp-doc-1" }]
      }
    }
  },
  "included": [
    {
      "type": "documents",
      "id": "temp-doc-1", // Deve corresponder ao ID acima
      "attributes": {
        "filename": `ccb_proposta_${proposalId}.pdf`,
        "content_base64": dataUriContent // Data URI completo
      }
    }
  ]
};
4. Debugging Estratégico e Sequência de Testes
Teste a Hipótese Principal: Implemente a criação unificada (Envelope + Documento) usando a estrutura simplificada (atributos aninhados) e o formato Data URI correto. Esta é a solução mais provável.

Teste a Hipótese Secundária: Se o Teste 1 falhar, tente a estrutura de Compound Document.

Verificação do Nome do Campo: Se continuar a receber erros sobre content vs content_base64, confie no Erro 3 que mencionou content_base64. Se, por algum motivo improvável, a API mudar o erro para exigir content, troque o nome do campo, mas mantenha o formato Data URI.

5. Alternativas de Implementação
Templates (Altamente Recomendado): Para documentos padronizados como CCBs, usar a funcionalidade de Templates da ClickSign é muito superior. Você faz o upload do PDF uma vez, define os campos variáveis e obtém um template_id. Na criação do envelope, você envia apenas o ID e os dados variáveis. Isso evita o overhead de codificar e enviar Base64 em todos os requests, sendo muito mais eficiente.

6. Meta-Pergunta: Como Abordar Sistematicamente APIs Inconsistentes?
Quando a documentação oficial diverge do comportamento real da API, a abordagem muda para "engenharia reversa baseada em evidências":

A Evidência do Erro é a Verdade Suprema: Confie na mensagem de erro mais específica da API, não na documentação. O Erro 3 (MimeType não informado) foi a evidência irrefutável que ditou a necessidade do Data URI.

Entender o Padrão Arquitetural Declarado: Se a API declara usar JSON:API (via headers), você deve entender os padrões desse standard (ex: Compound Documents, estrutura data/attributes/relationships). A documentação pode simplificar exemplos, mas a API pode exigir o padrão completo.

Isolar e Minimizar (MVP - Minimum Viable Payload): Use Postman ou cURL para enviar o payload mínimo necessário para obter sucesso. Remova todos os campos opcionais.

Inspecionar o Tráfego de Rede (HAR Analysis): Se o fornecedor tiver uma interface web funcional (ex: o dashboard da ClickSign), execute a ação na UI e inspecione a aba "Network" das Developer Tools. Isso revela o contrato exato (headers e payload) que a própria aplicação deles utiliza.

Teste Padrões Comuns de Input: Para uploads via JSON, as opções são limitadas (Base64 puro ou Data URI). Se um falha, teste o outro imediatamente.