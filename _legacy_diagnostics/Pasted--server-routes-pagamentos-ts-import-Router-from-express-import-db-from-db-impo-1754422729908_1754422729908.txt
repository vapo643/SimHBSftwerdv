// server/routes/pagamentos.ts
import { Router } from 'express';
import { db } from '../db';
import { propostas, interCollections } from '../../shared/schema';
import { and, eq, inArray, sql } from 'drizzle-orm';
import { authMiddleware } from '../middleware/auth';

const router = Router();

router.get('/api/pagamentos', authMiddleware, async (req, res) => {
  try {
    console.log('[PAGAMENTOS DEBUG] Iniciando busca de pagamentos...');
    
    // ESTRATÉGIA: Busca em duas etapas para evitar problemas de tipo
    // Isso também melhora a performance e facilita o debug
    
    // Etapa 1: Buscar IDs de propostas que têm boletos Inter gerados
    const propostasComBoletos = await db
      .select({ 
        propostaId: interCollections.propostaId,
        boletoId: interCollections.id,
        numeroBoleto: interCollections.numeroTitulo
      })
      .from(interCollections)
      .where(
        and(
          // Adicione aqui filtros específicos para boletos válidos
          sql`${interCollections.propostaId} IS NOT NULL`,
          sql`LENGTH(${interCollections.propostaId}) = 36` // Validação básica de UUID
        )
      );

    console.log(`[PAGAMENTOS DEBUG] Encontradas ${propostasComBoletos.length} propostas com boletos`);

    if (propostasComBoletos.length === 0) {
      return res.json({ 
        pagamentos: [], 
        total: 0,
        debug: 'Nenhuma proposta com boletos encontrada'
      });
    }

    // Extrair e validar os IDs das propostas
    const propostaIds = propostasComBoletos
      .map(item => item.propostaId)
      .filter(id => {
        // Validação extra para garantir que são UUIDs válidos
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return id && uuidRegex.test(id);
      });

    console.log(`[PAGAMENTOS DEBUG] IDs válidos de propostas: ${propostaIds.length}`);

    if (propostaIds.length === 0) {
      return res.json({ 
        pagamentos: [], 
        total: 0,
        debug: 'Nenhum ID de proposta válido encontrado'
      });
    }

    // Etapa 2: Buscar as propostas elegíveis para pagamento
    // Usando conversão explícita de tipos para garantir compatibilidade
    const propostas = await db
      .select({
        id: propostas.id,
        clienteNome: propostas.clienteNome,
        cpf: propostas.cpf,
        valorSolicitado: propostas.valorSolicitado,
        valorAprovado: propostas.valorAprovado,
        status: propostas.status,
        ccbGerado: propostas.ccbGerado,
        assinaturaEletronicaConcluida: propostas.assinaturaEletronicaConcluida,
        dataAtualizacao: propostas.updatedAt
      })
      .from(propostas)
      .where(
        and(
          // Converte os IDs text para UUID para comparação segura
          sql`${propostas.id}::text = ANY(${propostaIds})`,
          eq(propostas.status, 'pronto_pagamento'),
          eq(propostas.ccbGerado, true),
          eq(propostas.assinaturaEletronicaConcluida, true)
        )
      );

    console.log(`[PAGAMENTOS DEBUG] Propostas elegíveis encontradas: ${propostas.length}`);

    // Etapa 3: Enriquecer com informações dos boletos
    const pagamentos = propostas.map(proposta => {
      const boletoInfo = propostasComBoletos.find(
        boleto => boleto.propostaId === proposta.id.toString()
      );

      return {
        ...proposta,
        boleto: {
          id: boletoInfo?.boletoId,
          numero: boletoInfo?.numeroBoleto
        }
      };
    });

    console.log(`[PAGAMENTOS DEBUG] Pagamentos finais preparados: ${pagamentos.length}`);

    // Aplicar filtros de segurança baseados no role do usuário
    const userRole = req.user?.role;
    let pagamentosFiltrados = pagamentos;

    if (userRole === 'ATENDENTE') {
      // Atendentes só veem propostas de seus clientes
      // Implementar lógica de filtro por atendente se necessário
      console.log('[PAGAMENTOS DEBUG] Aplicando filtro de atendente');
    }

    res.json({
      pagamentos: pagamentosFiltrados,
      total: pagamentosFiltrados.length,
      debug: {
        totalPropostasComBoletos: propostasComBoletos.length,
        totalPropostasElegiveis: propostas.length,
        userRole: userRole
      }
    });

  } catch (error) {
    console.error('[PAGAMENTOS ERROR] Erro detalhado:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });

    res.status(500).json({
      error: 'Erro interno do servidor',
      debug: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Rota auxiliar para debug (remover em produção)
router.get('/api/pagamentos/debug', authMiddleware, async (req, res) => {
  try {
    // Teste de compatibilidade de tipos
    const tipoTeste = await db.execute(sql`
      SELECT 
        p.id as proposta_id_uuid,
        p.id::text as proposta_id_text,
        ic.proposta_id as boleto_proposta_id,
        (p.id::text = ic.proposta_id) as comparacao_resultado
      FROM propostas p
      LEFT JOIN inter_collections ic ON p.id::text = ic.proposta_id
      LIMIT 5
    `);

    res.json({
      teste_tipos: tipoTeste,
      message: 'Teste de compatibilidade de tipos executado com sucesso'
    });

  } catch (error) {
    res.status(500).json({
      error: error.message,
      message: 'Erro no teste de tipos'
    });
  }
});

export default router;