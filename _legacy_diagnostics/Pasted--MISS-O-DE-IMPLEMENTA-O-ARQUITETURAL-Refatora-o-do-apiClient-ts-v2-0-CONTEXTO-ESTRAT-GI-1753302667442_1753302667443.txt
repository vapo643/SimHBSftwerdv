# MISSÃO DE IMPLEMENTAÇÃO ARQUITETURAL: Refatoração do `apiClient.ts` (v2.0)

**CONTEXTO ESTRATÉGICO:**
Este prompt é o resultado final de um debate técnico rigoroso. Ele contém a arquitetura aprovada para a nova versão do nosso cliente de API, com foco em segurança, robustez e portabilidade. Siga as especificações com precisão absoluta.

**AÇÃO:**
Sua missão é refatorar o ficheiro `/client/src/lib/apiClient.ts`. Você irá decompor a lógica existente em classes de gestão especializadas e depois integrá-las de volta na função principal `apiClient`.

**ROADMAP DE EXECUÇÃO:**

**PASSO 1: Implementar o `TokenManager`**
* Crie uma classe singleton `TokenManager` para gerir o ciclo de vida do token de autenticação.
* **Lógica:**
    * Deve fazer o cache do `accessToken` em memória para evitar chamadas repetidas a `getSession()`.
    * Deve verificar a data de expiração do token (`exp` claim do JWT) antes de usá-lo.
    * Deve implementar uma lógica para renovar o token (`refreshToken`) se ele estiver expirado, e gerir promessas para evitar múltiplas renovações simultâneas.

**PASSO 2: Implementar o `ApiConfig`**
* Crie uma classe singleton `ApiConfig` para gerir as configurações de ambiente.
* **Lógica:**
    * Deve determinar a `baseUrl` da API com a seguinte prioridade: 1) Variável de ambiente `VITE_API_BASE_URL`, 2) Detecção automática do ambiente (Replit vs. local), 3) Fallback para `http://localhost:5000`.
    * Deve fornecer um método `buildUrl(endpoint)` que constrói a URL completa da requisição.

**PASSO 3: Implementar o `RequestManager`**
* Crie uma classe `RequestManager` com um método estático `fetchWithTimeout`.
* **Lógica:**
    * Utilize `AbortController` para implementar um timeout configurável (padrão: 15 segundos).
    * Implemente uma lógica de retentativa (`retry`) automática (padrão: 2 tentativas) com delay exponencial para erros de rede e timeouts.

**PASSO 4: Padronizar a Classe `ApiError`**
* Refatore a classe `ApiError` existente.
* **Lógica:**
    * A classe deve ser capaz de receber e armazenar um código de erro padronizado (ex: `VALIDATION_ERROR`, `TOKEN_EXPIRED`).
    * Deve incluir um método para inferir um código de erro a partir do status HTTP.
    * Deve incluir uma propriedade `isRetryable` que determina se o erro é transiente (ex: `503`, `504`, timeout).

**PASSO 5: Integrar Tudo no `apiClient` Principal**
* Refatore a função principal `apiClient` para orquestrar estas novas classes:
    1.  Use `ApiConfig.buildUrl(url)` para construir a URL completa.
    2.  Use `TokenManager.getInstance().getValidToken()` para obter o token de autenticação.
    3.  Faça a chamada de rede usando `RequestManager.fetchWithTimeout`.
    4.  Em caso de erro, intercepte a falha e, se o erro for de token expirado (`401`), tente usar o `TokenManager` para renovar o token e reenviar a requisição uma vez.
    5.  Ao capturar erros, instancie a nova classe `ApiError` aprimorada.

Execute este plano passo a passo para construir o nosso novo cliente de API robusto.