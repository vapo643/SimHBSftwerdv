# Runbook: Procedimento de Restaura√ß√£o de Emerg√™ncia

## Objetivo
Guia passo-a-passo para restaura√ß√£o completa do sistema Simpix em cen√°rios de desastre, incluindo rollback de migra√ß√µes e restaura√ß√£o de dados a partir de backups.

## Cen√°rios de Ativa√ß√£o
- **Falha Cr√≠tica de Deploy:** Sistema inacess√≠vel ap√≥s deploy
- **Corrup√ß√£o de Dados:** Dados cr√≠ticos corrompidos ou perdidos
- **Ataque/Breach:** Comprometimento de seguran√ßa detectado
- **Falha de Infraestrutura:** Perda total ou parcial de dados
- **Rollback Urgente:** Necessidade de voltar estado anterior

## ‚ö†Ô∏è CRIT√âRIOS DE EMERG√äNCIA
**‚è±Ô∏è SLA:** M√°ximo 4 horas para restaura√ß√£o completa
**üë• Autoriza√ß√£o:** Requer aprova√ß√£o de 2 pessoas (Tech Lead + Operations Manager)

---

## üö® FASE 0: AVALIA√á√ÉO E PREPARA√á√ÉO (0-30min)

### 0.1 Avalia√ß√£o da Situa√ß√£o
```bash
# VERIFICAR GRAVIDADE DO PROBLEMA
echo "=== DIAGN√ìSTICO INICIAL ==="
echo "1. Sistema respondendo?"
curl -f http://localhost:5000/health || echo "‚ùå SISTEMA DOWN"

echo "2. Banco de dados acess√≠vel?"
psql $DATABASE_URL -c "SELECT 1;" || echo "‚ùå DATABASE DOWN"

echo "3. √öltimas tentativas de opera√ß√£o:"
tail -50 logs/combined.log | grep -E "(ERROR|CRITICAL|FATAL)"
```

### 0.2 Determinar Estrat√©gia de Restaura√ß√£o

| Cen√°rio | Estrat√©gia | Tempo Estimado |
|---------|------------|----------------|
| Deploy com bugs | Rollback c√≥digo + migra√ß√£o | 30-60min |
| Corrup√ß√£o parcial | Restaura√ß√£o seletiva | 60-120min |
| Perda total de dados | Restaura√ß√£o completa | 120-240min |
| Compromisso seguran√ßa | Restaura√ß√£o + Auditoria | 240min+ |

### 0.3 Notificar Stakeholders
```bash
# Template de notifica√ß√£o de emerg√™ncia
echo "üö® PROCEDIMENTO DE RESTORE INICIADO - [DATA/HORA]
Problema: [DESCRI√á√ÉO_BREVE]
Estrat√©gia: [ROLLBACK/RESTORE_PARCIAL/RESTORE_COMPLETO]
Tempo Estimado: [MINUTOS] minutos
Respons√°vel: [NOME]
Status: EM PROGRESSO" | mail -s "EMERG√äNCIA: Restore Simpix" operations@empresa.com
```

---

## üîÑ FASE 1: ROLLBACK DE C√ìDIGO E MIGRA√á√ïES (30-60min)

### 1.1 Identificar Ponto de Restaura√ß√£o
```bash
# Listar √∫ltimas migra√ß√µes aplicadas
echo "SELECT * FROM __drizzle_migrations ORDER BY created_at DESC LIMIT 10;" | psql $DATABASE_URL

# Verificar commits recentes
git log --oneline -10

# Identificar √∫ltimo estado est√°vel conhecido
echo "üîç √öLTIMO ESTADO EST√ÅVEL: [COMMIT_HASH] - [DATA]"
```

### 1.2 Executar Rollback de Migra√ß√µes
**‚ö†Ô∏è ATEN√á√ÉO: Opera√ß√£o destrutiva - pode causar perda de dados**

```bash
# Rollback de 1 migra√ß√£o (padr√£o)
tsx scripts/rollback.ts 1

# Rollback m√∫ltiplas migra√ß√µes (usar com extrema cautela)
tsx scripts/rollback.ts 3

# Verificar resultado
echo "SELECT hash, success, error_message FROM __drizzle_migrations ORDER BY created_at DESC LIMIT 5;" | psql $DATABASE_URL
```

### 1.3 Rollback de C√≥digo
```bash
# Criar branch de emerg√™ncia
git checkout -b emergency-rollback-$(date +%Y%m%d-%H%M%S)

# Resetar para commit est√°vel
git reset --hard [COMMIT_HASH_EST√ÅVEL]

# Reiniciar aplica√ß√£o
# Em desenvolvimento: autom√°tico
# Em produ√ß√£o: seguir procedimento espec√≠fico do ambiente
```

---

## üíæ FASE 2: RESTAURA√á√ÉO DE DADOS (60-180min)

### 2.1 Preparar Ambiente para Restore
```bash
# Parar aplica√ß√£o (evitar corrup√ß√£o durante restore)
pkill -f "node.*server"

# Criar backup do estado atual (mesmo corrompido)
pg_dump $DATABASE_URL > emergency_backup_$(date +%Y%m%d_%H%M%S).sql

# Verificar backups dispon√≠veis
ls -la backups/ | head -10
echo "üíæ BACKUP MAIS RECENTE: $(ls -t backups/*.gz | head -1)"
```

### 2.2 Validar Integridade do Backup
```bash
# Escolher backup para restaura√ß√£o
BACKUP_FILE=$(ls -t backups/*.gz | head -1)
echo "üìÇ USANDO BACKUP: $BACKUP_FILE"

# Verificar integridade
gunzip -t $BACKUP_FILE
if [ $? -eq 0 ]; then
    echo "‚úÖ Backup √≠ntegro"
else
    echo "‚ùå Backup corrompido - tentando backup anterior"
    BACKUP_FILE=$(ls -t backups/*.gz | head -2 | tail -1)
fi

# Descomprimir temporariamente
gunzip -c $BACKUP_FILE > restore_temp.sql
echo "üìä TAMANHO DO BACKUP: $(wc -l < restore_temp.sql) linhas"
```

### 2.3 Executar Restaura√ß√£o Completa
**‚ö†Ô∏è PROCESSO DESTRUTIVO - CONFIRMAR AUTORIZA√á√ÉO**

```bash
echo "üö® ATEN√á√ÉO: Esta opera√ß√£o ir√° DESTRUIR todos os dados atuais"
echo "Backup sendo usado: $BACKUP_FILE"
echo "Pressione ENTER para continuar ou CTRL+C para cancelar"
read

# Dropar banco atual e recriar
dropdb -U [USERNAME] simpix_prod
createdb -U [USERNAME] simpix_prod

# Restaurar dados do backup
psql $DATABASE_URL < restore_temp.sql

# Verificar restaura√ß√£o
echo "SELECT COUNT(*) as total_propostas FROM propostas;" | psql $DATABASE_URL
echo "SELECT COUNT(*) as total_usuarios FROM users;" | psql $DATABASE_URL

# Limpeza
rm restore_temp.sql
```

### 2.4 Restaura√ß√£o Seletiva (Alternativa)
**Para casos onde apenas algumas tabelas precisam ser restauradas:**

```bash
# Extrair apenas tabelas espec√≠ficas do backup
pg_restore -t propostas -t users restore_temp.sql > selective_restore.sql

# Fazer backup das tabelas que ser√£o substitu√≠das
pg_dump $DATABASE_URL -t propostas -t users > current_tables_backup.sql

# Dropar e restaurar tabelas espec√≠ficas
echo "DROP TABLE propostas CASCADE;" | psql $DATABASE_URL
echo "DROP TABLE users CASCADE;" | psql $DATABASE_URL
psql $DATABASE_URL < selective_restore.sql
```

---

## üîß FASE 3: VALIDA√á√ÉO E REATIVA√á√ÉO (180-240min)

### 3.1 Valida√ß√£o de Integridade
```bash
# Verificar tabelas cr√≠ticas
echo "=== VALIDA√á√ÉO DE DADOS ==="
echo "Propostas: $(echo "SELECT COUNT(*) FROM propostas;" | psql $DATABASE_URL -t)"
echo "Usu√°rios: $(echo "SELECT COUNT(*) FROM users;" | psql $DATABASE_URL -t)"  
echo "Lojas: $(echo "SELECT COUNT(*) FROM lojas;" | psql $DATABASE_URL -t)"

# Verificar integridade referencial
echo "=== VERIFICA√á√ÉO DE CONSTRAINTS ==="
echo "
DO \$\$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (SELECT conname, conrelid::regclass, pg_get_constraintdef(oid) 
              FROM pg_constraint WHERE contype = 'f') 
    LOOP
        EXECUTE format('SET constraint_exclusion = off; EXPLAIN (ANALYZE, BUFFERS) %s', 
                      replace(pg_get_constraintdef(r.oid), 'FOREIGN KEY', 'SELECT 1 WHERE EXISTS(SELECT 1 FROM'));
        RAISE INFO 'Constraint % on % validated', r.conname, r.conrelid;
    END LOOP;
END;
\$\$;" | psql $DATABASE_URL
```

### 3.2 Testes de Funcionalidade Cr√≠tica
```bash
# Testar endpoints essenciais
echo "=== TESTES DE FUNCIONALIDADE ==="

# 1. Health check
curl -f http://localhost:5000/health && echo "‚úÖ Health OK" || echo "‚ùå Health FAIL"

# 2. Autentica√ß√£o
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"test"}' && echo "‚úÖ Auth OK" || echo "‚ùå Auth FAIL"

# 3. Dashboard
curl -f http://localhost:5000/api/dashboard && echo "‚úÖ Dashboard OK" || echo "‚ùå Dashboard FAIL"

# 4. Cria√ß√£o de proposta (teste cr√≠tico)
curl -X POST http://localhost:5000/api/propostas \
  -H "Content-Type: application/json" \
  -d '{"test":"restore_validation"}' && echo "‚úÖ Propostas OK" || echo "‚ùå Propostas FAIL"
```

### 3.3 Reativar Monitoramento
```bash
# Verificar se Sentry est√° funcionando
curl -f $VITE_SENTRY_DSN && echo "‚úÖ Sentry conectado"

# Verificar filas
curl -f http://localhost:5000/admin/queues && echo "‚úÖ Filas ativas"

# Reiniciar jobs cr√≠ticos
echo "üìã Reiniciando processamento de jobs..."
# Comandos espec√≠ficos para restart de jobs
```

---

## üìä FASE 4: MONITORAMENTO P√ìS-RESTORE (240+min)

### 4.1 Monitoramento Intensivo (Primeiras 2 horas)
```bash
# Script de monitoramento cont√≠nuo
watch -n 30 '
echo "=== $(date) ==="
echo "Sistema: $(curl -s http://localhost:5000/health | jq -r .status 2>/dev/null || echo "DOWN")"
echo "Propostas: $(echo "SELECT COUNT(*) FROM propostas;" | psql $DATABASE_URL -t | tr -d " ")"
echo "Erros (5min): $(grep "$(date -d "5 minutes ago" "+%Y-%m-%d %H:%M")" logs/combined.log | grep -c ERROR)"
echo "CPU: $(top -bn1 | grep "Cpu(s)" | awk "{print $2}" | cut -d"%" -f1)"
echo "Mem√≥ria: $(free -m | awk "NR==2{printf \"%.1f\", $3*100/$2}")\%"
echo "=================="
'
```

### 4.2 Relat√≥rio de Restore
**Criar documenta√ß√£o completa do incidente:**

```markdown
RELAT√ìRIO DE RESTORE DE EMERG√äNCIA
==================================
Data: [DATA]
Dura√ß√£o: [IN√çCIO] - [FIM] ([TOTAL] minutos)
Respons√°vel: [NOME]

SITUA√á√ÉO INICIAL:
- Problema: [DESCRI√á√ÉO DETALHADA]
- Gravidade: [BAIXA/M√âDIA/ALTA/CR√çTICA]
- Sistemas Afetados: [LISTA]
- Usu√°rios Impactados: [N√öMERO ESTIMADO]

ESTRAT√âGIA EXECUTADA:
‚ñ° Rollback de c√≥digo: [SIM/N√ÉO]
‚ñ° Rollback de migra√ß√£o: [SIM/N√ÉO] - [X] steps
‚ñ° Restore completo: [SIM/N√ÉO]
‚ñ° Restore seletivo: [SIM/N√ÉO] - Tabelas: [LISTA]

BACKUP UTILIZADO:
- Arquivo: [NOME_DO_BACKUP]
- Data do backup: [DATA]
- Idade dos dados: [X] horas
- Integridade: [OK/PARCIAL/PROBLEMAS]

DADOS RESTAURADOS:
- Propostas: [N√öMERO]
- Usu√°rios: [N√öMERO]
- Per√≠odo coberto: [DATA_IN√çCIO] - [DATA_FIM]
- Dados perdidos: [PER√çODO_PERDIDO]

VALIDA√á√ïES EXECUTADAS:
‚ñ° Integridade referencial
‚ñ° Testes de funcionalidade
‚ñ° Verifica√ß√£o de performance  
‚ñ° Valida√ß√£o de seguran√ßa

LI√á√ïES APRENDIDAS:
[MELHORIAS IDENTIFICADAS]

A√á√ïES PREVENTIVAS:
[MEDIDAS PARA EVITAR REINCID√äNCIA]
```

---

## üö® TROUBLESHOOTING COMUM

### Problema: Backup Corrompido
```bash
# Tentar backup anterior
BACKUP_FILES=($(ls -t backups/*.gz))
for backup in "${BACKUP_FILES[@]}"; do
    echo "Testando: $backup"
    gunzip -t "$backup" && echo "‚úÖ OK" && break
done
```

### Problema: Migra√ß√£o N√£o Reverte
```bash
# For√ßar rollback manual
echo "DELETE FROM __drizzle_migrations WHERE hash='[HASH_PROBLEM√ÅTICO]';" | psql $DATABASE_URL

# Reverter mudan√ßas SQL manualmente
echo "DROP TABLE IF EXISTS [TABELA_CRIADA_NA_MIGRA√á√ÉO];" | psql $DATABASE_URL
```

### Problema: Restore Parcial
```bash
# Identificar tabelas faltantes
echo "
SELECT schemaname, tablename 
FROM pg_tables 
WHERE schemaname = 'public'
ORDER BY tablename;
" | psql $DATABASE_URL > current_tables.txt

# Comparar com backup esperado
echo "Tabelas esperadas vs encontradas:"
diff expected_tables.txt current_tables.txt
```

---

## ‚ö° COMANDOS DE EMERG√äNCIA

### Abortar Restore em Andamento:
```bash
# Matar processos do PostgreSQL relacionados ao restore
pkill -f "psql.*$DATABASE_URL"
```

### Restore Ultra-R√°pido (√öltimas 24h):
```bash
# Para emerg√™ncias onde dados das √∫ltimas 24h s√£o suficientes
pg_dump $DATABASE_URL --where="created_at > NOW() - INTERVAL '1 day'" > quick_restore.sql
```

### Verifica√ß√£o Express de Integridade:
```bash
# Teste r√°pido dos dados cr√≠ticos
echo "SELECT 'propostas', COUNT(*) FROM propostas 
UNION ALL SELECT 'users', COUNT(*) FROM users 
UNION ALL SELECT 'lojas', COUNT(*) FROM lojas;" | psql $DATABASE_URL
```

---

## üìû CONTATOS DE EMERG√äNCIA

**24/7 On-Call:**
- Tech Lead: [TELEFONE]
- DevOps: [TELEFONE] 
- Database Admin: [TELEFONE]

**Escala√ß√£o Externa:**
- Supabase Support: [SUPORTE_SUPABASE]
- Infrastructure Provider: [PROVIDER_SUPPORT]

**Comunica√ß√£o:**
- Slack: #emergency-response
- Email: emergency@[EMPRESA].com
- Status Page: status.[EMPRESA].com