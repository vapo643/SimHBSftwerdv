import { Request, Response } from "express";
import { AuthenticatedRequest } from "../lib/jwt-auth-middleware";
import { createServerSupabaseAdminClient } from "../lib/supabase";
import { db } from "../lib/supabase.js";
import { propostas, statusContextuais } from "@shared/schema";
import { eq, and } from "drizzle-orm";
import { transitionTo, InvalidTransitionError } from "../services/statusFsmService";

/**
 * Alterar status da proposta entre ativa e suspensa
 * PUT /api/propostas/:id/toggle-status
 */
export const togglePropostaStatus = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id: propostaId } = req.params;

    if (!propostaId) {
      return res.status(400).json({ message: "ID da proposta é obrigatório" });
    }

    const supabase = createServerSupabaseAdminClient();

    // 1. Buscar a proposta atual
    const { data: proposta, error: fetchError } = await supabase
      .from("propostas")
      .select("id, status, user_id")
      .eq("id", propostaId)
      .single();

    if (fetchError || !proposta) {
      return res.status(404).json({ message: "Proposta não encontrada" });
    }

    // 2. Verificar se o usuário é o atendente da proposta ou administrador
    if (req.user?.role !== "ADMINISTRADOR" && proposta.user_id !== req.user?.id) {
      return res.status(403).json({
        message: "Você não tem permissão para alterar o status desta proposta",
      });
    }

    // 3. Verificar se a proposta está em um status que pode ser suspensa
    const statusSuspensiveis = ["rascunho", "aguardando_analise", "em_analise", "pendente"];
    if (!statusSuspensiveis.includes(proposta.status) && proposta.status !== "suspensa") {
      return res.status(400).json({
        message: "Esta proposta não pode ser suspensa/reativada no status atual",
      });
    }

    // 4. Determinar o novo status
    let novoStatus: string;
    if (proposta.status === "suspensa") {
      // Reativar: voltar para aguardando_analise
      novoStatus = "aguardando_analise";
    } else {
      // Suspender
      novoStatus = "suspensa";
    }

    // 5. PAM V1.0 - Usar FSM para validação de transição de status
    try {
      await transitionTo({
        propostaId,
        novoStatus,
        userId: req.user?.id || "sistema",
        contexto: "geral",
        observacoes: `Status ${novoStatus === "suspensa" ? "suspenso" : "reativado"} pelo usuário`,
        metadata: {
          tipoAcao: novoStatus === "suspensa" ? "SUSPENDER_PROPOSTA" : "REATIVAR_PROPOSTA",
          statusAnterior: proposta.status,
          usuarioRole: req.user?.role || "desconhecido",
          motivoSuspensao: novoStatus === "suspensa" ? "Ação manual do usuário" : null
        }
      });
    } catch (error) {
      if (error instanceof InvalidTransitionError) {
        return res.status(409).json({
          message: error.message,
          error: "INVALID_TRANSITION"
        });
      }
      console.error("Erro ao atualizar status:", error);
      return res.status(500).json({
        message: "Erro ao atualizar status da proposta"
      });
    }

    // 6. Criar log de comunicação adicional (mantido para compatibilidade)
    await supabase.from("comunicacao_logs").insert({
      proposta_id: propostaId,
      usuario_id: req.user?.id,
      tipo: "status_change",
      mensagem: `Status alterado de ${proposta.status} para ${novoStatus}`,
      created_at: new Date().toISOString(),
    });

    res.json({
      success: true,
      propostaId,
      statusAnterior: proposta.status,
      statusNovo: novoStatus,
      message:
        novoStatus === "suspensa"
          ? "Proposta suspensa com sucesso"
          : "Proposta reativada com sucesso",
    });
  } catch (error) {
    console.error("Erro ao alterar status da proposta:", error);
    res.status(500).json({
      message: "Erro interno do servidor ao alterar status",
    });
  }
};

/**
 * Buscar CCB assinada da proposta 
 * GET /api/propostas/:id/ccb
 * CORRIGIDO: Agora usa o campo caminho_ccb_assinado do banco
 */
export const getCcbAssinada = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id: propostaId } = req.params;

    if (!propostaId) {
      return res.status(400).json({ message: "ID da proposta é obrigatório" });
    }

    console.log(`[CCB] Buscando CCB para proposta: ${propostaId}`);

    // Buscar proposta com dados do ClickSign
    const [proposta] = await db
      .select()
      .from(propostas)
      .where(eq(propostas.id, propostaId))
      .limit(1);

    if (!proposta) {
      return res.status(404).json({ message: "Proposta não encontrada" });
    }

    console.log(`[CCB] Proposta encontrada. Caminho CCB: ${proposta.caminhoCcbAssinado}`);

    const supabase = createServerSupabaseAdminClient();

    // PRIORIDADE 1: Usar caminho_ccb_assinado se disponível
    if (proposta.caminhoCcbAssinado) {
      try {
        console.log(`[CCB] Tentando gerar URL para caminho: ${proposta.caminhoCcbAssinado}`);
        
        const { data: urlData, error: signError } = await supabase.storage
          .from("documents")
          .createSignedUrl(proposta.caminhoCcbAssinado, 3600); // 1 hora

        if (signError) {
          console.error(`[CCB] Erro ao gerar URL assinada:`, signError);
        } else if (urlData?.signedUrl) {
          console.log(`[CCB] ✅ URL assinada gerada com sucesso`);
          return res.json({
            url: urlData.signedUrl,
            nome: `CCB_${proposta.clienteNome}_${propostaId}.pdf`,
            status: "assinado",
            dataAssinatura: proposta.dataAprovacao,
            fonte: "storage",
            caminho: proposta.caminhoCcbAssinado,
          });
        }
      } catch (storageError) {
        console.error("[CCB] Erro ao buscar CCB pelo caminho salvo:", storageError);
      }
    }

    // PRIORIDADE 2: Tentar caminho legado para compatibilidade
    try {
      console.log(`[CCB] Tentando caminho legado: proposta-${propostaId}/ccb-assinada.pdf`);
      const { data: urlData } = await supabase.storage
        .from("documents")
        .createSignedUrl(`proposta-${propostaId}/ccb-assinada.pdf`, 3600);

      if (urlData?.signedUrl) {
        console.log(`[CCB] ✅ URL legada gerada com sucesso`);
        return res.json({
          url: urlData.signedUrl,
          nome: `CCB_${proposta.clienteNome}_${propostaId}.pdf`,
          status: "assinado",
          dataAssinatura: proposta.dataAprovacao,
          fonte: "storage_legado",
        });
      }
    } catch (storageError) {
      console.error("[CCB] Erro ao buscar no Storage legado:", storageError);
    }

    // PRIORIDADE 3: ClickSign como fallback
    if (proposta.clicksignDocumentKey) {
      console.log(`[CCB] Usando ClickSign como fallback: ${proposta.clicksignDocumentKey}`);
      return res.json({
        clicksignDocumentKey: proposta.clicksignDocumentKey,
        nome: `CCB_${proposta.clienteNome}_${propostaId}.pdf`,
        status: "assinado",
        dataAssinatura: proposta.dataAprovacao,
        fonte: "clicksign",
        message: "Documento disponível no ClickSign. Acesse sua conta para visualizar.",
      });
    }

    // Se chegou até aqui, CCB não foi encontrada
    console.log(`[CCB] ❌ CCB não encontrada para proposta ${propostaId}`);
    return res.status(404).json({
      message: "CCB assinada não encontrada. Verifique se o documento foi processado corretamente.",
      debug: {
        propostaId,
        caminhosSalvos: proposta.caminhoCcbAssinado,
        clicksignKey: proposta.clicksignDocumentKey,
        ccbGerado: proposta.ccbGerado,
        assinaturaConcluida: proposta.assinaturaEletronicaConcluida
      }
    });
  } catch (error) {
    console.error("Erro ao buscar CCB:", error);
    res.status(500).json({
      message: "Erro interno do servidor ao buscar CCB",
    });
  }
};
