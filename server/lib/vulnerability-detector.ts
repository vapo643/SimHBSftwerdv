/**
 * Detector Aut√¥nomo de Vulnerabilidades - Machine Learning
 *
 * Usa t√©cnicas de ML para detectar padr√µes an√¥malos e
 * vulnerabilidades desconhecidas em tempo real.
 */

import { EventEmitter } from 'events';
import { db } from './supabase';
import { security_logs } from '../../shared/schema';
import { sql } from 'drizzle-orm';

export interface AnomalyDetection {
  id: string;
  type: 'behavioral' | 'statistical' | 'pattern' | 'temporal';
  confidence: number; // 0-1
  description: string;
  metadata: Record<string, any>;
  timestamp: Date;
}

export interface BehaviorProfile {
  entity: string; // IP, User, Endpoint
  baseline: {
    requestsPerMinute: number[];
    responseTimeMs: number[];
    errorRate: number;
    commonPatterns: Map<string, number>;
    timeDistribution: number[]; // 24 hours
  };
  current: {
    requestsPerMinute: number;
    responseTimeMs: number;
    errorRate: number;
    patterns: Map<string, number>;
  };
  deviationScore: number;
}

export class VulnerabilityDetector extends EventEmitter {
  private profiles: Map<string, BehaviorProfile> = new Map();
  private anomalies: Map<string, AnomalyDetection> = new Map();
  private learningWindow = 7 * 24 * 60 * 60 * 1000; // 7 dias
  private detectionThreshold = 0.85;

  // Modelo de detec√ß√£o estat√≠stica
  private statisticalModel = {
    mean: 0,
    stdDev: 0,
    samples: [] as number[],
  };

  constructor() {
    super();
    this.initialize();
  }

  private async initialize() {
    // Carregar dados hist√≥ricos para treinamento
    await this.trainModel();

    // Iniciar detec√ß√£o em tempo real
    this.startRealTimeDetection();
  }

  /**
   * Treinar modelo com dados hist√≥ricos
   */
  private async trainModel() {
    console.log('üß† [ML] Treinando modelo de detec√ß√£o...');

    const historicalData = await db
      .select()
      .from(security_logs)
      .where(sql`created_at > NOW() - INTERVAL '30 days'`)
      .limit(100000);

    // Extrair features
    const features = this.extractFeatures(historicalData);

    // Calcular estat√≠sticas base
    this.calculateStatistics(features);

    // Criar perfis comportamentais
    this.createBehaviorProfiles(historicalData);

    console.log(`‚úÖ [ML] Modelo treinado com ${historicalData.length} amostras`);
  }

  /**
   * Extrair caracter√≠sticas dos dados
   */
  private extractFeatures(data: unknown[]): number[][] {
    return data.map((log) => {
      const hour = new Date(log.created_at).getHours();
      const dayOfWeek = new Date(log.created_at).getDay();

      return [
        // Temporal features
        hour,
        dayOfWeek,
        hour < 6 || hour > 22 ? 1 : 0, // Hor√°rio suspeito

        // Request features
        log.endpoint?.length || 0,
        log.method == 'POST' ? 1 : 0,
        log.method == 'DELETE' ? 1 : 0,

        // Response features
        log.status_code >= 400 ? 1 : 0,
        log.status_code == 500 ? 1 : 0,

        // Pattern features
        log.endpoint?.includes('admin') ? 1 : 0,
        log.endpoint?.includes('..') ? 1 : 0,
        log.user_agent?.includes('bot') ? 1 : 0,
      ];
    });
  }

  /**
   * Calcular estat√≠sticas para detec√ß√£o de anomalias
   */
  private calculateStatistics(features: number[][]) {
    const flattened = features.flat();
    const n = flattened.length;

    // M√©dia
    this.statisticalModel.mean = flattened.reduce((a, b) => a + b, 0) / n;

    // Desvio padr√£o
    const variance =
      flattened.reduce((sum, x) => {
        return sum + Math.pow(x - this.statisticalModel.mean, 2);
      }, 0) / n;

    this.statisticalModel.stdDev = Math.sqrt(variance);
    this.statisticalModel.samples = flattened.slice(-1000); // √öltimas 1000 amostras
  }

  /**
   * Criar perfis comportamentais
   */
  private createBehaviorProfiles(data: unknown[]) {
    // Agrupar por entidade (IP, User, Endpoint)
    const grouped = new Map<string, any[]>();

    data.forEach((log) => {
      const entities = [
        `ip:${log.ip_address}`,
        `user:${log.user_id || 'anonymous'}`,
        `endpoint:${log.endpoint}`,
      ];

      entities.forEach((entity) => {
        if (!grouped.has(entity)) {
          grouped.set(entity, []);
        }
        grouped.get(entity)!.push(log);
      });
    });

    // Criar perfil para cada entidade
    grouped.forEach((logs, entity) => {
      const profile = this.buildProfile(entity, logs);
      this.profiles.set(entity, profile);
    });
  }

  /**
   * Construir perfil comportamental
   */
  private buildProfile(entity: string, logs: unknown[]): BehaviorProfile {
    // Calcular m√©tricas por hora
    const hourlyMetrics = new Array(24).fill(0).map(() => ({
      requests: 0,
      errors: 0,
      totalTime: 0,
    }));

    logs.forEach((log) => {
      const hour = new Date(log.created_at).getHours();
      hourlyMetrics[hour].requests++;
      if (log.status_code >= 400) hourlyMetrics[hour].errors++;
      if (log.response_time) hourlyMetrics[hour].totalTime += log.response_time;
    });

    // Extrair padr√µes comuns
    const patterns = new Map<string, number>();
    logs.forEach((log) => {
      const pattern = `${log.method}:${log.endpoint}`;
      patterns.set(pattern, (patterns.get(pattern) || 0) + 1);
    });

    return {
      entity,
      baseline: {
        requestsPerMinute: hourlyMetrics.map((h) => h.requests / 60),
        responseTimeMs: hourlyMetrics.map((h) => (h.requests > 0 ? h.totalTime / h.requests : 0)),
        errorRate: logs.filter((l) => l.status_code >= 400).length / logs.length,
        commonPatterns: patterns,
        timeDistribution: hourlyMetrics.map((h) => h.requests),
      },
      current: {
        requestsPerMinute: 0,
        responseTimeMs: 0,
        errorRate: 0,
        patterns: new Map(),
      },
      deviationScore: 0,
    };
  }

  /**
   * Detec√ß√£o em tempo real
   */
  private startRealTimeDetection() {
    // Detectar anomalias a cada minuto
    setInterval(() => {
      this.detectAnomalies();
    }, 60000);
  }

  /**
   * Analisar requisi√ß√£o em tempo real
   */
  async analyzeRequest(requestData: {
    method: string;
    path: string;
    headers: unknown;
    body: unknown;
    ip: string;
    userId?: string;
    responseTime: number;
    statusCode: number;
  }): Promise<AnomalyDetection[]> {
    const anomalies: AnomalyDetection[] = [];

    // 1. Detec√ß√£o estat√≠stica
    const statisticalAnomaly = this.detectStatisticalAnomaly(requestData);
    if (statisticalAnomaly) anomalies.push(statisticalAnomaly);

    // 2. Detec√ß√£o comportamental
    const behavioralAnomalies = this.detectBehavioralAnomalies(requestData);
    anomalies.push(...behavioralAnomalies);

    // 3. Detec√ß√£o de padr√µes
    const patternAnomalies = this.detectPatternAnomalies(requestData);
    anomalies.push(...patternAnomalies);

    // 4. Detec√ß√£o temporal
    const temporalAnomaly = this.detectTemporalAnomaly(requestData);
    if (temporalAnomaly) anomalies.push(temporalAnomaly);

    // Emitir eventos para anomalias de alta confian√ßa
    anomalies
      .filter((a) => a.confidence > this.detectionThreshold)
      .forEach((anomaly) => {
        this.emit('anomaly', anomaly);
        this.anomalies.set(anomaly.id, anomaly);
      });

    return anomalies;
  }

  /**
   * Detec√ß√£o estat√≠stica usando Z-score
   */
  private detectStatisticalAnomaly(data): AnomalyDetection | null {
    const features = this.extractSingleFeature(_data);
    const featureSum = features.reduce((a, b) => a + b, 0);

    // Calcular Z-score
    const zScore =
      Math.abs(featureSum - this.statisticalModel.mean) / this.statisticalModel.stdDev;

    if (zScore > 3) {
      // 3 desvios padr√£o
      return {
        id: this.generateId(),
        type: 'statistical',
        confidence: Math.min(zScore / 5, 1), // Normalizar para 0-1
        description: `Comportamento estatisticamente an√¥malo (Z-score: ${zScore.toFixed(2)})`,
        metadata: { zScore, features },
        timestamp: new Date(),
      };
    }

    return null;
  }

  /**
   * Detec√ß√£o de anomalias comportamentais
   */
  private detectBehavioralAnomalies(data): AnomalyDetection[] {
    const anomalies: AnomalyDetection[] = [];
    const entities = [
      `ip:${data.ip}`,
      `user:${data.userId || 'anonymous'}`,
      `endpoint:${data.method}:${data.path}`,
    ];

    entities.forEach((entity) => {
      const profile = this.profiles.get(entity);
      if (!profile) return;

      // Atualizar perfil atual
      profile.current.requestsPerMinute++;
      if (data.statusCode >= 400) {
        profile.current.errorRate = profile.current.errorRate * 0.95 + 0.05; // M√©dia m√≥vel
      }

      // Calcular desvio
      const hour = new Date().getHours();
      const expectedRPM = profile.baseline.requestsPerMinute[hour];
      const deviation = Math.abs(profile.current.requestsPerMinute - expectedRPM);

      if (deviation > expectedRPM * 3) {
        // 300% de desvio
        anomalies.push({
          id: this.generateId(),
          type: 'behavioral',
          confidence: Math.min(deviation / (expectedRPM * 5), 1),
          description: `Taxa de requisi√ß√µes anormal para ${entity}`,
          metadata: {
            expected: expectedRPM,
            actual: profile.current.requestsPerMinute,
            deviation,
          },
          timestamp: new Date(),
        });
      }
    });

    return anomalies;
  }

  /**
   * Detec√ß√£o de padr√µes an√¥malos
   */
  private detectPatternAnomalies(data): AnomalyDetection[] {
    const anomalies: AnomalyDetection[] = [];

    // Padr√µes suspeitos conhecidos
    const suspiciousPatterns = [
      {
        name: 'Sequential ID Scanning',
        regex: /\/(users?|items?|products?)\/\d+$/,
        check: (matches: string[]) => {
          const ids = matches.map((m) => parseInt(m.match(/\d+$/)![0]));
          const sequential = ids.every((id, i) => i == 0 || id == ids[i - 1] + 1);
          return sequential && ids.length > 5;
        },
      },
      {
        name: 'Automated Tool Signature',
        regex: /(sqlmap|nikto|nmap|burp|zap|acunetix)/i,
        check: () => true,
      },
      {
        name: 'Unusual HTTP Methods',
        regex: /^(TRACE|CONNECT|OPTIONS|PROPFIND)$/,
        check: () => /^(TRACE|CONNECT|OPTIONS|PROPFIND)$/.test(data.method),
      },
    ];

    // Verificar cada padr√£o
    suspiciousPatterns.forEach((pattern) => {
      const userAgent = data.headers['user-agent'] || '';
      if (pattern.regex.test(userAgent) || pattern.regex.test(data.path)) {
        anomalies.push({
          id: this.generateId(),
          type: 'pattern',
          confidence: 0.9,
          description: `Padr√£o suspeito detectado: ${pattern.name}`,
          metadata: {
            pattern: pattern.name,
            evidence: { path: data.path, userAgent },
          },
          timestamp: new Date(),
        });
      }
    });

    return anomalies;
  }

  /**
   * Detec√ß√£o de anomalias temporais
   */
  private detectTemporalAnomaly(data): AnomalyDetection | null {
    const hour = new Date().getHours();
    const dayOfWeek = new Date().getDay();

    // Detectar acesso em hor√°rios incomuns
    if ((hour >= 0 && hour <= 5) || dayOfWeek == 0 || dayOfWeek == 6) {
      // Verificar se √© comum para este usu√°rio/IP
      const entity = `ip:${data.ip}`;
      const profile = this.profiles.get(entity);

      if (profile) {
        const normalActivity = profile.baseline.timeDistribution[hour];
        if (normalActivity < profile.baseline.timeDistribution.reduce((a, b) => a + b) * 0.01) {
          return {
            id: this.generateId(),
            type: 'temporal',
            confidence: 0.8,
            description: 'Atividade em hor√°rio incomum',
            metadata: {
              hour,
              dayOfWeek,
              normalActivity,
            },
            timestamp: new Date(),
          };
        }
      }
    }

    return null;
  }

  /**
   * Detectar anomalias gerais periodicamente
   */
  private async detectAnomalies() {
    // An√°lise de correla√ß√£o entre diferentes sinais
    const recentAnomalies = Array.from(this.anomalies.values()).filter(
      (a) => Date.now() - a.timestamp.getTime() < 300000
    ); // √öltimos 5 min

    // Detectar ataques coordenados
    const ipGroups = new Map<string, AnomalyDetection[]>();
    recentAnomalies.forEach((anomaly) => {
      const ip = anomaly.metadata.ip;
      if (ip) {
        if (!ipGroups.has(ip)) ipGroups.set(ip, []);
        ipGroups.get(ip)!.push(anomaly);
      }
    });

    // Alertar sobre IPs com m√∫ltiplas anomalias
    ipGroups.forEach((anomalies, ip) => {
      if (anomalies.length > 5) {
        this.emit('coordinated-attack', {
          ip,
          anomalies,
          confidence: Math.min(anomalies.length / 10, 1),
        });
      }
    });
  }

  /**
   * Obter relat√≥rio de anomalias
   */
  getAnomalyReport(): {
    total: number;
    byType: Record<string, number>;
    highConfidence: AnomalyDetection[];
    recentTrends: string[];
  } {
    const anomalies = Array.from(this.anomalies.values());
    const byType: Record<string, number> = {};

    anomalies.forEach((a) => {
      byType[a.type] = (byType[a.type] || 0) + 1;
    });

    return {
      total: anomalies.length,
      byType,
      highConfidence: anomalies
        .filter((a) => a.confidence > 0.9)
        .sort((a, b) => b.confidence - a.confidence)
        .slice(0, 10),
      recentTrends: this.detectTrends(),
    };
  }

  /**
   * Detectar tend√™ncias
   */
  private detectTrends(): string[] {
    const trends: string[] = [];
    const recentAnomalies = Array.from(this.anomalies.values()).filter(
      (a) => Date.now() - a.timestamp.getTime() < 3600000
    ); // √öltima hora

    // Agrupar por tipo
    const byType = new Map<string, number>();
    recentAnomalies.forEach((a) => {
      byType.set(a.type, (byType.get(a.type) || 0) + 1);
    });

    // Identificar tend√™ncias
    byType.forEach((count, type) => {
      if (count > 10) {
        trends.push(`Aumento de anomalias do tipo ${type} (${count} na √∫ltima hora)`);
      }
    });

    return trends;
  }

  // Helpers
  private generateId(): string {
    return `ANOM-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private extractSingleFeature(data): number[] {
    const hour = new Date().getHours();
    const dayOfWeek = new Date().getDay();

    return [
      hour,
      dayOfWeek,
      hour < 6 || hour > 22 ? 1 : 0,
      data.path.length,
      data.method == 'POST' ? 1 : 0,
      data.method == 'DELETE' ? 1 : 0,
      data.statusCode >= 400 ? 1 : 0,
      data.statusCode == 500 ? 1 : 0,
      data.path.includes('admin') ? 1 : 0,
      data.path.includes('..') ? 1 : 0,
      (data.headers['user-agent'] || '').includes('bot') ? 1 : 0,
    ];
  }
}

// Exportar inst√¢ncia singleton
let detector: VulnerabilityDetector | null = null;

export function getVulnerabilityDetector(): VulnerabilityDetector {
  if (!detector) {
    detector = new VulnerabilityDetector();
  }
  return detector;
}
